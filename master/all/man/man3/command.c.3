.TH "src/ckb-daemon/command.c" 3 "Tue May 16 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/command.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'command\&.h'\fP
.br
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'led\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTRY_WITH_RESET\fP(action)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBreadcmd\fP (\fBusbdevice\fP *kb, const char *line)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const char *const \fBcmd_strings\fP [(\fBCMD_LAST\fP-\fBCMD_FIRST\fP+2)-1]"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define TRY_WITH_RESET(action)"
\fBValue:\fP
.PP
.nf
while(action){              \
        if(usb_tryreset(kb)){   \
            free(word);         \
            return 1;           \
        }                       \
    }
.fi
.PP
Definition at line 58 of file command\&.c\&.
.PP
Referenced by readcmd()\&.
.SH "Function Documentation"
.PP 
.SS "int readcmd (\fBusbdevice\fP *kb, const char *line)"

.PP
.RS 4
Because length of word is length of line + 1, there should be no problem with buffer overflow\&. 
.RE
.PP

.PP
Definition at line 67 of file command\&.c\&.
.PP
References ACCEL, ACTIVE, usbdevice::active, BIND, CMD_COUNT, CMD_FIRST, cmd_strings, usbprofile::currentmode, DELAY, usbdevice::delay, DITHER, usbdevice::dither, devcmd::do_cmd, devcmd::do_io, devcmd::do_macro, DPI, DPISEL, ERASE, ERASEPROFILE, FEAT_ANSI, FEAT_BIND, FEAT_ISO, FEAT_LMASK, FEAT_MOUSEACCEL, FEAT_NOTIFY, usbdevice::features, lighting::forceupdate, FPS, FWUPDATE, GET, HAS_FEATURES, HWLOAD, HWSAVE, IAUTO, ID, IDLE, INDEX_OF, INOTIFY, IOFF, ION, IS_FULLRANGE, IS_MOUSE_DEV, keymap, LAYOUT, left, LIFT, usbmode::light, MACRO, mknotifynode(), MODE, usbprofile::mode, MODE_COUNT, N_KEYS_EXTENDED, NAME, NEEDS_FW_UPDATE, NONE, NOTIFY, NOTIFYOFF, NOTIFYON, OUTFIFO_MAX, POLLRATE, usbdevice::profile, PROFILEID, PROFILENAME, REBIND, RESTART, RGB, right(), rmnotifynode(), SCROLL_ACCELERATED, SCROLL_MAX, SCROLL_MIN, SCROLLSPEED, SNAP, SWITCH, TRY_WITH_RESET, UNBIND, usbdevice::usbdelay, and usbdevice::vtable\&.
.PP
Referenced by devmain()\&.
.PP
.nf
67                                             {
68     char* word = malloc(strlen(line) + 1);
69     int wordlen;
70     const char* newline = 0;
71     const devcmd* vt = kb->vtable;
72     usbprofile* profile = kb->profile;
73     usbmode* mode = 0;
74     int notifynumber = 0;
75     // Read words from the input
76     cmd command = NONE;
77     while(sscanf(line, "%s%n", word, &wordlen) == 1){
78         line += wordlen;
79         // If we passed a newline, reset the context
80         if(line > newline){
81             mode = profile->currentmode;
82             command = NONE;
83             notifynumber = 0;
84             newline = strchr(line, '\n');
85             if(!newline)
86                 newline = line + strlen(line);
87         }
88         // Check for a command word
89         for(int i = 0; i < CMD_COUNT - 1; i++){
90             if(!strcmp(word, cmd_strings[i])){
91                 command = i + CMD_FIRST;
92 #ifndef OS_MAC
93                 // Layout and mouse acceleration aren't used on Linux; ignore
94                 if(command == LAYOUT || command == ACCEL || command == SCROLLSPEED)
95                     command = NONE;
96 #endif
97                 // Most commands require parameters, but a few are actions in and of themselves
98                 if(command != SWITCH
99                         && command != HWLOAD && command != HWSAVE
100                         && command != ACTIVE && command != IDLE
101                         && command != ERASE && command != ERASEPROFILE
102                         && command != RESTART)
103                     goto next_loop;
104                 break;
105             }
106         }
107 
108         // Set current notification node when given @number
109         int newnotify;
110         if(sscanf(word, "@%u", &newnotify) == 1 && newnotify < OUTFIFO_MAX){
111             notifynumber = newnotify;
112             continue;
113         }
114 
115         // Reject unrecognized commands\&. Reject bind or notify related commands if the keyboard doesn't have the feature enabled\&.
116         if(command == NONE
117                 || ((!HAS_FEATURES(kb, FEAT_BIND) && (command == BIND || command == UNBIND || command == REBIND || command == MACRO || command == DELAY))
118                            || (!HAS_FEATURES(kb, FEAT_NOTIFY) && command == NOTIFY))){
119             next_loop:
120             continue;
121         }
122         // Reject anything not related to fwupdate if device has a bricked FW
123         if(NEEDS_FW_UPDATE(kb) && command != FWUPDATE && command != NOTIFYON && command != NOTIFYOFF)
124             continue;
125 
126         // Specially handled commands - these are available even when keyboard is IDLE
127         switch(command){
128         case NOTIFYON: {
129             // Notification node on
130             int notify;
131             if(sscanf(word, "%u", &notify) == 1)
132                 mknotifynode(kb, notify);
133             continue;
134         } case NOTIFYOFF: {
135             // Notification node off
136             int notify;
137             if(sscanf(word, "%u", &notify) == 1 && notify != 0) // notify0 can't be removed
138                 rmnotifynode(kb, notify);
139             continue;
140         } case GET:
141             // Output data to notification node
142             vt->get(kb, mode, notifynumber, 0, word);
143             continue;
144         case LAYOUT:
145             // OSX: switch ANSI/ISO keyboard layout
146             if(!strcmp(word, "ansi"))
147                 kb->features = (kb->features & ~FEAT_LMASK) | FEAT_ANSI;
148             else if(!strcmp(word, "iso"))
149                 kb->features = (kb->features & ~FEAT_LMASK) | FEAT_ISO;
150             continue;
151 #ifdef OS_MAC
152         case ACCEL:
153             // OSX mouse acceleration on/off
154             if(!strcmp(word, "on"))
155                 kb->features |= FEAT_MOUSEACCEL;
156             else if(!strcmp(word, "off"))
157                 kb->features &= ~FEAT_MOUSEACCEL;
158             continue;
159         case SCROLLSPEED:{
160             int newscroll;
161             if(sscanf(word, "%d", &newscroll) != 1)
162                 break;
163             if(newscroll < SCROLL_MIN)
164                 newscroll = SCROLL_ACCELERATED;
165             if(newscroll > SCROLL_MAX)
166                 newscroll = SCROLL_MAX;
167             kb->scroll_rate = newscroll;
168             continue;
169         }
170 #endif
171         case MODE: {
172             // Select a mode number (1 - 6)
173             int newmode;
174             if(sscanf(word, "%u", &newmode) == 1 && newmode > 0 && newmode <= MODE_COUNT)
175                 mode = profile->mode + newmode - 1;
176             continue;
177         }
178         case FPS: {
179             // USB command delay (2 - 10ms)
180             uint framerate;
181             if(sscanf(word, "%u", &framerate) == 1 && framerate > 0){
182                 // Not all devices require the same number of messages per frame; select delay appropriately
183                 uint per_frame = IS_MOUSE_DEV(kb) ? 2 : IS_FULLRANGE(kb) ? 14 : 5;
184                 uint delay = 1000 / framerate / per_frame;
185                 if(delay < 2)
186                     delay = 2;
187                 else if(delay > 10)
188                     delay = 10;
189                 kb->usbdelay = delay;
190             }
191             continue;
192         }
193         case DITHER: {
194             // 0: No dither, 1: Ordered dither\&.
195             uint dither;
196             if(sscanf(word, "%u", &dither) == 1 && dither <= 1){
197                 kb->dither = dither;
198                 profile->currentmode->light\&.forceupdate = 1;
199                 mode->light\&.forceupdate = 1;
200             }
201             continue;
202         }
203         case DELAY:
204             kb->delay = (!strcmp (word, "on")); // independendant from parameter to handle false commands like "delay off"
205             continue;
206         case RESTART: {
207             char mybuffer[] = "no reason specified";
208             if (sscanf(line, " %[^\n]", word) == -1) { 
209                 word = mybuffer;
210             }
211             vt->do_cmd[command](kb, mode, notifynumber, 0, word);
212             continue;
213         }
214 
215         default:;
216         }
217 
218         // If a keyboard is inactive, it must be activated before receiving any other commands
219         if(!kb->active){
220             if(command == ACTIVE)
221                 TRY_WITH_RESET(vt->active(kb, mode, notifynumber, 0, 0));
222             continue;
223         }
224         // Specially handled commands only available when keyboard is ACTIVE
225         switch(command){
226         case IDLE:
227             TRY_WITH_RESET(vt->idle(kb, mode, notifynumber, 0, 0));
228             continue;
229         case SWITCH:
230             if(profile->currentmode != mode){
231                 profile->currentmode = mode;
232                 // Set mode light for non-RGB K95
233                 int index = INDEX_OF(mode, profile->mode);
234                 vt->setmodeindex(kb, index);
235             }
236             continue;
237         case HWLOAD: case HWSAVE:{
238             char delay = kb->usbdelay;
239             // Ensure delay of at least 10ms as the device can get overwhelmed otherwise
240             if(delay < 10)
241                 kb->usbdelay = 10;
242             // Try to load/save the hardware profile\&. Reset on failure, disconnect if reset fails\&.
243             TRY_WITH_RESET(vt->do_io[command](kb, mode, notifynumber, 1, 0));
244             // Re-send the current RGB state as it sometimes gets scrambled
245             TRY_WITH_RESET(vt->updatergb(kb, 1));
246             kb->usbdelay = delay;
247             continue;
248         }
249         case FWUPDATE:
250             // FW update parses a whole word\&. Unlike hwload/hwsave, there's no try again on failure\&.
251             if(vt->fwupdate(kb, mode, notifynumber, 0, word)){
252                 free(word);
253                 return 1;
254             }
255             continue;
256         case POLLRATE: {
257             uint rate;
258             if(sscanf(word, "%u", &rate) == 1 && (rate == 1 || rate == 2 || rate == 4 || rate == 8))
259                 TRY_WITH_RESET(vt->pollrate(kb, mode, notifynumber, rate, 0));
260             continue;
261         }
262         case ERASEPROFILE:
263             // Erase the current profile
264             vt->eraseprofile(kb, mode, notifynumber, 0, 0);
265             // Update profile/mode pointers
266             profile = kb->profile;
267             mode = profile->currentmode;
268             continue;
269         case ERASE: case NAME: case IOFF: case ION: case IAUTO: case INOTIFY: case PROFILENAME: case ID: case PROFILEID: case DPISEL: case LIFT: case SNAP:
270             // All of the above just parse the whole word
271             vt->do_cmd[command](kb, mode, notifynumber, 0, word);
272             continue;
273         case RGB: {
274             // RGB command has a special response for a single hex constant
275             int r, g, b;
276             if(sscanf(word, "%02x%02x%02x", &r, &g, &b) == 3){
277                 // Set all keys
278                 for(int i = 0; i < N_KEYS_EXTENDED; i++)
279                     vt->rgb(kb, mode, notifynumber, i, word);
280                 continue;
281             }
282             break;
283         }
284         case MACRO:
285             if(!strcmp(word, "clear")){
286                 // Macro has a special clear command
287                 vt->macro(kb, mode, notifynumber, 0, 0);
288                 continue;
289             }
290             break;
291         default:;
292         }
293         // For anything else, split the parameter at the colon
294         int left = -1;
295         sscanf(word, "%*[^:]%n", &left);
296         if(left <= 0)
297             continue;
298         const char* right = word + left;
299         if(right[0] == ':')
300             right++;
301         // Macros and DPI have a separate left-side handler
302         if(command == MACRO || command == DPI){
303             word[left] = 0;
304             vt->do_macro[command](kb, mode, notifynumber, word, right);
305             continue;
306         }
307         // Scan the left side for key names and run the requested command
308         int position = 0, field = 0;
309         char keyname[11];
310         while(position < left && sscanf(word + position, "%10[^:,]%n", keyname, &field) == 1){
311             int keycode;
312             if(!strcmp(keyname, "all")){
313                 // Set all keys
314                 for(int i = 0; i < N_KEYS_EXTENDED; i++)
315                     vt->do_cmd[command](kb, mode, notifynumber, i, right);
316             } else if((sscanf(keyname, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_EXTENDED)
317                       || (sscanf(keyname, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_EXTENDED)){
318                 // Set a key numerically
319                 vt->do_cmd[command](kb, mode, notifynumber, keycode, right);
320             } else {
321                 // Find this key in the keymap
322                 for(unsigned i = 0; i < N_KEYS_EXTENDED; i++){
323                     if(keymap[i]\&.name && !strcmp(keyname, keymap[i]\&.name)){
324                         vt->do_cmd[command](kb, mode, notifynumber, i, right);
325                         break;
326                     }
327                 }
328             }
329             if(word[position += field] == ',')
330                 position++;
331         }
332     }
333 
334     // Finish up
335     if(!NEEDS_FW_UPDATE(kb)){
336         TRY_WITH_RESET(vt->updatergb(kb, 0));
337         TRY_WITH_RESET(vt->updatedpi(kb, 0));
338     }
339     free(word);
340     return 0;
341 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const char* const cmd_strings[(\fBCMD_LAST\fP-\fBCMD_FIRST\fP+2)-1]\fC [static]\fP"

.PP
Definition at line 9 of file command\&.c\&.
.PP
Referenced by readcmd()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
