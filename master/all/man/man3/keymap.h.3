.TH "src/ckb-daemon/keymap.h" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/keymap.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'keymap_mac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBkey\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKEY_NONE\fP   -1"
.br
.ti -1c
.RI "#define \fBKEY_CORSAIR\fP   -2"
.br
.ti -1c
.RI "#define \fBKEY_UNBOUND\fP   -3"
.br
.ti -1c
.RI "#define \fBBTN_WHEELUP\fP   0x1f01"
.br
.ti -1c
.RI "#define \fBBTN_WHEELDOWN\fP   0x1f02"
.br
.ti -1c
.RI "#define \fBKEY_BACKSLASH_ISO\fP   KEY_BACKSLASH"
.br
.ti -1c
.RI "#define \fBN_KEYS_HW\fP   152"
.br
.ti -1c
.RI "#define \fBN_KEYBYTES_HW\fP   ((\fBN_KEYS_HW\fP + 7) / 8)"
.br
.ti -1c
.RI "#define \fBN_KEY_ZONES\fP   22"
.br
.ti -1c
.RI "#define \fBN_KEYS_EXTRA\fP   12"
.br
.ti -1c
.RI "#define \fBN_BUTTONS_HW\fP   20"
.br
.ti -1c
.RI "#define \fBN_BUTTONS_EXTENDED\fP   25"
.br
.ti -1c
.RI "#define \fBMOUSE_BUTTON_FIRST\fP   (\fBN_KEYS_HW\fP + \fBN_KEY_ZONES\fP + \fBN_KEYS_EXTRA\fP)"
.br
.ti -1c
.RI "#define \fBMOUSE_EXTRA_FIRST\fP   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_HW\fP)"
.br
.ti -1c
.RI "#define \fBN_KEYS_INPUT\fP   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_EXTENDED\fP)"
.br
.ti -1c
.RI "#define \fBN_KEYBYTES_INPUT\fP   ((\fBN_KEYS_INPUT\fP + 7) / 8)"
.br
.ti -1c
.RI "#define \fBLED_MOUSE\fP   \fBN_KEYS_HW\fP"
.br
.ti -1c
.RI "#define \fBN_MOUSE_ZONES\fP   6"
.br
.ti -1c
.RI "#define \fBN_MOUSE_ZONES_EXTENDED\fP   12"
.br
.ti -1c
.RI "#define \fBLED_DPI\fP   (\fBLED_MOUSE\fP + 2)"
.br
.ti -1c
.RI "#define \fBN_KEYS_EXTENDED\fP   (\fBN_KEYS_INPUT\fP + \fBN_MOUSE_ZONES_EXTENDED\fP)"
.br
.ti -1c
.RI "#define \fBN_KEYBYTES_EXTENDED\fP   ((\fBN_KEYS_EXTENDED\fP + 7) / 8)"
.br
.ti -1c
.RI "#define \fBSCAN_SILENT\fP   0x8000"
.br
.ti -1c
.RI "#define \fBSCAN_KBD\fP   0"
.br
.ti -1c
.RI "#define \fBSCAN_MOUSE\fP   0x1000"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBhid_kb_translate\fP (unsigned char *kbinput, int endpoint, int length, const unsigned char *urbinput)"
.br
.ti -1c
.RI "void \fBhid_mouse_translate\fP (unsigned char *kbinput, short *xaxis, short *yaxis, int endpoint, int length, const unsigned char *urbinput, \fBushort\fP fwversion)"
.br
.ti -1c
.RI "void \fBcorsair_kbcopy\fP (unsigned char *kbinput, int endpoint, const unsigned char *urbinput)"
.br
.ti -1c
.RI "void \fBcorsair_mousecopy\fP (unsigned char *kbinput, int endpoint, const unsigned char *urbinput)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBkey\fP \fBkeymap\fP [(((152+22+12)+25)+12)]"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct key"
.PP 
Definition at line 49 of file keymap\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
short \fIled\fP 
.br
.PP
const char * \fIname\fP 
.br
.PP
short \fIscan\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define BTN_WHEELDOWN   0x1f02"

.PP
Definition at line 13 of file keymap\&.h\&.
.PP
Referenced by os_keypress()\&.
.SS "#define BTN_WHEELUP   0x1f01"

.PP
Definition at line 12 of file keymap\&.h\&.
.PP
Referenced by os_keypress()\&.
.SS "#define KEY_BACKSLASH_ISO   KEY_BACKSLASH"

.PP
Definition at line 20 of file keymap\&.h\&.
.SS "#define KEY_CORSAIR   -2"

.PP
Definition at line 8 of file keymap\&.h\&.
.SS "#define KEY_NONE   -1"

.PP
Definition at line 7 of file keymap\&.h\&.
.SS "#define KEY_UNBOUND   -3"

.PP
Definition at line 9 of file keymap\&.h\&.
.PP
Referenced by cmd_unbind()\&.
.SS "#define LED_DPI   (\fBLED_MOUSE\fP + 2)"

.PP
Definition at line 43 of file keymap\&.h\&.
.PP
Referenced by loadrgb_mouse(), and savergb_mouse()\&.
.SS "#define LED_MOUSE   \fBN_KEYS_HW\fP"

.PP
Definition at line 39 of file keymap\&.h\&.
.PP
Referenced by isblack(), loaddpi(), loadrgb_mouse(), rgbcmp(), savedpi(), savergb_mouse(), and updatergb_mouse()\&.
.SS "#define MOUSE_BUTTON_FIRST   (\fBN_KEYS_HW\fP + \fBN_KEY_ZONES\fP + \fBN_KEYS_EXTRA\fP)"

.PP
Definition at line 33 of file keymap\&.h\&.
.PP
Referenced by corsair_mousecopy(), and hid_mouse_translate()\&.
.SS "#define MOUSE_EXTRA_FIRST   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_HW\fP)"

.PP
Definition at line 34 of file keymap\&.h\&.
.PP
Referenced by hid_mouse_translate()\&.
.SS "#define N_BUTTONS_EXTENDED   25"

.PP
Definition at line 32 of file keymap\&.h\&.
.SS "#define N_BUTTONS_HW   20"

.PP
Definition at line 31 of file keymap\&.h\&.
.PP
Referenced by corsair_mousecopy()\&.
.SS "#define N_KEY_ZONES   22"

.PP
Definition at line 27 of file keymap\&.h\&.
.SS "#define N_KEYBYTES_EXTENDED   ((\fBN_KEYS_EXTENDED\fP + 7) / 8)"

.PP
Definition at line 46 of file keymap\&.h\&.
.SS "#define N_KEYBYTES_HW   ((\fBN_KEYS_HW\fP + 7) / 8)"

.PP
Definition at line 25 of file keymap\&.h\&.
.PP
Referenced by corsair_kbcopy()\&.
.SS "#define N_KEYBYTES_INPUT   ((\fBN_KEYS_INPUT\fP + 7) / 8)"

.PP
Definition at line 37 of file keymap\&.h\&.
.PP
Referenced by _cmd_macro(), inputupdate_keys(), and macromask()\&.
.SS "#define N_KEYS_EXTENDED   (\fBN_KEYS_INPUT\fP + \fBN_MOUSE_ZONES_EXTENDED\fP)"

.PP
Definition at line 45 of file keymap\&.h\&.
.PP
Referenced by printrgb(), and readcmd()\&.
.SS "#define N_KEYS_EXTRA   12"

.PP
Definition at line 29 of file keymap\&.h\&.
.SS "#define N_KEYS_HW   152"

.PP
Definition at line 24 of file keymap\&.h\&.
.PP
Referenced by loadrgb_kb(), makergb_512(), rgbcmp(), and setactive_kb()\&.
.SS "#define N_KEYS_INPUT   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_EXTENDED\fP)"

.PP
Definition at line 36 of file keymap\&.h\&.
.PP
Referenced by _cmd_get(), _cmd_macro(), cmd_bind(), cmd_notify(), cmd_rebind(), cmd_unbind(), initbind(), and inputupdate_keys()\&.
.SS "#define N_MOUSE_ZONES   6"

.PP
Definition at line 40 of file keymap\&.h\&.
.PP
Referenced by isblack(), loaddpi(), rgbcmp(), savedpi(), and updatergb_mouse()\&.
.SS "#define N_MOUSE_ZONES_EXTENDED   12"

.PP
Definition at line 41 of file keymap\&.h\&.
.SS "#define SCAN_KBD   0"

.PP
Definition at line 57 of file keymap\&.h\&.
.SS "#define SCAN_MOUSE   0x1000"

.PP
Definition at line 58 of file keymap\&.h\&.
.PP
Referenced by os_keypress()\&.
.SS "#define SCAN_SILENT   0x8000"

.PP
Definition at line 56 of file keymap\&.h\&.
.PP
Referenced by inputupdate_keys()\&.
.SH "Function Documentation"
.PP 
.SS "void corsair_kbcopy (unsigned char *kbinput, intendpoint, const unsigned char *urbinput)"

.PP
Definition at line 420 of file keymap\&.c\&.
.PP
References N_KEYBYTES_HW\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
420                                                                                         {
421     if(endpoint == 2 || endpoint == -2){
422         if(urbinput[0] != 3)
423             return;
424         urbinput++;
425     }
426     memcpy(kbinput, urbinput, N_KEYBYTES_HW);
427 }
.fi
.SS "void corsair_mousecopy (unsigned char *kbinput, intendpoint, const unsigned char *urbinput)"

.PP
Definition at line 429 of file keymap\&.c\&.
.PP
References BUTTON_HID_COUNT, CLEAR_KEYBIT, MOUSE_BUTTON_FIRST, N_BUTTONS_HW, and SET_KEYBIT\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
429                                                                                            {
430     if(endpoint == 2 || endpoint == -2){
431         if(urbinput[0] != 3)
432             return;
433         urbinput++;
434     }
435     for(int bit = BUTTON_HID_COUNT; bit < N_BUTTONS_HW; bit++){
436         int byte = bit / 8;
437         uchar test = 1 << (bit % 8);
438         if(urbinput[byte] & test)
439             SET_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
440         else
441             CLEAR_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
442     }
443 }
.fi
.SS "void hid_kb_translate (unsigned char *kbinput, intendpoint, intlength, const unsigned char *urbinput)"

.PP
Definition at line 246 of file keymap\&.c\&.
.PP
References ckb_warn, CLEAR_KEYBIT, and SET_KEYBIT\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
246                                                                                                       {
247     if(length < 1)
248         return;
249     // LUT for HID -> Corsair scancodes (-1 for no scan code, -2 for currently unsupported)
250     // Modified from Linux drivers/hid/usbhid/usbkbd\&.c, key codes replaced with keymap array indices and K95 keys added
251     // Make sure the indices match the keyindex as passed to nprintkey() in notify\&.c
252     static const short hid_codes[256] = {
253         -1,  -1,  -1,  -1,  37,  54,  52,  39,  27,  40,  41,  42,  32,  43,  44,  45,
254         56,  55,  33,  34,  25,  28,  38,  29,  31,  53,  26,  51,  30,  50,  13,  14,
255         15,  16,  17,  18,  19,  20,  21,  22,  82,   0,  86,  24,  64,  23,  84,  35,
256         79,  80,  81,  46,  47,  12,  57,  58,  59,  36,   1,   2,   3,   4,   5,   6,
257          7,   8,   9,  10,  11,  72,  73,  74,  75,  76,  77,  78,  87,  88,  89,  95,
258         93,  94,  92, 102, 103, 104, 105, 106, 107, 115, 116, 117, 112, 113, 114, 108,
259        109, 110, 118, 119,  49,  69,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,
260         -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  98,  -2,  -2,  -2,  -2,  -2,  -2,  97,
261        130, 131,  -1,  -1,  -1,  -2,  -1,  83,  66,  85, 145, 144,  -2,  -1,  -1,  -1,
262         -2,  -2,  -2,  -2,  -2,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
263         -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
264         -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
265         -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -3,  -1,  -1,  -1,  // <- -3 = non-RGB program key
266        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 136, 137, 138, 139, 140, 141,
267         60,  48,  62,  61,  91,  90,  67,  68, 142, 143,  99, 101,  -2, 130, 131,  97,
268         -2, 133, 134, 135,  -2,  96,  -2, 132,  -2,  -2,  71,  71,  71,  71,  -1,  -1,
269     };
270     switch(endpoint){
271     case 1:
272     case -1:
273         // EP 1: 6KRO input (RGB and non-RGB)
274         // Clear previous input
275         for(int i = 0; i < 256; i++){
276             if(hid_codes[i] >= 0)
277                 CLEAR_KEYBIT(kbinput, hid_codes[i]);
278         }
279         // Set new input
280         for(int i = 0; i < 8; i++){
281             if((urbinput[0] >> i) & 1)
282                 SET_KEYBIT(kbinput, hid_codes[i + 224]);
283         }
284         for(int i = 2; i < length; i++){
285             if(urbinput[i] > 3){
286                 int scan = hid_codes[urbinput[i]];
287                 if(scan >= 0)
288                     SET_KEYBIT(kbinput, scan);
289                 else
290                     ckb_warn("Got unknown key press %d on EP 1\n", urbinput[i]);
291             }
292         }
293         break;
294     case -2:
295         // EP 2 RGB: NKRO input
296         if(urbinput[0] == 1){
297             // Type 1: standard key
298             if(length != 21)
299                 return;
300             for(int bit = 0; bit < 8; bit++){
301                 if((urbinput[1] >> bit) & 1)
302                     SET_KEYBIT(kbinput, hid_codes[bit + 224]);
303                 else
304                     CLEAR_KEYBIT(kbinput, hid_codes[bit + 224]);
305             }
306             for(int byte = 0; byte < 19; byte++){
307                 char input = urbinput[byte + 2];
308                 for(int bit = 0; bit < 8; bit++){
309                     int keybit = byte * 8 + bit;
310                     int scan = hid_codes[keybit];
311                     if((input >> bit) & 1){
312                         if(scan >= 0)
313                             SET_KEYBIT(kbinput, hid_codes[keybit]);
314                         else
315                             ckb_warn("Got unknown key press %d on EP 2\n", keybit);
316                     } else if(scan >= 0)
317                         CLEAR_KEYBIT(kbinput, hid_codes[keybit]);
318                 }
319             }
320             break;
321         } else if (urbinput[0] == 2)
322             ; // Type 2: media key (implicitly falls through)
323         else
324             break;  // No other known types
325         /* FALLTHRU */
326     case 2:
327         // EP 2 Non-RGB: media keys
328         CLEAR_KEYBIT(kbinput, 97);          // mute
329         CLEAR_KEYBIT(kbinput, 98);          // stop
330         CLEAR_KEYBIT(kbinput, 99);          // prev
331         CLEAR_KEYBIT(kbinput, 100);         // play
332         CLEAR_KEYBIT(kbinput, 101);         // next
333         CLEAR_KEYBIT(kbinput, 130);         // volup
334         CLEAR_KEYBIT(kbinput, 131);         // voldn
335         for(int i = 0; i < length; i++){
336             switch(urbinput[i]){
337             case 181:
338                 SET_KEYBIT(kbinput, 101);   // next
339                 break;
340             case 182:
341                 SET_KEYBIT(kbinput, 99);    // prev
342                 break;
343             case 183:
344                 SET_KEYBIT(kbinput, 98);    // stop
345                 break;
346             case 205:
347                 SET_KEYBIT(kbinput, 100);   // play
348                 break;
349             case 226:
350                 SET_KEYBIT(kbinput, 97);    // mute
351                 break;
352             case 233:
353                 SET_KEYBIT(kbinput, 130);   // volup
354                 break;
355             case 234:
356                 SET_KEYBIT(kbinput, 131);   // voldn
357                 break;
358             }
359         }
360         break;
361     case 3:
362         // EP 3 non-RGB: NKRO input
363         if(length != 15)
364             return;
365         for(int bit = 0; bit < 8; bit++){
366             if((urbinput[0] >> bit) & 1)
367                 SET_KEYBIT(kbinput, hid_codes[bit + 224]);
368             else
369                 CLEAR_KEYBIT(kbinput, hid_codes[bit + 224]);
370         }
371         for(int byte = 0; byte < 14; byte++){
372             char input = urbinput[byte + 1];
373             for(int bit = 0; bit < 8; bit++){
374                 int keybit = byte * 8 + bit;
375                 int scan = hid_codes[keybit];
376                 if((input >> bit) & 1){
377                     if(scan >= 0)
378                         SET_KEYBIT(kbinput, hid_codes[keybit]);
379                     else
380                         ckb_warn("Got unknown key press %d on EP 3\n", keybit);
381                 } else if(scan >= 0)
382                     CLEAR_KEYBIT(kbinput, hid_codes[keybit]);
383             }
384         }
385         break;
386     }
387 }
.fi
.SS "void hid_mouse_translate (unsigned char *kbinput, short *xaxis, short *yaxis, intendpoint, intlength, const unsigned char *urbinput, \fBushort\fPfwversion)"

.PP
Definition at line 391 of file keymap\&.c\&.
.PP
References BUTTON_HID_COUNT, CLEAR_KEYBIT, MOUSE_BUTTON_FIRST, MOUSE_EXTRA_FIRST, and SET_KEYBIT\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
391                                                                                                                                                        {
392     //The HID Input Endpoint on FWv3 is 64 bytes, so we can't check for length\&.
393     if((endpoint != 2 && endpoint != -2) || (fwversion < 0x300 && length < 10))
394         return;
395     // EP 2: mouse input
396     if(urbinput[0] != 1)
397         return;
398     // Byte 1 = mouse buttons (bitfield)
399     for(int bit = 0; bit < BUTTON_HID_COUNT; bit++){
400         if(urbinput[1] & (1 << bit))
401             SET_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
402         else
403             CLEAR_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
404     }
405     // Bytes 5 - 8: movement
406     *xaxis += *(short*)(urbinput + 5);
407     *yaxis += *(short*)(urbinput + 7);
408     // Byte 9: wheel
409     char wheel = urbinput[9];
410     if(wheel > 0)
411         SET_KEYBIT(kbinput, MOUSE_EXTRA_FIRST);         // wheelup
412     else
413         CLEAR_KEYBIT(kbinput, MOUSE_EXTRA_FIRST);
414     if(wheel < 0)
415         SET_KEYBIT(kbinput, MOUSE_EXTRA_FIRST + 1);     // wheeldn
416     else
417         CLEAR_KEYBIT(kbinput, MOUSE_EXTRA_FIRST + 1);
418 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const \fBkey\fP keymap[(((152+22+12)+25)+12)]"

.PP
Definition at line 5 of file keymap\&.c\&.
.PP
Referenced by _cmd_get(), _cmd_macro(), cmd_bind(), cmd_rebind(), cmd_rgb(), initbind(), inputupdate_keys(), nprintkey(), printrgb(), readcmd(), and setactive_kb()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
