.TH "src/ckb-daemon/keymap.h" 3 "Fri Nov 3 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/keymap.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'keymap_mac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBkey\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKEY_NONE\fP   -1"
.br
.ti -1c
.RI "#define \fBKEY_CORSAIR\fP   -2"
.br
.ti -1c
.RI "#define \fBKEY_UNBOUND\fP   -3"
.br
.ti -1c
.RI "#define \fBBTN_WHEELUP\fP   0x1f01"
.br
.ti -1c
.RI "#define \fBBTN_WHEELDOWN\fP   0x1f02"
.br
.ti -1c
.RI "#define \fBKEY_BACKSLASH_ISO\fP   KEY_BACKSLASH"
.br
.ti -1c
.RI "#define \fBN_KEYS_HW\fP   152"
.br
.ti -1c
.RI "#define \fBN_KEYBYTES_HW\fP   ((\fBN_KEYS_HW\fP + 7) / 8)"
.br
.ti -1c
.RI "#define \fBN_KEY_ZONES\fP   3"
.br
.ti -1c
.RI "#define \fBN_KEYS_EXTRA\fP   12"
.br
.ti -1c
.RI "#define \fBN_BUTTONS_HW\fP   20"
.br
.ti -1c
.RI "#define \fBN_BUTTONS_EXTENDED\fP   25"
.br
.ti -1c
.RI "#define \fBMOUSE_BUTTON_FIRST\fP   (\fBN_KEYS_HW\fP + \fBN_KEY_ZONES\fP + \fBN_KEYS_EXTRA\fP)"
.br
.ti -1c
.RI "#define \fBMOUSE_EXTRA_FIRST\fP   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_HW\fP)"
.br
.ti -1c
.RI "#define \fBN_KEYS_INPUT\fP   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_EXTENDED\fP)"
.br
.ti -1c
.RI "#define \fBN_KEYBYTES_INPUT\fP   ((\fBN_KEYS_INPUT\fP + 7) / 8)"
.br
.ti -1c
.RI "#define \fBLED_MOUSE\fP   \fBN_KEYS_HW\fP"
.br
.ti -1c
.RI "#define \fBN_MOUSE_ZONES\fP   6"
.br
.ti -1c
.RI "#define \fBN_MOUSE_ZONES_EXTENDED\fP   12"
.br
.ti -1c
.RI "#define \fBLED_DPI\fP   (\fBLED_MOUSE\fP + 2)"
.br
.ti -1c
.RI "#define \fBN_KEYS_EXTENDED\fP   (\fBN_KEYS_INPUT\fP + \fBN_MOUSE_ZONES_EXTENDED\fP)"
.br
.ti -1c
.RI "#define \fBN_KEYBYTES_EXTENDED\fP   ((\fBN_KEYS_EXTENDED\fP + 7) / 8)"
.br
.ti -1c
.RI "#define \fBSCAN_SILENT\fP   0x8000"
.br
.ti -1c
.RI "#define \fBSCAN_KBD\fP   0"
.br
.ti -1c
.RI "#define \fBSCAN_MOUSE\fP   0x1000"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBhid_kb_translate\fP (unsigned char *kbinput, int endpoint, int length, const unsigned char *urbinput)"
.br
.ti -1c
.RI "void \fBhid_mouse_translate\fP (unsigned char *kbinput, short *xaxis, short *yaxis, int endpoint, int length, const unsigned char *urbinput)"
.br
.ti -1c
.RI "void \fBcorsair_kbcopy\fP (unsigned char *kbinput, int endpoint, const unsigned char *urbinput)"
.br
.ti -1c
.RI "void \fBcorsair_mousecopy\fP (unsigned char *kbinput, int endpoint, const unsigned char *urbinput)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBkey\fP \fBkeymap\fP [(((152+3+12)+25)+12)]"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct key"
.PP 
Definition at line 49 of file keymap\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
short \fIled\fP 
.br
.PP
const char * \fIname\fP 
.br
.PP
short \fIscan\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define BTN_WHEELDOWN   0x1f02"

.PP
Definition at line 13 of file keymap\&.h\&.
.PP
Referenced by os_keypress()\&.
.SS "#define BTN_WHEELUP   0x1f01"

.PP
Definition at line 12 of file keymap\&.h\&.
.PP
Referenced by os_keypress()\&.
.SS "#define KEY_BACKSLASH_ISO   KEY_BACKSLASH"

.PP
Definition at line 20 of file keymap\&.h\&.
.SS "#define KEY_CORSAIR   -2"

.PP
Definition at line 8 of file keymap\&.h\&.
.SS "#define KEY_NONE   -1"

.PP
Definition at line 7 of file keymap\&.h\&.
.SS "#define KEY_UNBOUND   -3"

.PP
Definition at line 9 of file keymap\&.h\&.
.PP
Referenced by cmd_unbind()\&.
.SS "#define LED_DPI   (\fBLED_MOUSE\fP + 2)"

.PP
Definition at line 43 of file keymap\&.h\&.
.PP
Referenced by loadrgb_mouse(), and savergb_mouse()\&.
.SS "#define LED_MOUSE   \fBN_KEYS_HW\fP"

.PP
Definition at line 39 of file keymap\&.h\&.
.PP
Referenced by isblack(), loaddpi(), loadrgb_mouse(), rgbcmp(), savedpi(), savergb_mouse(), and updatergb_mouse()\&.
.SS "#define MOUSE_BUTTON_FIRST   (\fBN_KEYS_HW\fP + \fBN_KEY_ZONES\fP + \fBN_KEYS_EXTRA\fP)"

.PP
Definition at line 33 of file keymap\&.h\&.
.PP
Referenced by corsair_mousecopy(), and hid_mouse_translate()\&.
.SS "#define MOUSE_EXTRA_FIRST   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_HW\fP)"

.PP
Definition at line 34 of file keymap\&.h\&.
.PP
Referenced by hid_mouse_translate()\&.
.SS "#define N_BUTTONS_EXTENDED   25"

.PP
Definition at line 32 of file keymap\&.h\&.
.SS "#define N_BUTTONS_HW   20"

.PP
Definition at line 31 of file keymap\&.h\&.
.PP
Referenced by corsair_mousecopy()\&.
.SS "#define N_KEY_ZONES   3"

.PP
Definition at line 27 of file keymap\&.h\&.
.SS "#define N_KEYBYTES_EXTENDED   ((\fBN_KEYS_EXTENDED\fP + 7) / 8)"

.PP
Definition at line 46 of file keymap\&.h\&.
.SS "#define N_KEYBYTES_HW   ((\fBN_KEYS_HW\fP + 7) / 8)"

.PP
Definition at line 25 of file keymap\&.h\&.
.PP
Referenced by corsair_kbcopy()\&.
.SS "#define N_KEYBYTES_INPUT   ((\fBN_KEYS_INPUT\fP + 7) / 8)"

.PP
Definition at line 37 of file keymap\&.h\&.
.PP
Referenced by _cmd_macro(), inputupdate_keys(), and macromask()\&.
.SS "#define N_KEYS_EXTENDED   (\fBN_KEYS_INPUT\fP + \fBN_MOUSE_ZONES_EXTENDED\fP)"

.PP
Definition at line 45 of file keymap\&.h\&.
.PP
Referenced by printrgb(), and readcmd()\&.
.SS "#define N_KEYS_EXTRA   12"

.PP
Definition at line 29 of file keymap\&.h\&.
.SS "#define N_KEYS_HW   152"

.PP
Definition at line 24 of file keymap\&.h\&.
.PP
Referenced by loadrgb_kb(), makergb_512(), rgbcmp(), and setactive_kb()\&.
.SS "#define N_KEYS_INPUT   (\fBMOUSE_BUTTON_FIRST\fP + \fBN_BUTTONS_EXTENDED\fP)"

.PP
Definition at line 36 of file keymap\&.h\&.
.PP
Referenced by _cmd_get(), _cmd_macro(), cmd_bind(), cmd_notify(), cmd_rebind(), cmd_unbind(), initbind(), and inputupdate_keys()\&.
.SS "#define N_MOUSE_ZONES   6"

.PP
Definition at line 40 of file keymap\&.h\&.
.PP
Referenced by isblack(), loaddpi(), rgbcmp(), savedpi(), and updatergb_mouse()\&.
.SS "#define N_MOUSE_ZONES_EXTENDED   12"

.PP
Definition at line 41 of file keymap\&.h\&.
.SS "#define SCAN_KBD   0"

.PP
Definition at line 57 of file keymap\&.h\&.
.SS "#define SCAN_MOUSE   0x1000"

.PP
Definition at line 58 of file keymap\&.h\&.
.PP
Referenced by os_keypress()\&.
.SS "#define SCAN_SILENT   0x8000"

.PP
Definition at line 56 of file keymap\&.h\&.
.PP
Referenced by inputupdate_keys()\&.
.SH "Function Documentation"
.PP 
.SS "void corsair_kbcopy (unsigned char *kbinput, intendpoint, const unsigned char *urbinput)"

.PP
Definition at line 397 of file keymap\&.c\&.
.PP
References N_KEYBYTES_HW\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
397                                                                                         {
398     if(endpoint == 2 || endpoint == -2){
399         if(urbinput[0] != 3)
400             return;
401         urbinput++;
402     }
403     memcpy(kbinput, urbinput, N_KEYBYTES_HW);
404 }
.fi
.SS "void corsair_mousecopy (unsigned char *kbinput, intendpoint, const unsigned char *urbinput)"

.PP
Definition at line 406 of file keymap\&.c\&.
.PP
References BUTTON_HID_COUNT, CLEAR_KEYBIT, MOUSE_BUTTON_FIRST, N_BUTTONS_HW, and SET_KEYBIT\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
406                                                                                            {
407     if(endpoint == 2 || endpoint == -2){
408         if(urbinput[0] != 3)
409             return;
410         urbinput++;
411     }
412     for(int bit = BUTTON_HID_COUNT; bit < N_BUTTONS_HW; bit++){
413         int byte = bit / 8;
414         uchar test = 1 << (bit % 8);
415         if(urbinput[byte] & test)
416             SET_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
417         else
418             CLEAR_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
419     }
420 }
.fi
.SS "void hid_kb_translate (unsigned char *kbinput, intendpoint, intlength, const unsigned char *urbinput)"

.PP
Definition at line 224 of file keymap\&.c\&.
.PP
References ckb_warn, CLEAR_KEYBIT, and SET_KEYBIT\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
224                                                                                                       {
225     if(length < 1)
226         return;
227     // LUT for HID -> Corsair scancodes (-1 for no scan code, -2 for currently unsupported)
228     // Modified from Linux drivers/hid/usbhid/usbkbd\&.c, key codes replaced with keymap array indices and K95 keys added
229     // Make sure the indices match the keyindex as passed to nprintkey() in notify\&.c
230     static const short hid_codes[256] = {
231         -1,  -1,  -1,  -1,  37,  54,  52,  39,  27,  40,  41,  42,  32,  43,  44,  45,
232         56,  55,  33,  34,  25,  28,  38,  29,  31,  53,  26,  51,  30,  50,  13,  14,
233         15,  16,  17,  18,  19,  20,  21,  22,  82,   0,  86,  24,  64,  23,  84,  35,
234         79,  80,  81,  46,  47,  12,  57,  58,  59,  36,   1,   2,   3,   4,   5,   6,
235          7,   8,   9,  10,  11,  72,  73,  74,  75,  76,  77,  78,  87,  88,  89,  95,
236         93,  94,  92, 102, 103, 104, 105, 106, 107, 115, 116, 117, 112, 113, 114, 108,
237        109, 110, 118, 119,  49,  69,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,
238         -2,  -2,  -2,  -2,  -2,  -2,  -2,  -2,  98,  -2,  -2,  -2,  -2,  -2,  -2,  97,
239        130, 131,  -1,  -1,  -1,  -2,  -1,  83,  66,  85, 145, 144,  -2,  -1,  -1,  -1,
240         -2,  -2,  -2,  -2,  -2,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
241         -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
242         -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
243         -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -3,  -1,  -1,  -1,  // <- -3 = non-RGB program key
244        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 136, 137, 138, 139, 140, 141,
245         60,  48,  62,  61,  91,  90,  67,  68, 142, 143,  99, 101,  -2, 130, 131,  97,
246         -2, 133, 134, 135,  -2,  96,  -2, 132,  -2,  -2,  71,  71,  71,  71,  -1,  -1,
247     };
248     switch(endpoint){
249     case 1:
250     case -1:
251         // EP 1: 6KRO input (RGB and non-RGB)
252         // Clear previous input
253         for(int i = 0; i < 256; i++){
254             if(hid_codes[i] >= 0)
255                 CLEAR_KEYBIT(kbinput, hid_codes[i]);
256         }
257         // Set new input
258         for(int i = 0; i < 8; i++){
259             if((urbinput[0] >> i) & 1)
260                 SET_KEYBIT(kbinput, hid_codes[i + 224]);
261         }
262         for(int i = 2; i < length; i++){
263             if(urbinput[i] > 3){
264                 int scan = hid_codes[urbinput[i]];
265                 if(scan >= 0)
266                     SET_KEYBIT(kbinput, scan);
267                 else
268                     ckb_warn("Got unknown key press %d on EP 1\n", urbinput[i]);
269             }
270         }
271         break;
272     case -2:
273         // EP 2 RGB: NKRO input
274         if(urbinput[0] == 1){
275             // Type 1: standard key
276             if(length != 21)
277                 return;
278             for(int bit = 0; bit < 8; bit++){
279                 if((urbinput[1] >> bit) & 1)
280                     SET_KEYBIT(kbinput, hid_codes[bit + 224]);
281                 else
282                     CLEAR_KEYBIT(kbinput, hid_codes[bit + 224]);
283             }
284             for(int byte = 0; byte < 19; byte++){
285                 char input = urbinput[byte + 2];
286                 for(int bit = 0; bit < 8; bit++){
287                     int keybit = byte * 8 + bit;
288                     int scan = hid_codes[keybit];
289                     if((input >> bit) & 1){
290                         if(scan >= 0)
291                             SET_KEYBIT(kbinput, hid_codes[keybit]);
292                         else
293                             ckb_warn("Got unknown key press %d on EP 2\n", keybit);
294                     } else if(scan >= 0)
295                         CLEAR_KEYBIT(kbinput, hid_codes[keybit]);
296                 }
297             }
298             break;
299         } else if (urbinput[0] == 2)
300             ; // Type 2: media key (implicitly falls through)
301         else
302             break;  // No other known types
303         /* FALLTHRU */
304     case 2:
305         // EP 2 Non-RGB: media keys
306         CLEAR_KEYBIT(kbinput, 97);          // mute
307         CLEAR_KEYBIT(kbinput, 98);          // stop
308         CLEAR_KEYBIT(kbinput, 99);          // prev
309         CLEAR_KEYBIT(kbinput, 100);         // play
310         CLEAR_KEYBIT(kbinput, 101);         // next
311         CLEAR_KEYBIT(kbinput, 130);         // volup
312         CLEAR_KEYBIT(kbinput, 131);         // voldn
313         for(int i = 0; i < length; i++){
314             switch(urbinput[i]){
315             case 181:
316                 SET_KEYBIT(kbinput, 101);   // next
317                 break;
318             case 182:
319                 SET_KEYBIT(kbinput, 99);    // prev
320                 break;
321             case 183:
322                 SET_KEYBIT(kbinput, 98);    // stop
323                 break;
324             case 205:
325                 SET_KEYBIT(kbinput, 100);   // play
326                 break;
327             case 226:
328                 SET_KEYBIT(kbinput, 97);    // mute
329                 break;
330             case 233:
331                 SET_KEYBIT(kbinput, 130);   // volup
332                 break;
333             case 234:
334                 SET_KEYBIT(kbinput, 131);   // voldn
335                 break;
336             }
337         }
338         break;
339     case 3:
340         // EP 3 non-RGB: NKRO input
341         if(length != 15)
342             return;
343         for(int bit = 0; bit < 8; bit++){
344             if((urbinput[0] >> bit) & 1)
345                 SET_KEYBIT(kbinput, hid_codes[bit + 224]);
346             else
347                 CLEAR_KEYBIT(kbinput, hid_codes[bit + 224]);
348         }
349         for(int byte = 0; byte < 14; byte++){
350             char input = urbinput[byte + 1];
351             for(int bit = 0; bit < 8; bit++){
352                 int keybit = byte * 8 + bit;
353                 int scan = hid_codes[keybit];
354                 if((input >> bit) & 1){
355                     if(scan >= 0)
356                         SET_KEYBIT(kbinput, hid_codes[keybit]);
357                     else
358                         ckb_warn("Got unknown key press %d on EP 3\n", keybit);
359                 } else if(scan >= 0)
360                     CLEAR_KEYBIT(kbinput, hid_codes[keybit]);
361             }
362         }
363         break;
364     }
365 }
.fi
.SS "void hid_mouse_translate (unsigned char *kbinput, short *xaxis, short *yaxis, intendpoint, intlength, const unsigned char *urbinput)"

.PP
Definition at line 369 of file keymap\&.c\&.
.PP
References BUTTON_HID_COUNT, CLEAR_KEYBIT, MOUSE_BUTTON_FIRST, MOUSE_EXTRA_FIRST, and SET_KEYBIT\&.
.PP
Referenced by os_inputmain()\&.
.PP
.nf
369                                                                                                                                      {
370     if((endpoint != 2 && endpoint != -2) || length < 10)
371         return;
372     // EP 2: mouse input
373     if(urbinput[0] != 1)
374         return;
375     // Byte 1 = mouse buttons (bitfield)
376     for(int bit = 0; bit < BUTTON_HID_COUNT; bit++){
377         if(urbinput[1] & (1 << bit))
378             SET_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
379         else
380             CLEAR_KEYBIT(kbinput, MOUSE_BUTTON_FIRST + bit);
381     }
382     // Bytes 5 - 8: movement
383     *xaxis += *(short*)(urbinput + 5);
384     *yaxis += *(short*)(urbinput + 7);
385     // Byte 9: wheel
386     char wheel = urbinput[9];
387     if(wheel > 0)
388         SET_KEYBIT(kbinput, MOUSE_EXTRA_FIRST);         // wheelup
389     else
390         CLEAR_KEYBIT(kbinput, MOUSE_EXTRA_FIRST);
391     if(wheel < 0)
392         SET_KEYBIT(kbinput, MOUSE_EXTRA_FIRST + 1);     // wheeldn
393     else
394         CLEAR_KEYBIT(kbinput, MOUSE_EXTRA_FIRST + 1);
395 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const \fBkey\fP keymap[(((152+3+12)+25)+12)]"

.PP
Definition at line 5 of file keymap\&.c\&.
.PP
Referenced by _cmd_get(), _cmd_macro(), cmd_bind(), cmd_rebind(), cmd_rgb(), initbind(), inputupdate_keys(), nprintkey(), printrgb(), readcmd(), and setactive_kb()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
