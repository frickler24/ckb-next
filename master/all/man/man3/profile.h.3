.TH "src/ckb-daemon/profile.h" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/profile.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br
\fC#include 'device\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBhwloadprofile\fP(kb, apply)   (kb)->vtable->hwload(kb, 0, 0, apply, 0)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBallocprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBloadprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBfreeprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBcmd_erase\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *dummy3)"
.br
.ti -1c
.RI "void \fBcmd_eraseprofile\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "void \fBcmd_name\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *name)"
.br
.ti -1c
.RI "void \fBcmd_profilename\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *name)"
.br
.ti -1c
.RI "char * \fBgetmodename\fP (\fBusbmode\fP *mode)"
.br
.ti -1c
.RI "char * \fBgetprofilename\fP (\fBusbprofile\fP *profile)"
.br
.ti -1c
.RI "char * \fBgethwmodename\fP (\fBhwprofile\fP *profile, int index)"
.br
.ti -1c
.RI "char * \fBgethwprofilename\fP (\fBhwprofile\fP *profile)"
.br
.ti -1c
.RI "int \fBsetid\fP (\fBusbid\fP *id, const char *guid)"
.br
.ti -1c
.RI "char * \fBgetid\fP (\fBusbid\fP *id)"
.br
.ti -1c
.RI "void \fBhwtonative\fP (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, int modecount)"
.br
.ti -1c
.RI "void \fBnativetohw\fP (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, int modecount)"
.br
.ti -1c
.RI "void \fBcmd_id\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *id)"
.br
.ti -1c
.RI "void \fBcmd_profileid\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *id)"
.br
.ti -1c
.RI "int \fBcmd_hwload_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int apply, const char *dummy3)"
.br
.ti -1c
.RI "int \fBcmd_hwload_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int apply, const char *dummy3)"
.br
.ti -1c
.RI "int \fBcmd_hwsave_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_hwsave_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define hwloadprofile(kb, apply)   (kb)->vtable->hwload(kb, 0, 0, apply, 0)"

.PP
Definition at line 52 of file profile\&.h\&.
.PP
Referenced by _start_dev(), and loadprofile()\&.
.SH "Function Documentation"
.PP 
.SS "void allocprofile (\fBusbdevice\fP *kb)"

.PP
Definition at line 198 of file profile\&.c\&.
.PP
References usbprofile::currentmode, dpiset::forceupdate, lighting::forceupdate, initmode(), usbprofile::lastdpi, usbprofile::lastlight, usbprofile::mode, MODE_COUNT, and usbdevice::profile\&.
.PP
Referenced by cmd_eraseprofile()\&.
.PP
.nf
198                                 {
199     if(kb->profile)
200         return;
201     usbprofile* profile = kb->profile = calloc(1, sizeof(usbprofile));
202     for(int i = 0; i < MODE_COUNT; i++)
203         initmode(profile->mode + i);
204     profile->currentmode = profile->mode;
205     profile->lastlight\&.forceupdate = profile->lastdpi\&.forceupdate = 1;
206 }
.fi
.SS "void cmd_erase (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *dummy3)"

.PP
Definition at line 219 of file profile\&.c\&.
.PP
References freemode(), imutex, and initmode()\&.
.PP
.nf
219                                                                                         {
220     (void)dummy1;
221     (void)dummy2;
222     (void)dummy3;
223 
224     pthread_mutex_lock(imutex(kb));
225     freemode(mode);
226     initmode(mode);
227     pthread_mutex_unlock(imutex(kb));
228 }
.fi
.SS "void cmd_eraseprofile (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 241 of file profile\&.c\&.
.PP
References _freeprofile(), allocprofile(), and imutex\&.
.PP
.nf
241                                                                                                  {
242     (void)dummy1;
243     (void)dummy2;
244     (void)dummy3;
245     (void)dummy4;
246 
247     pthread_mutex_lock(imutex(kb));
248     _freeprofile(kb);
249     allocprofile(kb);
250     pthread_mutex_unlock(imutex(kb));
251 }
.fi
.SS "int cmd_hwload_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intapply, const char *dummy3)"

.PP
Definition at line 16 of file profile_keyboard\&.c\&.
.PP
References DELAY_LONG, usbdevice::hw, hwloadmode(), HWMODE_K70, HWMODE_K95, hwtonative(), hwprofile::id, IS_K95, MSG_SIZE, hwprofile::name, PR_NAME_LEN, usbdevice::profile, and usbrecv\&.
.PP
.nf
16                                                                                             {
17     (void)dummy1;
18     (void)dummy2;
19     (void)dummy3;
20 
21     DELAY_LONG(kb);
22     hwprofile* hw = calloc(1, sizeof(hwprofile));
23     // Ask for profile and mode IDs
24     uchar data_pkt[2][MSG_SIZE] = {
25         { 0x0e, 0x15, 0x01, 0 },
26         { 0x0e, 0x16, 0x01, 0 }
27     };
28     uchar in_pkt[MSG_SIZE];
29     int modes = (IS_K95(kb) ? HWMODE_K95 : HWMODE_K70);
30     for(int i = 0; i <= modes; i++){
31         data_pkt[0][3] = i;
32         if(!usbrecv(kb, data_pkt[0], in_pkt)){
33             free(hw);
34             return -1;
35         }
36         memcpy(hw->id + i, in_pkt + 4, sizeof(usbid));
37     }
38     // Ask for profile name
39     if(!usbrecv(kb, data_pkt[1], in_pkt)){
40         free(hw);
41         return -1;
42     }
43     memcpy(hw->name[0], in_pkt + 4, PR_NAME_LEN * 2);
44     // Load modes
45     for(int i = 0; i < modes; i++){
46         if(hwloadmode(kb, hw, i)){
47             free(hw);
48             return -1;
49         }
50     }
51     // Make the profile active (if requested)
52     if(apply)
53         hwtonative(kb->profile, hw, modes);
54     // Free the existing profile (if any)
55     free(kb->hw);
56     kb->hw = hw;
57     DELAY_LONG(kb);
58     return 0;
59 }
.fi
.SS "int cmd_hwload_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intapply, const char *dummy3)"

.PP
Definition at line 6 of file profile_mouse\&.c\&.
.PP
References DELAY_LONG, hwprofile::dpi, usbdevice::hw, hwtonative(), hwprofile::id, hwprofile::light, loaddpi(), loadrgb_mouse(), MSG_SIZE, hwprofile::name, PR_NAME_LEN, usbdevice::profile, and usbrecv\&.
.PP
.nf
6                                                                                                {
7     (void)dummy1;
8     (void)dummy2;
9     (void)dummy3;
10 
11     DELAY_LONG(kb);
12     hwprofile* hw = calloc(1, sizeof(hwprofile));
13     // Ask for profile and mode IDs
14     uchar data_pkt[2][MSG_SIZE] = {
15         { 0x0e, 0x15, 0x01, 0 },
16         { 0x0e, 0x16, 0x01, 0 }
17     };
18     uchar in_pkt[MSG_SIZE];
19     for(int i = 0; i <= 1; i++){
20         data_pkt[0][3] = i;
21         if(!usbrecv(kb, data_pkt[0], in_pkt)){
22             free(hw);
23             return -1;
24         }
25         memcpy(hw->id + i, in_pkt + 4, sizeof(usbid));
26     }
27     // Ask for profile and mode names
28     for(int i = 0; i <= 1; i++){
29         data_pkt[1][3] = i;
30         if(!usbrecv(kb, data_pkt[1],in_pkt)){
31             free(hw);
32             return -1;
33         }
34         memcpy(hw->name[i], in_pkt + 4, PR_NAME_LEN * 2);
35     }
36 
37     // Load the RGB and DPI settings
38     if(loadrgb_mouse(kb, hw->light, 0)
39             || loaddpi(kb, hw->dpi, hw->light)){
40         free(hw);
41         return -1;
42     }
43 
44     // Make the profile active (if requested)
45     if(apply)
46         hwtonative(kb->profile, hw, 1);
47     // Free the existing profile (if any)
48     free(kb->hw);
49     kb->hw = hw;
50     DELAY_LONG(kb);
51     return 0;
52 }
.fi
.SS "int cmd_hwsave_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 61 of file profile_keyboard\&.c\&.
.PP
References DELAY_LONG, usbdevice::hw, HWMODE_K70, HWMODE_K95, hwprofile::id, IS_K95, hwprofile::light, MD_NAME_LEN, MSG_SIZE, hwprofile::name, nativetohw(), usbdevice::profile, savergb_kb(), and usbsend\&.
.PP
.nf
61                                                                                              {
62     (void)dummy1;
63     (void)dummy2;
64     (void)dummy3;
65     (void)dummy4;
66 
67     DELAY_LONG(kb);
68     hwprofile* hw = kb->hw;
69     if(!hw)
70         hw = kb->hw = calloc(1, sizeof(hwprofile));
71     int modes = (IS_K95(kb) ? HWMODE_K95 : HWMODE_K70);
72     nativetohw(kb->profile, hw, modes);
73     // Save the profile and mode names
74     uchar data_pkt[2][MSG_SIZE] = {
75         { 0x07, 0x16, 0x01, 0 },
76         { 0x07, 0x15, 0x01, 0 },
77     };
78     // Save the mode names
79     for(int i = 0; i <= modes; i++){
80         data_pkt[0][3] = i;
81         memcpy(data_pkt[0] + 4, hw->name[i], MD_NAME_LEN * 2);
82         if(!usbsend(kb, data_pkt[0], 1))
83             return -1;
84     }
85     // Save the IDs
86     for(int i = 0; i <= modes; i++){
87         data_pkt[1][3] = i;
88         memcpy(data_pkt[1] + 4, hw->id + i, sizeof(usbid));
89         if(!usbsend(kb, data_pkt[1], 1))
90             return -1;
91     }
92     // Save the RGB data
93     for(int i = 0; i < modes; i++){
94         if(savergb_kb(kb, hw->light + i, i))
95             return -1;
96     }
97     DELAY_LONG(kb);
98     return 0;
99 }
.fi
.SS "int cmd_hwsave_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 54 of file profile_mouse\&.c\&.
.PP
References DELAY_LONG, hwprofile::dpi, usbdevice::hw, hwprofile::id, hwprofile::light, MD_NAME_LEN, MSG_SIZE, hwprofile::name, nativetohw(), usbdevice::profile, savedpi(), savergb_mouse(), and usbsend\&.
.PP
.nf
54                                                                                                 {
55     (void)dummy1;
56     (void)dummy2;
57     (void)dummy3;
58     (void)dummy4;
59 
60     DELAY_LONG(kb);
61     hwprofile* hw = kb->hw;
62     if(!hw)
63         hw = kb->hw = calloc(1, sizeof(hwprofile));
64     nativetohw(kb->profile, hw, 1);
65     // Save the profile and mode names
66     uchar data_pkt[2][MSG_SIZE] = {
67         { 0x07, 0x16, 0x01, 0 },
68         { 0x07, 0x15, 0x01, 0 },
69     };
70     for(int i = 0; i <= 1; i++){
71         data_pkt[0][3] = i;
72         memcpy(data_pkt[0] + 4, hw->name[i], MD_NAME_LEN * 2);
73         if(!usbsend(kb, data_pkt[0], 1))
74             return -1;
75     }
76     // Save the IDs
77     for(int i = 0; i <= 1; i++){
78         data_pkt[1][3] = i;
79         memcpy(data_pkt[1] + 4, hw->id + i, sizeof(usbid));
80         if(!usbsend(kb, data_pkt[1], 1))
81             return -1;
82     }
83     // Save the RGB data for the non-DPI zones
84     if(savergb_mouse(kb, hw->light, 0))
85         return -1;
86     // Save the DPI data (also saves RGB for those states)
87     if(savedpi(kb, hw->dpi, hw->light))
88         return -1;
89     DELAY_LONG(kb);
90     return 0;
91 }
.fi
.SS "void cmd_id (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *id)"

.PP
Definition at line 168 of file profile\&.c\&.
.PP
References usbmode::id, usbid::modified, and setid()\&.
.PP
.nf
168                                                                                  {
169     (void)kb;
170     (void)dummy1;
171     (void)dummy2;
172 
173     // ID is either a GUID or an 8-digit hex number
174     int newmodified;
175     if(!setid(&mode->id, id) && sscanf(id, "%08x", &newmodified) == 1)
176         memcpy(mode->id\&.modified, &newmodified, sizeof(newmodified));
177 }
.fi
.SS "void cmd_name (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *name)"

.PP
Definition at line 117 of file profile\&.c\&.
.PP
References MD_NAME_LEN, usbmode::name, u16enc(), and urldecode2()\&.
.PP
.nf
117                                                                                      {
118     (void)kb;
119     (void)dummy1;
120     (void)dummy2;
121 
122     char decoded[strlen(name) + 1];
123     urldecode2(decoded, name);
124     size_t srclen = strlen(decoded), dstlen = MD_NAME_LEN;
125     u16enc(decoded, mode->name, &srclen, &dstlen);
126 }
.fi
.SS "void cmd_profileid (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *id)"

.PP
Definition at line 179 of file profile\&.c\&.
.PP
References usbprofile::id, usbid::modified, usbdevice::profile, and setid()\&.
.PP
.nf
179                                                                                         {
180     (void)mode;
181     (void)dummy1;
182     (void)dummy2;
183 
184     usbprofile* profile = kb->profile;
185     int newmodified;
186     if(!setid(&profile->id, id) && sscanf(id, "%08x", &newmodified) == 1)
187         memcpy(profile->id\&.modified, &newmodified, sizeof(newmodified));
188 
189 }
.fi
.SS "void cmd_profilename (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *name)"

.PP
Definition at line 128 of file profile\&.c\&.
.PP
References usbprofile::name, PR_NAME_LEN, usbdevice::profile, u16enc(), and urldecode2()\&.
.PP
.nf
128                                                                                               {
129     (void)dummy1;
130     (void)dummy2;
131     (void)dummy3;
132 
133     usbprofile* profile = kb->profile;
134     char decoded[strlen(name) + 1];
135     urldecode2(decoded, name);
136     size_t srclen = strlen(decoded), dstlen = PR_NAME_LEN;
137     u16enc(decoded, profile->name, &srclen, &dstlen);
138 }
.fi
.SS "void freeprofile (\fBusbdevice\fP *kb)"

.PP
Definition at line 253 of file profile\&.c\&.
.PP
References _freeprofile(), and usbdevice::hw\&.
.PP
.nf
253                                {
254     _freeprofile(kb);
255     // Also free HW profile
256     free(kb->hw);
257     kb->hw = 0;
258 }
.fi
.SS "char* gethwmodename (\fBhwprofile\fP *profile, intindex)"

.PP
Definition at line 160 of file profile\&.c\&.
.PP
References MD_NAME_LEN, hwprofile::name, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
160                                                   {
161     return printname(profile->name[index + 1], MD_NAME_LEN);
162 }
.fi
.SS "char* gethwprofilename (\fBhwprofile\fP *profile)"

.PP
Definition at line 164 of file profile\&.c\&.
.PP
References MD_NAME_LEN, hwprofile::name, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
164                                           {
165     return printname(profile->name[0], MD_NAME_LEN);
166 }
.fi
.SS "char* getid (\fBusbid\fP *id)"

.PP
Definition at line 79 of file profile\&.c\&.
.PP
References usbid::guid\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
79                       {
80     int32_t data1;
81     int16_t data2, data3, data4a;
82     char data4b[6];
83     memcpy(&data1, id->guid + 0x0, 4);
84     memcpy(&data2, id->guid + 0x4, 2);
85     memcpy(&data3, id->guid + 0x6, 2);
86     memcpy(&data4a, id->guid + 0x8, 2);
87     memcpy(data4b, id->guid + 0xA, 6);
88     char* guid = malloc(39);
89     snprintf(guid, 39, "{%08X-%04hX-%04hX-%04hX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
90              data1, data2, data3, data4a, data4b[0], data4b[1], data4b[2], data4b[3], data4b[4], data4b[5]);
91     return guid;
92 }
.fi
.SS "char* getmodename (\fBusbmode\fP *mode)"

.PP
Definition at line 152 of file profile\&.c\&.
.PP
References MD_NAME_LEN, usbmode::name, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
152                                 {
153     return printname(mode->name, MD_NAME_LEN);
154 }
.fi
.SS "char* getprofilename (\fBusbprofile\fP *profile)"

.PP
Definition at line 156 of file profile\&.c\&.
.PP
References usbprofile::name, PR_NAME_LEN, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
156                                          {
157     return printname(profile->name, PR_NAME_LEN);
158 }
.fi
.SS "void hwtonative (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, intmodecount)"

.PP
Definition at line 260 of file profile\&.c\&.
.PP
References usbmode::dpi, hwprofile::dpi, dpiset::forceupdate, lighting::forceupdate, usbmode::id, usbprofile::id, hwprofile::id, usbprofile::lastdpi, usbprofile::lastlight, usbmode::light, hwprofile::light, MD_NAME_LEN, usbprofile::mode, usbmode::name, usbprofile::name, hwprofile::name, and PR_NAME_LEN\&.
.PP
Referenced by cmd_hwload_kb(), and cmd_hwload_mouse()\&.
.PP
.nf
260                                                                   {
261     // Copy the profile name and ID
262     memcpy(profile->name, hw->name[0], PR_NAME_LEN * 2);
263     memcpy(&profile->id, hw->id, sizeof(usbid));
264     // Copy the mode settings
265     for(int i = 0; i < modecount; i++){
266         usbmode* mode = profile->mode + i;
267         memcpy(mode->name, hw->name[i + 1], MD_NAME_LEN * 2);
268         memcpy(&mode->id, hw->id + i + 1, sizeof(usbid));
269         memcpy(&mode->light, hw->light + i, sizeof(lighting));
270         memcpy(&mode->dpi, hw->dpi + i, sizeof(dpiset));
271         // Set a force update on the light/DPI since they've been overwritten
272         mode->light\&.forceupdate = mode->dpi\&.forceupdate = 1;
273     }
274     profile->lastlight\&.forceupdate = profile->lastdpi\&.forceupdate = 1;
275 }
.fi
.SS "int loadprofile (\fBusbdevice\fP *kb)"

.PP
Definition at line 208 of file profile\&.c\&.
.PP
References hwloadprofile\&.
.PP
.nf
208                               {
209     if(hwloadprofile(kb, 1))
210         return -1;
211     return 0;
212 }
.fi
.SS "void nativetohw (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, intmodecount)"

.PP
Definition at line 277 of file profile\&.c\&.
.PP
References usbmode::dpi, hwprofile::dpi, usbmode::id, usbprofile::id, hwprofile::id, usbmode::light, hwprofile::light, MD_NAME_LEN, usbprofile::mode, usbmode::name, usbprofile::name, hwprofile::name, and PR_NAME_LEN\&.
.PP
Referenced by cmd_hwsave_kb(), and cmd_hwsave_mouse()\&.
.PP
.nf
277                                                                   {
278     // Copy name and ID
279     memcpy(hw->name[0], profile->name, PR_NAME_LEN * 2);
280     memcpy(hw->id, &profile->id, sizeof(usbid));
281     // Copy the mode settings
282     for(int i = 0; i < modecount; i++){
283         usbmode* mode = profile->mode + i;
284         memcpy(hw->name[i + 1], mode->name, MD_NAME_LEN * 2);
285         memcpy(hw->id + i + 1, &mode->id, sizeof(usbid));
286         memcpy(hw->light + i, &mode->light, sizeof(lighting));
287         memcpy(hw->dpi + i, &mode->dpi, sizeof(dpiset));
288     }
289 }
.fi
.SS "int setid (\fBusbid\fP *id, const char *guid)"

.PP
Definition at line 64 of file profile\&.c\&.
.PP
References usbid::guid\&.
.PP
Referenced by cmd_id(), and cmd_profileid()\&.
.PP
.nf
64                                       {
65     int32_t data1;
66     int16_t data2, data3, data4a;
67     char data4b[6];
68     if(sscanf(guid, "{%08X-%04hX-%04hX-%04hX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
69               &data1, &data2, &data3, &data4a, data4b, data4b + 1, data4b + 2, data4b + 3, data4b + 4, data4b + 5) != 10)
70         return 0;
71     memcpy(id->guid + 0x0, &data1, 4);
72     memcpy(id->guid + 0x4, &data2, 2);
73     memcpy(id->guid + 0x6, &data3, 2);
74     memcpy(id->guid + 0x8, &data4a, 2);
75     memcpy(id->guid + 0xA, data4b, 6);
76     return 1;
77 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
