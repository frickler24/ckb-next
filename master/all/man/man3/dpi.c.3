.TH "src/ckb-daemon/dpi.c" 3 "Tue May 16 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/dpi.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'dpi\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcmd_dpi\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, const char *stages, const char *values)"
.br
.ti -1c
.RI "void \fBcmd_dpisel\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *stage)"
.br
.ti -1c
.RI "void \fBcmd_lift\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *height)"
.br
.ti -1c
.RI "void \fBcmd_snap\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *enable)"
.br
.ti -1c
.RI "char * \fBprintdpi\fP (const \fBdpiset\fP *dpi, const \fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBupdatedpi\fP (\fBusbdevice\fP *kb, int force)"
.br
.ti -1c
.RI "int \fBsavedpi\fP (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"
.br
.ti -1c
.RI "int \fBloaddpi\fP (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void cmd_dpi (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, const char *stages, const char *values)"

.PP
Definition at line 4 of file dpi\&.c\&.
.PP
References usbmode::dpi, DPI_COUNT, dpiset::enabled, left, dpiset::x, x, dpiset::y, and y\&.
.PP
.nf
4                                                                                              {
5     int disable = 0;
6     ushort x, y;
7     // Try to scan X,Y values
8     if(sscanf(values, "%hu,%hu", &x, &y) != 2){
9         // If that doesn't work, scan single number
10         if(sscanf(values, "%hu", &x) == 1)
11             y = x;
12         else if(!strncmp(values, "off", 3))
13             // If the right side says "off", disable the level(s)
14             disable = 1;
15         else
16             // Otherwise, quit
17             return;
18     }
19     if((x == 0 || y == 0) && !disable)
20         return;
21     // Scan the left side for stage numbers (comma-separated)
22     int left = strlen(stages);
23     int position = 0, field = 0;
24     char stagename[3];
25     while(position < left && sscanf(stages + position, "%2[^,]%n", stagename, &field) == 1){
26         uchar stagenum;
27         if(sscanf(stagename, "%hhu", &stagenum) && stagenum < DPI_COUNT){
28             // Set DPI for this stage
29             if(disable){
30                 mode->dpi\&.enabled &= ~(1 << stagenum);
31                 mode->dpi\&.x[stagenum] = 0;
32                 mode->dpi\&.y[stagenum] = 0;
33             } else {
34                 mode->dpi\&.enabled |= 1 << stagenum;
35                 mode->dpi\&.x[stagenum] = x;
36                 mode->dpi\&.y[stagenum] = y;
37             }
38         }
39         if(stages[position += field] == ',')
40             position++;
41     }
42 }
.fi
.SS "void cmd_dpisel (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *stage)"

.PP
Definition at line 44 of file dpi\&.c\&.
.PP
References dpiset::current, usbmode::dpi, and DPI_COUNT\&.
.PP
.nf
44                                                                                         {
45     uchar stagenum;
46     if(sscanf(stage, "%hhu", &stagenum) != 1)
47         return;
48     if(stagenum > DPI_COUNT)
49         return;
50     mode->dpi\&.current = stagenum;
51 }
.fi
.SS "void cmd_lift (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *height)"

.PP
Definition at line 53 of file dpi\&.c\&.
.PP
References usbmode::dpi, dpiset::lift, LIFT_MAX, and LIFT_MIN\&.
.PP
.nf
53                                                                                        {
54     uchar heightnum;
55     if(sscanf(height, "%hhu", &heightnum) != 1)
56         return;
57     if(heightnum > LIFT_MAX || heightnum < LIFT_MIN)
58         return;
59     mode->dpi\&.lift = heightnum;
60 }
.fi
.SS "void cmd_snap (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *enable)"

.PP
Definition at line 62 of file dpi\&.c\&.
.PP
References usbmode::dpi, and dpiset::snap\&.
.PP
.nf
62                                                                                        {
63     if(!strcmp(enable, "on"))
64         mode->dpi\&.snap = 1;
65     if(!strcmp(enable, "off"))
66         mode->dpi\&.snap = 0;
67 }
.fi
.SS "int loaddpi (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"

.PP
Definition at line 152 of file dpi\&.c\&.
.PP
References lighting::b, ckb_err, dpiset::current, DPI_COUNT, dpiset::enabled, lighting::g, LED_MOUSE, dpiset::lift, LIFT_MAX, LIFT_MIN, MSG_SIZE, N_MOUSE_ZONES, lighting::r, dpiset::snap, usbrecv, dpiset::x, and dpiset::y\&.
.PP
Referenced by cmd_hwload_mouse()\&.
.PP
.nf
152                                                         {
153     // Ask for settings
154     uchar data_pkt[4][MSG_SIZE] = {
155         { 0x0e, 0x13, 0x05, 1, },
156         { 0x0e, 0x13, 0x02, 1, },
157         { 0x0e, 0x13, 0x03, 1, },
158         { 0x0e, 0x13, 0x04, 1, }
159     };
160     uchar in_pkt[4][MSG_SIZE];
161     for(int i = 0; i < 4; i++){
162         if(!usbrecv(kb, data_pkt[i], in_pkt[i]))
163             return -2;
164         if(memcmp(in_pkt[i], data_pkt[i], 4)){
165             ckb_err("Bad input header\n");
166             return -3;
167         }
168     }
169     // Copy data from device
170     dpi->enabled = in_pkt[0][4];
171     dpi->enabled &= (1 << DPI_COUNT) - 1;
172     dpi->current = in_pkt[1][4];
173     if(dpi->current >= DPI_COUNT)
174         dpi->current = 0;
175     dpi->lift = in_pkt[2][4];
176     if(dpi->lift < LIFT_MIN || dpi->lift > LIFT_MAX)
177         dpi->lift = LIFT_MIN;
178     dpi->snap = !!in_pkt[3][4];
179 
180     // Get X/Y DPIs
181     for(int i = 0; i < DPI_COUNT; i++){
182         uchar data_pkt[MSG_SIZE] = { 0x0e, 0x13, 0xd0, 1 };
183         uchar in_pkt[MSG_SIZE];
184         data_pkt[2] |= i;
185         if(!usbrecv(kb, data_pkt, in_pkt))
186             return -2;
187         if(memcmp(in_pkt, data_pkt, 4)){
188             ckb_err("Bad input header\n");
189             return -3;
190         }
191         // Copy to profile
192         dpi->x[i] = *(ushort*)(in_pkt + 5);
193         dpi->y[i] = *(ushort*)(in_pkt + 7);
194         light->r[LED_MOUSE + N_MOUSE_ZONES + i] = in_pkt[9];
195         light->g[LED_MOUSE + N_MOUSE_ZONES + i] = in_pkt[10];
196         light->b[LED_MOUSE + N_MOUSE_ZONES + i] = in_pkt[11];
197     }
198     // Finished\&. Set SW DPI light to the current hardware level
199     light->r[LED_MOUSE + 2] = light->r[LED_MOUSE + N_MOUSE_ZONES + dpi->current];
200     light->g[LED_MOUSE + 2] = light->g[LED_MOUSE + N_MOUSE_ZONES + dpi->current];
201     light->b[LED_MOUSE + 2] = light->b[LED_MOUSE + N_MOUSE_ZONES + dpi->current];
202     return 0;
203 }
.fi
.SS "char* printdpi (const \fBdpiset\fP *dpi, const \fBusbdevice\fP *kb)"

.PP
Definition at line 69 of file dpi\&.c\&.
.PP
References _readlines_ctx::buffer, DPI_COUNT, dpiset::enabled, dpiset::x, and dpiset::y\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
69                                                       {
70     // Print all DPI settings
71     const int BUFFER_LEN = 100;
72     char* buffer = malloc(BUFFER_LEN);
73     int length = 0;
74     for(int i = 0; i < DPI_COUNT; i++){
75         // Print the stage number
76         int newlen = 0;
77         snprintf(buffer + length, BUFFER_LEN - length, length == 0 ? "%d%n" : " %d%n", i, &newlen);
78         length += newlen;
79         // Print the DPI settings
80         if(!(dpi->enabled & (1 << i)))
81             snprintf(buffer + length, BUFFER_LEN - length, ":off%n", &newlen);
82         else
83             snprintf(buffer + length, BUFFER_LEN - length, ":%u,%u%n", dpi->x[i], dpi->y[i], &newlen);
84         length += newlen;
85     }
86     return buffer;
87 }
.fi
.SS "int savedpi (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"

.PP
Definition at line 124 of file dpi\&.c\&.
.PP
References lighting::b, dpiset::current, DPI_COUNT, dpiset::enabled, lighting::g, LED_MOUSE, dpiset::lift, MSG_SIZE, N_MOUSE_ZONES, lighting::r, dpiset::snap, usbsend, dpiset::x, and dpiset::y\&.
.PP
Referenced by cmd_hwsave_mouse()\&.
.PP
.nf
124                                                         {
125     // Send X/Y DPIs
126     for(int i = 0; i < DPI_COUNT; i++){
127         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0xd0, 1 };
128         data_pkt[2] |= i;
129         *(ushort*)(data_pkt + 5) = dpi->x[i];
130         *(ushort*)(data_pkt + 7) = dpi->y[i];
131         // Save the RGB value for this setting too
132         data_pkt[9] = light->r[LED_MOUSE + N_MOUSE_ZONES + i];
133         data_pkt[10] = light->g[LED_MOUSE + N_MOUSE_ZONES + i];
134         data_pkt[11] = light->b[LED_MOUSE + N_MOUSE_ZONES + i];
135         if(!usbsend(kb, data_pkt, 1))
136             return -1;
137     }
138 
139     // Send settings
140     uchar data_pkt[4][MSG_SIZE] = {
141         { 0x07, 0x13, 0x05, 1, dpi->enabled },
142         { 0x07, 0x13, 0x02, 1, dpi->current },
143         { 0x07, 0x13, 0x03, 1, dpi->lift },
144         { 0x07, 0x13, 0x04, 1, dpi->snap, 0x05 }
145     };
146     if(!usbsend(kb, data_pkt[0], 4))
147         return -2;
148     // Finished
149     return 0;
150 }
.fi
.SS "int updatedpi (\fBusbdevice\fP *kb, intforce)"

.PP
Definition at line 89 of file dpi\&.c\&.
.PP
References usbdevice::active, dpiset::current, usbprofile::currentmode, usbmode::dpi, DPI_COUNT, dpiset::enabled, dpiset::forceupdate, usbprofile::lastdpi, dpiset::lift, MSG_SIZE, usbdevice::profile, dpiset::snap, usbsend, dpiset::x, and dpiset::y\&.
.PP
.nf
89                                        {
90     if(!kb->active)
91         return 0;
92     dpiset* lastdpi = &kb->profile->lastdpi;
93     dpiset* newdpi = &kb->profile->currentmode->dpi;
94     // Don't do anything if the settings haven't changed
95     if(!force && !lastdpi->forceupdate && !newdpi->forceupdate
96             && !memcmp(lastdpi, newdpi, sizeof(dpiset)))
97         return 0;
98     lastdpi->forceupdate = newdpi->forceupdate = 0;
99 
100     // Send X/Y DPIs
101     for(int i = 0; i < DPI_COUNT; i++){
102         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0xd0, 0 };
103         data_pkt[2] |= i;
104         *(ushort*)(data_pkt + 5) = newdpi->x[i];
105         *(ushort*)(data_pkt + 7) = newdpi->y[i];
106         if(!usbsend(kb, data_pkt, 1))
107             return -1;
108     }
109 
110     // Send settings
111     uchar data_pkt[4][MSG_SIZE] = {
112         { 0x07, 0x13, 0x05, 0, newdpi->enabled },
113         { 0x07, 0x13, 0x02, 0, newdpi->current },
114         { 0x07, 0x13, 0x03, 0, newdpi->lift },
115         { 0x07, 0x13, 0x04, 0, newdpi->snap, 0x05 }
116     };
117     if(!usbsend(kb, data_pkt[0], 4))
118         return -2;
119     // Finished
120     memcpy(lastdpi, newdpi, sizeof(dpiset));
121     return 0;
122 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
