.TH "src/ckb-daemon/led_mouse.c" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/led_mouse.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'led\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static int \fBrgbcmp\fP (const \fBlighting\fP *lhs, const \fBlighting\fP *rhs)"
.br
.ti -1c
.RI "static int \fBisblack\fP (const \fBusbdevice\fP *kb, const \fBlighting\fP *light)"
.br
.ti -1c
.RI "int \fBupdatergb_mouse\fP (\fBusbdevice\fP *kb, int force)"
.br
.ti -1c
.RI "int \fBsavergb_mouse\fP (\fBusbdevice\fP *kb, \fBlighting\fP *light, int mode)"
.br
.ti -1c
.RI "int \fBloadrgb_mouse\fP (\fBusbdevice\fP *kb, \fBlighting\fP *light, int mode)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static int isblack (const \fBusbdevice\fP *kb, const \fBlighting\fP *light)\fC [static]\fP"

.PP
Definition at line 13 of file led_mouse\&.c\&.
.PP
References lighting::b, lighting::g, IS_M65, LED_MOUSE, N_MOUSE_ZONES, and lighting::r\&.
.PP
Referenced by updatergb_mouse()\&.
.PP
.nf
13                                                               {
14     if(!IS_M65(kb))
15         return 0;
16     uchar black[N_MOUSE_ZONES] = { 0 };
17     return !memcmp(light->r + LED_MOUSE, black, sizeof(black)) && !memcmp(light->g + LED_MOUSE, black, sizeof(black)) && !memcmp(light->b + LED_MOUSE, black, sizeof(black));
18 }
.fi
.SS "int loadrgb_mouse (\fBusbdevice\fP *kb, \fBlighting\fP *light, intmode)"

.PP
Definition at line 87 of file led_mouse\&.c\&.
.PP
References lighting::b, ckb_err, lighting::g, IS_SABRE, IS_SCIMITAR, LED_DPI, LED_MOUSE, MSG_SIZE, lighting::r, and usbrecv\&.
.PP
Referenced by cmd_hwload_mouse()\&.
.PP
.nf
87                                                            {
88     (void)mode;
89 
90     uchar data_pkt[MSG_SIZE] = { 0x0e, 0x13, 0x10, 1, 0 };
91     uchar in_pkt[MSG_SIZE] = { 0 };
92     // Load each RGB zone
93     int zonecount = IS_SCIMITAR(kb) ? 4 : IS_SABRE(kb) ? 3 : 2;
94     for(int i = 0; i < zonecount; i++){
95         if(!usbrecv(kb, data_pkt, in_pkt))
96             return -1;
97         if(memcmp(in_pkt, data_pkt, 4)){
98             ckb_err("Bad input header\n");
99             return -2;
100         }
101         // Copy data
102         int led = LED_MOUSE + i;
103         if(led >= LED_DPI)
104             led++;          // Skip DPI light
105         light->r[led] = in_pkt[4];
106         light->g[led] = in_pkt[5];
107         light->b[led] = in_pkt[6];
108         // Set packet for next zone
109         data_pkt[2]++;
110     }
111     return 0;
112 }
.fi
.SS "static int rgbcmp (const \fBlighting\fP *lhs, const \fBlighting\fP *rhs)\fC [static]\fP"

.PP
Definition at line 7 of file led_mouse\&.c\&.
.PP
References lighting::b, lighting::g, LED_MOUSE, N_MOUSE_ZONES, and lighting::r\&.
.PP
Referenced by updatergb_mouse()\&.
.PP
.nf
7                                                            {
8     return memcmp(lhs->r + LED_MOUSE, rhs->r + LED_MOUSE, N_MOUSE_ZONES) || memcmp(lhs->g + LED_MOUSE, rhs->g + LED_MOUSE, N_MOUSE_ZONES) || memcmp(lhs->b + LED_MOUSE, rhs->b + LED_MOUSE, N_MOUSE_ZONES);
9 }
.fi
.SS "int savergb_mouse (\fBusbdevice\fP *kb, \fBlighting\fP *light, intmode)"

.PP
Definition at line 66 of file led_mouse\&.c\&.
.PP
References lighting::b, lighting::g, IS_SABRE, IS_SCIMITAR, LED_DPI, LED_MOUSE, MSG_SIZE, lighting::r, and usbsend\&.
.PP
Referenced by cmd_hwsave_mouse()\&.
.PP
.nf
66                                                            {
67     (void)mode;
68 
69     uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x10, 1, 0 };
70     // Save each RGB zone, minus the DPI light which is sent in the DPI packets
71     int zonecount = IS_SCIMITAR(kb) ? 4 : IS_SABRE(kb) ? 3 : 2;
72     for(int i = 0; i < zonecount; i++){
73         int led = LED_MOUSE + i;
74         if(led >= LED_DPI)
75             led++;          // Skip DPI light
76         data_pkt[4] = light->r[led];
77         data_pkt[5] = light->g[led];
78         data_pkt[6] = light->b[led];
79         if(!usbsend(kb, data_pkt, 1))
80             return -1;
81         // Set packet for next zone
82         data_pkt[2]++;
83     }
84     return 0;
85 }
.fi
.SS "int updatergb_mouse (\fBusbdevice\fP *kb, intforce)"

.PP
Definition at line 20 of file led_mouse\&.c\&.
.PP
References usbdevice::active, lighting::b, usbprofile::currentmode, lighting::forceupdate, lighting::g, IS_GLAIVE, isblack(), usbprofile::lastlight, LED_MOUSE, usbmode::light, MSG_SIZE, N_MOUSE_ZONES, usbdevice::profile, lighting::r, rgbcmp(), and usbsend\&.
.PP
.nf
20                                              {
21     if(!kb->active)
22         return 0;
23     lighting* lastlight = &kb->profile->lastlight;
24     lighting* newlight = &kb->profile->currentmode->light;
25     // Don't do anything if the lighting hasn't changed
26     if(!force && !lastlight->forceupdate && !newlight->forceupdate
27             && !rgbcmp(lastlight, newlight))
28         return 0;
29     lastlight->forceupdate = newlight->forceupdate = 0;
30 
31     // Prevent writing to DPI LEDs or non-existent LED zones for the Glaive\&.
32     int num_zones = IS_GLAIVE(kb) ? 3 : N_MOUSE_ZONES;
33     // Send the RGB values for each zone to the mouse
34     uchar data_pkt[2][MSG_SIZE] = {
35         { 0x07, 0x22, num_zones, 0x01, 0 }, // RGB colors
36         { 0x07, 0x05, 0x02, 0 }                 // Lighting on/off
37     };
38     uchar* rgb_data = &data_pkt[0][4];
39     for(int i = 0; i < N_MOUSE_ZONES; i++){
40         if (IS_GLAIVE(kb) && i != 0 && i != 1 && i != 5)
41         continue;
42         *rgb_data++ = i + 1;
43         *rgb_data++ = newlight->r[LED_MOUSE + i];
44         *rgb_data++ = newlight->g[LED_MOUSE + i];
45         *rgb_data++ = newlight->b[LED_MOUSE + i];
46     }
47     // Send RGB data
48     if(!usbsend(kb, data_pkt[0], 1))
49         return -1;
50     int was_black = isblack(kb, lastlight), is_black = isblack(kb, newlight);
51     if(is_black){
52         // If the lighting is black, send the deactivation packet (M65 only)
53         if(!usbsend(kb, data_pkt[1], 1))
54             return -1;
55     } else if(was_black || force){
56         // If the lighting WAS black, or if we're on forced update, send the activation packet
57         data_pkt[1][4] = 1;
58         if(!usbsend(kb, data_pkt[1], 1))
59             return -1;
60     }
61 
62     memcpy(lastlight, newlight, sizeof(lighting));
63     return 0;
64 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
