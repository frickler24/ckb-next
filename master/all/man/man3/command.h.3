.TH "src/ckb-daemon/command.h" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/command.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "union \fBdevcmd\fP"
.br
.ti -1c
.RI "struct \fBdevcmd\&.__unnamed__\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCMD_COUNT\fP   (\fBCMD_LAST\fP - \fBCMD_FIRST\fP + 2)"
.br
.ti -1c
.RI "#define \fBCMD_DEV_COUNT\fP   (\fBCMD_LAST\fP - \fBCMD_VT_FIRST\fP + 1)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBcmdhandler\fP )(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *\fBparameter\fP)"
.br
.ti -1c
.RI "typedef int(* \fBcmdhandler_io\fP )(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *\fBparameter\fP)"
.br
.ti -1c
.RI "typedef void(* \fBcmdhandler_mac\fP )(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, const char *keys, const char *assignment)"
.br
.ti -1c
.RI "typedef union \fBdevcmd\fP \fBdevcmd\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBcmd\fP { \fBNONE\fP = -11, \fBDELAY\fP = -10, \fBCMD_FIRST\fP = DELAY, \fBMODE\fP = -9, \fBSWITCH\fP = -8, \fBLAYOUT\fP = -7, \fBACCEL\fP = -6, \fBSCROLLSPEED\fP = -5, \fBNOTIFYON\fP = -4, \fBNOTIFYOFF\fP = -3, \fBFPS\fP = -2, \fBDITHER\fP = -1, \fBHWLOAD\fP = 0, \fBCMD_VT_FIRST\fP = 0, \fBHWSAVE\fP, \fBFWUPDATE\fP, \fBPOLLRATE\fP, \fBACTIVE\fP, \fBIDLE\fP, \fBERASE\fP, \fBERASEPROFILE\fP, \fBNAME\fP, \fBPROFILENAME\fP, \fBID\fP, \fBPROFILEID\fP, \fBRGB\fP, \fBIOFF\fP, \fBION\fP, \fBIAUTO\fP, \fBBIND\fP, \fBUNBIND\fP, \fBREBIND\fP, \fBMACRO\fP, \fBDPI\fP, \fBDPISEL\fP, \fBLIFT\fP, \fBSNAP\fP, \fBNOTIFY\fP, \fBINOTIFY\fP, \fBGET\fP, \fBRESTART\fP, \fBCMD_LAST\fP = RESTART }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBreadcmd\fP (\fBusbdevice\fP *kb, const char *line)"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "union devcmd"
.PP 
Definition at line 73 of file command\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
struct \fBdevcmd\fP \fI__unnamed__\fP 
.br
.PP
\fBcmdhandler\fP \fIdo_cmd[(\fBCMD_LAST\fP-\fBCMD_VT_FIRST\fP+1)]\fP 
.br
.PP
\fBcmdhandler_io\fP \fIdo_io[(\fBCMD_LAST\fP-\fBCMD_VT_FIRST\fP+1)]\fP 
.br
.PP
\fBcmdhandler_mac\fP \fIdo_macro[(\fBCMD_LAST\fP-\fBCMD_VT_FIRST\fP+1)]\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define CMD_COUNT   (\fBCMD_LAST\fP - \fBCMD_FIRST\fP + 2)"

.PP
Definition at line 65 of file command\&.h\&.
.PP
Referenced by readcmd()\&.
.SS "#define CMD_DEV_COUNT   (\fBCMD_LAST\fP - \fBCMD_VT_FIRST\fP + 1)"

.PP
Definition at line 66 of file command\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* cmdhandler)(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *\fBparameter\fP)"

.PP
Definition at line 70 of file command\&.h\&.
.SS "typedef int(* cmdhandler_io)(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *\fBparameter\fP)"

.PP
Definition at line 71 of file command\&.h\&.
.SS "typedef void(* cmdhandler_mac)(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, const char *keys, const char *assignment)"

.PP
Definition at line 72 of file command\&.h\&.
.SS "typedef union \fBdevcmd\fP  \fBdevcmd\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBcmd\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINONE \fP\fP
.TP
\fB\fIDELAY \fP\fP
.TP
\fB\fICMD_FIRST \fP\fP
.TP
\fB\fIMODE \fP\fP
.TP
\fB\fISWITCH \fP\fP
.TP
\fB\fILAYOUT \fP\fP
.TP
\fB\fIACCEL \fP\fP
.TP
\fB\fISCROLLSPEED \fP\fP
.TP
\fB\fINOTIFYON \fP\fP
.TP
\fB\fINOTIFYOFF \fP\fP
.TP
\fB\fIFPS \fP\fP
.TP
\fB\fIDITHER \fP\fP
.TP
\fB\fIHWLOAD \fP\fP
.TP
\fB\fICMD_VT_FIRST \fP\fP
.TP
\fB\fIHWSAVE \fP\fP
.TP
\fB\fIFWUPDATE \fP\fP
.TP
\fB\fIPOLLRATE \fP\fP
.TP
\fB\fIACTIVE \fP\fP
.TP
\fB\fIIDLE \fP\fP
.TP
\fB\fIERASE \fP\fP
.TP
\fB\fIERASEPROFILE \fP\fP
.TP
\fB\fINAME \fP\fP
.TP
\fB\fIPROFILENAME \fP\fP
.TP
\fB\fIID \fP\fP
.TP
\fB\fIPROFILEID \fP\fP
.TP
\fB\fIRGB \fP\fP
.TP
\fB\fIIOFF \fP\fP
.TP
\fB\fIION \fP\fP
.TP
\fB\fIIAUTO \fP\fP
.TP
\fB\fIBIND \fP\fP
.TP
\fB\fIUNBIND \fP\fP
.TP
\fB\fIREBIND \fP\fP
.TP
\fB\fIMACRO \fP\fP
.TP
\fB\fIDPI \fP\fP
.TP
\fB\fIDPISEL \fP\fP
.TP
\fB\fILIFT \fP\fP
.TP
\fB\fISNAP \fP\fP
.TP
\fB\fINOTIFY \fP\fP
.TP
\fB\fIINOTIFY \fP\fP
.TP
\fB\fIGET \fP\fP
.TP
\fB\fIRESTART \fP\fP
.TP
\fB\fICMD_LAST \fP\fP
.PP
Definition at line 7 of file command\&.h\&.
.PP
.nf
7              {
8     // Special - handled by readcmd, no device functions
9     NONE        = -11,
10     DELAY       = -10,   CMD_FIRST = DELAY,
11     MODE        = -9,
12     SWITCH      = -8,
13     LAYOUT      = -7,
14     ACCEL       = -6,
15     SCROLLSPEED = -5,
16     NOTIFYON    = -4,
17     NOTIFYOFF   = -3,
18     FPS         = -2,
19     DITHER      = -1,
20 
21     // Hardware data
22     HWLOAD      = 0,    CMD_VT_FIRST = 0,
23     HWSAVE,
24     FWUPDATE,
25     POLLRATE,
26 
27     // Software control on/off
28     ACTIVE,
29     IDLE,
30 
31     // Profile/mode metadata
32     ERASE,
33     ERASEPROFILE,
34     NAME,
35     PROFILENAME,
36     ID,
37     PROFILEID,
38 
39     // LED control
40     RGB,
41     IOFF,
42     ION,
43     IAUTO,
44 
45     // Key binding control
46     BIND,
47     UNBIND,
48     REBIND,
49     MACRO,
50 
51     // DPI control
52     DPI,
53     DPISEL,
54     LIFT,
55     SNAP,
56 
57     // Notifications and output
58     NOTIFY,
59     INOTIFY,
60     GET,
61     RESTART,
62 
63     CMD_LAST = RESTART
64 } cmd;
.fi
.SH "Function Documentation"
.PP 
.SS "int readcmd (\fBusbdevice\fP *kb, const char *line)"
< Because length of word is length of line + 1, there should be no problem with buffer overflow\&. 
.PP
Definition at line 68 of file command\&.c\&.
.PP
References ACCEL, ACTIVE, usbdevice::active, BIND, CMD_COUNT, CMD_FIRST, cmd_strings, usbprofile::currentmode, DELAY, usbdevice::delay, DITHER, usbdevice::dither, devcmd::do_cmd, devcmd::do_io, devcmd::do_macro, DPI, DPISEL, ERASE, ERASEPROFILE, FEAT_ANSI, FEAT_BIND, FEAT_ISO, FEAT_LMASK, FEAT_MOUSEACCEL, FEAT_NOTIFY, usbdevice::features, lighting::forceupdate, FPS, FWUPDATE, GET, HAS_FEATURES, HWLOAD, HWSAVE, IAUTO, ID, IDLE, INDEX_OF, INOTIFY, IOFF, ION, IS_FULLRANGE, IS_MOUSE_DEV, keymap, LAYOUT, left, LIFT, usbmode::light, MACRO, mknotifynode(), MODE, usbprofile::mode, MODE_COUNT, N_KEYS_EXTENDED, NAME, NEEDS_FW_UPDATE, NONE, NOTIFY, NOTIFYOFF, NOTIFYON, OUTFIFO_MAX, POLLRATE, usbdevice::profile, PROFILEID, PROFILENAME, REBIND, RESTART, RGB, right(), rmnotifynode(), SCROLL_ACCELERATED, SCROLL_MAX, SCROLL_MIN, SCROLLSPEED, SNAP, SWITCH, TRY_WITH_RESET, UNBIND, usbdevice::usbdelay, and usbdevice::vtable\&.
.PP
Referenced by devmain()\&.
.PP
.nf
68                                             {
69     char* word = malloc(strlen(line) + 1);
70     int wordlen;
71     const char* newline = 0;
72     const devcmd* vt = kb->vtable;
73     usbprofile* profile = kb->profile;
74     usbmode* mode = 0;
75     int notifynumber = 0;
76     // Read words from the input
77     cmd command = NONE;
78     while(sscanf(line, "%s%n", word, &wordlen) == 1){
79         line += wordlen;
80         // If we passed a newline, reset the context
81         if(line > newline){
82             mode = profile->currentmode;
83             command = NONE;
84             notifynumber = 0;
85             newline = strchr(line, '\n');
86             if(!newline)
87                 newline = line + strlen(line);
88         }
89         // Check for a command word
90         for(int i = 0; i < CMD_COUNT - 1; i++){
91             if(!strcmp(word, cmd_strings[i])){
92                 command = i + CMD_FIRST;
93 #ifndef OS_MAC
94                 // Layout and mouse acceleration aren't used on Linux; ignore
95                 if(command == LAYOUT || command == ACCEL || command == SCROLLSPEED)
96                     command = NONE;
97 #endif
98                 // Most commands require parameters, but a few are actions in and of themselves
99                 if(command != SWITCH
100                         && command != HWLOAD && command != HWSAVE
101                         && command != ACTIVE && command != IDLE
102                         && command != ERASE && command != ERASEPROFILE
103                         && command != RESTART)
104                     goto next_loop;
105                 break;
106             }
107         }
108 
109         // Set current notification node when given @number
110         int newnotify;
111         if(sscanf(word, "@%u", &newnotify) == 1 && newnotify < OUTFIFO_MAX){
112             notifynumber = newnotify;
113             continue;
114         }
115 
116         // Reject unrecognized commands\&. Reject bind or notify related commands if the keyboard doesn't have the feature enabled\&.
117         if(command == NONE
118                 || ((!HAS_FEATURES(kb, FEAT_BIND) && (command == BIND || command == UNBIND || command == REBIND || command == MACRO || command == DELAY))
119                            || (!HAS_FEATURES(kb, FEAT_NOTIFY) && command == NOTIFY))){
120             next_loop:
121             continue;
122         }
123         // Reject anything not related to fwupdate if device has a bricked FW
124         if(NEEDS_FW_UPDATE(kb) && command != FWUPDATE && command != NOTIFYON && command != NOTIFYOFF)
125             continue;
126 
127         // Specially handled commands - these are available even when keyboard is IDLE
128         switch(command){
129         case NOTIFYON: {
130             // Notification node on
131             int notify;
132             if(sscanf(word, "%u", &notify) == 1)
133                 mknotifynode(kb, notify);
134             continue;
135         } case NOTIFYOFF: {
136             // Notification node off
137             int notify;
138             if(sscanf(word, "%u", &notify) == 1 && notify != 0) // notify0 can't be removed
139                 rmnotifynode(kb, notify);
140             continue;
141         } case GET:
142             // Output data to notification node
143             vt->get(kb, mode, notifynumber, 0, word);
144             continue;
145         case LAYOUT:
146             // OSX: switch ANSI/ISO keyboard layout
147             if(!strcmp(word, "ansi"))
148                 kb->features = (kb->features & ~FEAT_LMASK) | FEAT_ANSI;
149             else if(!strcmp(word, "iso"))
150                 kb->features = (kb->features & ~FEAT_LMASK) | FEAT_ISO;
151             continue;
152 #ifdef OS_MAC
153         case ACCEL:
154             // OSX mouse acceleration on/off
155             if(!strcmp(word, "on"))
156                 kb->features |= FEAT_MOUSEACCEL;
157             else if(!strcmp(word, "off"))
158                 kb->features &= ~FEAT_MOUSEACCEL;
159             continue;
160         case SCROLLSPEED:{
161             int newscroll;
162             if(sscanf(word, "%d", &newscroll) != 1)
163                 break;
164             if(newscroll < SCROLL_MIN)
165                 newscroll = SCROLL_ACCELERATED;
166             if(newscroll > SCROLL_MAX)
167                 newscroll = SCROLL_MAX;
168             kb->scroll_rate = newscroll;
169             continue;
170         }
171 #endif
172         case MODE: {
173             // Select a mode number (1 - 6)
174             int newmode;
175             if(sscanf(word, "%u", &newmode) == 1 && newmode > 0 && newmode <= MODE_COUNT)
176                 mode = profile->mode + newmode - 1;
177             continue;
178         }
179         case FPS: {
180             // USB command delay (2 - 10ms)
181             uint framerate;
182             if(sscanf(word, "%u", &framerate) == 1 && framerate > 0){
183                 // Not all devices require the same number of messages per frame; select delay appropriately
184                 uint per_frame = IS_MOUSE_DEV(kb) ? 2 : IS_FULLRANGE(kb) ? 14 : 5;
185                 uint delay = 1000 / framerate / per_frame;
186                 if(delay < 2)
187                     delay = 2;
188                 else if(delay > 10)
189                     delay = 10;
190                 kb->usbdelay = delay;
191             }
192             continue;
193         }
194         case DITHER: {
195             // 0: No dither, 1: Ordered dither\&.
196             uint dither;
197             if(sscanf(word, "%u", &dither) == 1 && dither <= 1){
198                 kb->dither = dither;
199                 profile->currentmode->light\&.forceupdate = 1;
200                 mode->light\&.forceupdate = 1;
201             }
202             continue;
203         }
204         case DELAY: {
205             long int delay;
206             if(sscanf(word, "%ld", &delay) == 1 && 0 <= delay && delay < UINT_MAX) {
207                 // Add delay of `newdelay` microseconds to macro playback
208                 kb->delay = (unsigned int)delay;
209             } else if(strcmp(word, "on") == 0) {
210                 // allow previous syntax, `delay on` means use old `long macro delay`
211                 kb->delay = UINT_MAX;
212             } else {
213                 // bad parameter to handle false commands like "delay off"
214                 kb->delay = 0; // No delay\&.
215             }
216             continue;
217         }
218         case RESTART: {
219             char mybuffer[] = "no reason specified";
220             if (sscanf(line, " %[^\n]", word) == -1) { 
221                 word = mybuffer;
222             }
223             vt->do_cmd[command](kb, mode, notifynumber, 0, word);
224             continue;
225         }
226         default:;
227         }
228 
229         // If a keyboard is inactive, it must be activated before receiving any other commands
230         if(!kb->active){
231             if(command == ACTIVE)
232                 TRY_WITH_RESET(vt->active(kb, mode, notifynumber, 0, 0));
233             continue;
234         }
235         // Specially handled commands only available when keyboard is ACTIVE
236         switch(command){
237         case IDLE:
238             TRY_WITH_RESET(vt->idle(kb, mode, notifynumber, 0, 0));
239             continue;
240         case SWITCH:
241             if(profile->currentmode != mode){
242                 profile->currentmode = mode;
243                 // Set mode light for non-RGB K95
244                 int index = INDEX_OF(mode, profile->mode);
245                 vt->setmodeindex(kb, index);
246             }
247             continue;
248         case HWLOAD: case HWSAVE:{
249             char delay = kb->usbdelay;
250             // Ensure delay of at least 10ms as the device can get overwhelmed otherwise
251             if(delay < 10)
252                 kb->usbdelay = 10;
253             // Try to load/save the hardware profile\&. Reset on failure, disconnect if reset fails\&.
254             TRY_WITH_RESET(vt->do_io[command](kb, mode, notifynumber, 1, 0));
255             // Re-send the current RGB state as it sometimes gets scrambled
256             TRY_WITH_RESET(vt->updatergb(kb, 1));
257             kb->usbdelay = delay;
258             continue;
259         }
260         case FWUPDATE:
261             // FW update parses a whole word\&. Unlike hwload/hwsave, there's no try again on failure\&.
262             if(vt->fwupdate(kb, mode, notifynumber, 0, word)){
263                 free(word);
264                 return 1;
265             }
266             continue;
267         case POLLRATE: {
268             uint rate;
269             if(sscanf(word, "%u", &rate) == 1 && (rate == 1 || rate == 2 || rate == 4 || rate == 8))
270                 TRY_WITH_RESET(vt->pollrate(kb, mode, notifynumber, rate, 0));
271             continue;
272         }
273         case ERASEPROFILE:
274             // Erase the current profile
275             vt->eraseprofile(kb, mode, notifynumber, 0, 0);
276             // Update profile/mode pointers
277             profile = kb->profile;
278             mode = profile->currentmode;
279             continue;
280         case ERASE: case NAME: case IOFF: case ION: case IAUTO: case INOTIFY: case PROFILENAME: case ID: case PROFILEID: case DPISEL: case LIFT: case SNAP:
281             // All of the above just parse the whole word
282             vt->do_cmd[command](kb, mode, notifynumber, 0, word);
283             continue;
284         case RGB: {
285             // RGB command has a special response for a single hex constant
286             int r, g, b;
287             if(sscanf(word, "%02x%02x%02x", &r, &g, &b) == 3){
288                 // Set all keys
289                 for(int i = 0; i < N_KEYS_EXTENDED; i++)
290                     vt->rgb(kb, mode, notifynumber, i, word);
291                 continue;
292             }
293             break;
294         }
295         case MACRO:
296             if(!strcmp(word, "clear")){
297                 // Macro has a special clear command
298                 vt->macro(kb, mode, notifynumber, 0, 0);
299                 continue;
300             }
301             break;
302         default:;
303         }
304         // For anything else, split the parameter at the colon
305         int left = -1;
306         sscanf(word, "%*[^:]%n", &left);
307         if(left <= 0)
308             continue;
309         const char* right = word + left;
310         if(right[0] == ':')
311             right++;
312         // Macros and DPI have a separate left-side handler
313         if(command == MACRO || command == DPI){
314             word[left] = 0;
315             vt->do_macro[command](kb, mode, notifynumber, word, right);
316             continue;
317         }
318         // Scan the left side for key names and run the requested command
319         int position = 0, field = 0;
320         char keyname[11];
321         while(position < left && sscanf(word + position, "%10[^:,]%n", keyname, &field) == 1){
322             int keycode;
323             if(!strcmp(keyname, "all")){
324                 // Set all keys
325                 for(int i = 0; i < N_KEYS_EXTENDED; i++)
326                     vt->do_cmd[command](kb, mode, notifynumber, i, right);
327             } else if((sscanf(keyname, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_EXTENDED)
328                       || (sscanf(keyname, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_EXTENDED)){
329                 // Set a key numerically
330                 vt->do_cmd[command](kb, mode, notifynumber, keycode, right);
331             } else {
332                 // Find this key in the keymap
333                 for(unsigned i = 0; i < N_KEYS_EXTENDED; i++){
334                     if(keymap[i]\&.name && !strcmp(keyname, keymap[i]\&.name)){
335                         vt->do_cmd[command](kb, mode, notifynumber, i, right);
336                         break;
337                     }
338                 }
339             }
340             if(word[position += field] == ',')
341                 position++;
342         }
343     }
344 
345     // Finish up
346     if(!NEEDS_FW_UPDATE(kb)){
347         TRY_WITH_RESET(vt->updatergb(kb, 0));
348         TRY_WITH_RESET(vt->updatedpi(kb, 0));
349     }
350     free(word);
351     return 0;
352 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
