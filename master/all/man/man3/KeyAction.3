.TH "KeyAction" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KeyAction \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/keyaction\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBType\fP { \fBUNBOUND\fP, \fBNORMAL\fP, \fBSPECIAL\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyAction\fP (const QString &action, \fBQObject\fP *parent=0)"
.br
.ti -1c
.RI "QString \fBvalue\fP () const "
.br
.ti -1c
.RI "\fBoperator QString\fP () const "
.br
.ti -1c
.RI "\fBKeyAction\fP (\fBQObject\fP *parent=0)"
.br
.ti -1c
.RI "QString \fBfriendlyName\fP (const \fBKeyMap\fP &map) const "
.br
.ti -1c
.RI "QString \fBdriverName\fP () const "
.br
.ti -1c
.RI "QString \fBmacroFullLine\fP () const "
.br
.RI "\fImacroFullLine If a macro command and a macro definition exists for the given key, returns the complete string except the leading '$' (the $ may confuse some caller)\&. \fP"
.ti -1c
.RI "bool \fBisValidMacro\fP () const "
.br
.RI "\fIisValidMacro checks whether a keyAction contains a valid macro\&. This is done easily: If the macro action starts with $macro: and has five elements, delimited by ':', we may assume, that is a structural correct macro action\&. If it has 4 entries only, it is an older definition and ok also\&. \fP"
.ti -1c
.RI "QStringList \fBmacroLine\fP () const "
.br
.RI "\fImacroLine returns all interresting content for a macro definition\&. \fP"
.ti -1c
.RI "QString \fBmacroContent\fP () const "
.br
.RI "\fImacroContent returns the macro key definition only (the second part of the macro action)\&. \fP"
.ti -1c
.RI "QString \fBmacroTiming\fP () const "
.br
.RI "\fImacroTiming returns the macro key definition with original timing infos (the fifth and up to now last part of the macro action)\&. If the implementation does not know anything about delays and has no 5th part, return first part\&. \fP"
.ti -1c
.RI "void \fBmacroDisplay\fP ()"
.br
.RI "\fIDebug output for invalid macro Definitions\&. \fP"
.ti -1c
.RI "\fBType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "bool \fBisUnbound\fP () const "
.br
.ti -1c
.RI "bool \fBisNormal\fP () const "
.br
.ti -1c
.RI "bool \fBisSpecial\fP () const "
.br
.ti -1c
.RI "bool \fBisMedia\fP () const "
.br
.ti -1c
.RI "bool \fBisProgram\fP () const "
.br
.ti -1c
.RI "bool \fBisAnim\fP () const "
.br
.ti -1c
.RI "bool \fBisMacro\fP () const "
.br
.ti -1c
.RI "bool \fBisDPI\fP () const "
.br
.ti -1c
.RI "bool \fBisMouse\fP () const "
.br
.ti -1c
.RI "QString \fBspecialInfo\fP (int &\fBparameter\fP) const "
.br
.ti -1c
.RI "int \fBprogramInfo\fP (QString &onPress, QString &onRelease) const "
.br
.ti -1c
.RI "int \fBdpiInfo\fP (QPoint &custom) const "
.br
.ti -1c
.RI "QUuid \fBanimInfo\fP (bool &onlyOnce, bool &stopOnRelease) const "
.br
.ti -1c
.RI "void \fBkeyEvent\fP (\fBKbBind\fP *bind, bool down)"
.br
.ti -1c
.RI "void \fBkeyRelease\fP (\fBKbBind\fP *bind)"
.br
.ti -1c
.RI "void \fBadjustDisplay\fP ()"
.br
.ti -1c
.RI "\fB~KeyAction\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static QString \fBnoAction\fP ()"
.br
.ti -1c
.RI "static QString \fBdefaultAction\fP (const QString &\fBkey\fP, \fBKeyMap::Model\fP model)"
.br
.ti -1c
.RI "static QString \fBmodeAction\fP (int mode)"
.br
.ti -1c
.RI "static QString \fBdpiAction\fP (int level, int customX=0, int customY=0)"
.br
.ti -1c
.RI "static QString \fBlightAction\fP (int \fBtype\fP=\fBLIGHT_UP_WRAP\fP)"
.br
.ti -1c
.RI "static QString \fBlockAction\fP (int \fBtype\fP=\fBLOCK_TOGGLE\fP)"
.br
.ti -1c
.RI "static QString \fBprogramAction\fP (const QString &onPress, const QString &onRelease, int stop)"
.br
.ti -1c
.RI "static QString \fBanimAction\fP (const QUuid &guid, bool onlyOnce, bool stopOnRelease)"
.br
.ti -1c
.RI "static QString \fBmacroAction\fP (QString macroDef)"
.br
.RI "\fIwell documented in cpp file \fP"
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBMODE_PREV\fP = -2"
.br
.ti -1c
.RI "static const int \fBMODE_NEXT\fP = -1"
.br
.ti -1c
.RI "static const int \fBMODE_PREV_WRAP\fP = -4"
.br
.ti -1c
.RI "static const int \fBMODE_NEXT_WRAP\fP = -3"
.br
.ti -1c
.RI "static const int \fBDPI_CYCLE_UP\fP = -4"
.br
.ti -1c
.RI "static const int \fBDPI_CYCLE_DOWN\fP = -3"
.br
.ti -1c
.RI "static const int \fBDPI_UP\fP = -2"
.br
.ti -1c
.RI "static const int \fBDPI_DOWN\fP = -1"
.br
.ti -1c
.RI "static const int \fBDPI_SNIPER\fP = 0"
.br
.ti -1c
.RI "static const int \fBDPI_CUSTOM\fP = 6"
.br
.ti -1c
.RI "static const int \fBLIGHT_UP\fP = 0"
.br
.ti -1c
.RI "static const int \fBLIGHT_DOWN\fP = 1"
.br
.ti -1c
.RI "static const int \fBLIGHT_UP_WRAP\fP = 2"
.br
.ti -1c
.RI "static const int \fBLIGHT_DOWN_WRAP\fP = 3"
.br
.ti -1c
.RI "static const int \fBLOCK_TOGGLE\fP = 0"
.br
.ti -1c
.RI "static const int \fBLOCK_ON\fP = 1"
.br
.ti -1c
.RI "static const int \fBLOCK_OFF\fP = 2"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_MULTI\fP = 0x04"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_INDEF\fP = 0x00"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_KRSTOP\fP = 0x01"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_KPSTOP\fP = 0x02"
.br
.ti -1c
.RI "static const int \fBPROGRAM_RE_MULTI\fP = 0x40"
.br
.ti -1c
.RI "static const int \fBPROGRAM_RE_INDEF\fP = 0x00"
.br
.ti -1c
.RI "static const int \fBPROGRAM_RE_KPSTOP\fP = 0x20"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBoperator=\fP (const \fBKeyAction\fP &rhs)"
.br
.RI "\fIccMSC: Don't copy key actions (the old one needs to be deleted first) frickler24: statement left as described, but copying is done in \fBKbBind\fP copy constructor \fP"
.ti -1c
.RI "\fBKeyAction\fP (const \fBKeyAction\fP &rhs)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QString \fB_value\fP"
.br
.ti -1c
.RI "QProcess * \fBpreProgram\fP"
.br
.ti -1c
.RI "QProcess * \fBrelProgram\fP"
.br
.ti -1c
.RI "quint64 \fBsniperValue\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 13 of file keyaction\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBKeyAction::Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNBOUND \fP\fP
.TP
\fB\fINORMAL \fP\fP
.TP
\fB\fISPECIAL \fP\fP
.PP
Definition at line 146 of file keyaction\&.h\&.
.PP
.nf
146               {
147         UNBOUND,
148         NORMAL,
149         SPECIAL,
150     };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KeyAction::KeyAction (const QString &action, \fBQObject\fP *parent = \fC0\fP)"

.PP
Definition at line 22 of file keyaction\&.cpp\&.
.PP
.nf
23     : QObject(parent), _value(action), preProgram(0), relProgram(0), sniperValue(0)
24 {
25 }
.fi
.SS "KeyAction::KeyAction (\fBQObject\fP *parent = \fC0\fP)\fC [explicit]\fP"

.PP
Definition at line 27 of file keyaction\&.cpp\&.
.PP
.nf
28     : QObject(parent), _value(""), preProgram(0), relProgram(0), sniperValue(0)
29 {
30 }
.fi
.SS "KeyAction::~KeyAction ()"

.PP
Definition at line 32 of file keyaction\&.cpp\&.
.PP
References preProgram, and relProgram\&.
.PP
.nf
32                      {
33     // Clean up processes
34     if(preProgram){
35         preProgram->kill();
36         delete preProgram;
37     }
38     if(relProgram){
39         relProgram->kill();
40         delete relProgram;
41     }
42 }
.fi
.SS "KeyAction::KeyAction (const \fBKeyAction\fP &rhs)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 187 of file keyaction\&.h\&.
.PP
.nf
187 : QObject() {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "void KeyAction::adjustDisplay ()"

.PP
Definition at line 464 of file keyaction\&.cpp\&.
.PP
Referenced by keyEvent()\&.
.PP
.nf
464                              {
465 #ifdef USE_LIBX11
466     // Try to get the current display from the X server
467     char* display_name = XDisplayName(NULL);
468     if(!display_name)
469         return;
470     Display* display = XOpenDisplay(display_name);
471     if(!display)
472         return;
473     char* display_string = DisplayString(display);
474     if(!display_string || strlen(display_string) == 0){
475         XCloseDisplay(display);
476         return;
477     }
478     size_t envstr_size = strlen(display_string) + 4;
479     char* envstr = new char[envstr_size];
480     strncpy(envstr, display_string, envstr_size);
481     envstr[envstr_size - 1] = 0;
482 
483     Window root_window = XRootWindow(display, DefaultScreen(display));
484     Window root_window_ret, child_window_ret, window;
485     XWindowAttributes attr;
486     int root_x, root_y, win_x, win_y;
487     unsigned int mask_ret;
488 
489     // Find the screen which currently has the mouse
490     XQueryPointer(display, root_window, &root_window_ret, &child_window_ret, &root_x, &root_y, &win_x, &win_y, &mask_ret);
491     if(child_window_ret == (Window)NULL)
492         window = root_window_ret;
493     else
494         window = child_window_ret;
495     XGetWindowAttributes(display, window,  &attr);
496 
497     char* ptr = strchr(envstr, ':');
498     if(ptr){
499         ptr = strchr(ptr, '\&.');
500         if(ptr)
501             *ptr = '\0';
502         char buf[16];
503         snprintf(buf, sizeof(buf), "\&.%i", XScreenNumberOfScreen(attr\&.screen));
504         strncat(envstr, buf, envstr_size - 1 - strlen(envstr));
505 
506         // Update environment variable
507         setenv("DISPLAY", envstr, 1);
508     }
509 
510     delete[] envstr;
511     XCloseDisplay(display);
512 #endif
513 }
.fi
.SS "QString KeyAction::animAction (const QUuid &guid, boolonlyOnce, boolstopOnRelease)\fC [static]\fP"

.PP
Definition at line 184 of file keyaction\&.cpp\&.
.PP
References ANIM_KRSTOP, and ANIM_ONCE\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
184                                                                                  {
185     int flags = (onlyOnce ? ANIM_ONCE : 0) | (stopOnRelease ? ANIM_KRSTOP : 0);
186     return "$anim:" + guid\&.toString() + QString("+%1")\&.arg(flags);
187 }
.fi
.SS "QUuid KeyAction::animInfo (bool &onlyOnce, bool &stopOnRelease) const"

.PP
Definition at line 225 of file keyaction\&.cpp\&.
.PP
References _value, ANIM_KRSTOP, ANIM_ONCE, and isAnim()\&.
.PP
Referenced by keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
225                                                                    {
226     if(!isAnim())
227         return QUuid();
228     QString param = _value\&.mid(6);
229     QStringList split = param\&.split("+");
230     if(split\&.length() < 2)
231         return QUuid();
232     QUuid id = split[0];
233     int flags = split[1]\&.toInt();
234     onlyOnce = !!(flags & ANIM_ONCE);
235     stopOnRelease = !!(flags & ANIM_KRSTOP);
236     return id;
237 }
.fi
.SS "QString KeyAction::defaultAction (const QString &key, \fBKeyMap::Model\fPmodel)\fC [static]\fP"

.PP
Definition at line 44 of file keyaction\&.cpp\&.
.PP
References KeyMap::GLAIVE, and KeyMap::HARPOON\&.
.PP
Referenced by KbBind::bindAction(), KbBind::defaultAction(), and KbBind::save()\&.
.PP
.nf
44                                                                      {
45     // G1-G18 are unbound by default
46     if(key\&.length() >= 2 && key[0] == 'g'
47         && ((key\&.length() == 2 && key[1] >= '0' && key[1] <= '9')
48         || (key\&.length() == 3 && key[1] == '1' && key[2] >= '0' && key[2] <= '8')))
49         return "";
50     // So are thumbgrid buttons
51     if(key\&.startsWith("thumb"))
52         return "";
53     // TODO: default action for MR
54     if(key == "mr")
55         return "";
56     // M1-M3 switch modes
57     if(key == "m1")
58         return "$mode:0";
59     if(key == "m2")
60         return "$mode:1";
61     if(key == "m3")
62         return "$mode:2";
63     // Brightness and Win Lock are their own functions
64     if(key == "light")
65         return "$light:2";
66     if(key == "lock")
67         return "$lock:0";
68     // DPI buttons
69     if(key == "dpiup"){
70         if(model == KeyMap::HARPOON ||
71        model == KeyMap::GLAIVE){
72         return "$dpi:-4";
73         }
74     return "$dpi:-2";
75     }
76     if(key == "dpidn")
77         return "$dpi:-1";
78     if(key == "sniper")
79         return "$dpi:0";
80     // Everything else is a standard keypress
81     return key;
82 }
.fi
.SS "QString KeyAction::dpiAction (intlevel, intcustomX = \fC0\fP, intcustomY = \fC0\fP)\fC [static]\fP"

.PP
Definition at line 162 of file keyaction\&.cpp\&.
.PP
References DPI_CUSTOM\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
162                                                                {
163     QString action = tr("$dpi:%1")\&.arg(level);
164     if(level == DPI_CUSTOM)
165         action += tr("+%1+%2")\&.arg(customX)\&.arg(customY);
166     return action;
167 }
.fi
.SS "int KeyAction::dpiInfo (QPoint &custom) const"

.PP
Definition at line 211 of file keyaction\&.cpp\&.
.PP
References _value, DPI_CUSTOM, and isDPI()\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
211                                            {
212     if(!isDPI())
213         return 0;
214     QString param = _value\&.mid(5);
215     QStringList lxy = param\&.split("+");
216     int level = lxy[0]\&.toInt();
217     if(level == DPI_CUSTOM){
218         if(lxy\&.length() != 3)
219             return 0;
220         custom = QPoint(lxy[1]\&.toInt(), lxy[2]\&.toInt());
221     }
222     return level;
223 }
.fi
.SS "QString KeyAction::driverName () const"

.PP
Definition at line 239 of file keyaction\&.cpp\&.
.PP
References _value, and isSpecial()\&.
.PP
Referenced by KbBind::update()\&.
.PP
.nf
239                                     {
240     if(isSpecial())
241         return "";
242     return _value;
243 }
.fi
.SS "QString KeyAction::friendlyName (const \fBKeyMap\fP &map) const"

.PP
Definition at line 84 of file keyaction\&.cpp\&.
.PP
References _value, DPI_CUSTOM, DPI_CYCLE_DOWN, DPI_CYCLE_UP, DPI_DOWN, DPI_SNIPER, DPI_UP, dpiInfo(), KeyMap::friendlyName(), KeyMap::layout(), LIGHT_DOWN, LIGHT_DOWN_WRAP, LIGHT_UP, LIGHT_UP_WRAP, LOCK_OFF, LOCK_ON, LOCK_TOGGLE, MODE_NEXT, MODE_NEXT_WRAP, MODE_PREV, and MODE_PREV_WRAP\&.
.PP
.nf
84                                                        {
85     if(_value\&.isEmpty())
86         return "Unbound";
87     QStringList parts = _value\&.split(":");
88     QString prefix = parts[0];
89     if(parts\&.length() < 2){
90         KeyMap::Layout layout = map\&.layout();
91         QString name = KeyMap::friendlyName(_value, layout);
92         if(name\&.isEmpty())
93             return "(Unknown)";
94         return name;
95     }
96     int suffix = parts[1]\&.toInt();
97     if(prefix == "$mode"){
98         switch(suffix){
99         case MODE_PREV:
100         case MODE_PREV_WRAP:
101             return "Switch to previous mode";
102         case MODE_NEXT:
103         case MODE_NEXT_WRAP:
104             return "Switch to next mode";
105         default:
106             return tr("Switch to mode %1")\&.arg(suffix + 1);
107         }
108     } else if(prefix == "$dpi"){
109         // Split off custom parameters (if any)
110         int level = parts[1]\&.split("+")[0]\&.toInt();
111         switch(level){
112         case DPI_CYCLE_UP:
113             return "DPI cycle up";
114         case DPI_CYCLE_DOWN:
115             return "DPI cycle down";
116         case DPI_UP:
117             return "DPI up";
118         case DPI_DOWN:
119             return "DPI down";
120         case DPI_SNIPER:
121             return "Sniper";
122         case DPI_CUSTOM:{
123             QPoint xy;
124             dpiInfo(xy);
125             return tr("DPI: %1, %2")\&.arg(xy\&.x())\&.arg(xy\&.y());
126         }
127         default:
128             return tr("DPI stage %1")\&.arg(level);
129         }
130     } else if(prefix == "$light"){
131         switch(suffix){
132         case LIGHT_UP:
133         case LIGHT_UP_WRAP:
134             return "Brightness up";
135         case LIGHT_DOWN:
136         case LIGHT_DOWN_WRAP:
137             return "Brightness down";
138         }
139     } else if(prefix == "$lock"){
140         switch(suffix){
141         case LOCK_TOGGLE:
142             return "Toggle Windows lock";
143         case LOCK_ON:
144             return "Windows lock on";
145         case LOCK_OFF:
146             return "Windows lock off";
147         }
148     } else if(prefix == "$anim"){
149         return "Start animation";
150     } else if(prefix == "$program"){
151         return "Launch program";
152     } else if(prefix == "$macro"){
153         return "Send G-key macro";
154     }
155     return "(Unknown)";
156 }
.fi
.SS "bool KeyAction::isAnim () const\fC [inline]\fP"

.PP
Definition at line 159 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by animInfo(), and RebindWidget::setSelection()\&.
.PP
.nf
159 { return _value\&.startsWith("$anim:"); }
.fi
.SS "bool KeyAction::isDPI () const\fC [inline]\fP"

.PP
Definition at line 162 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by dpiInfo(), isMouse(), and RebindWidget::setSelection()\&.
.PP
.nf
162 { return _value\&.startsWith("$dpi:"); }
.fi
.SS "bool KeyAction::isMacro () const\fC [inline]\fP"

.PP
Definition at line 160 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by isValidMacro(), macroDisplay(), and macroFullLine()\&.
.PP
.nf
160 { return _value\&.startsWith("$macro:"); }
.fi
.SS "bool KeyAction::isMedia () const\fC [inline]\fP"

.PP
Definition at line 156 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
.nf
156 { return _value == "mute" || _value == "volup" || _value == "voldn" || _value == "stop" || _value == "prev" || _value == "play" || _value == "next"; }
.fi
.SS "bool KeyAction::isMouse () const\fC [inline]\fP"

.PP
Definition at line 163 of file keyaction\&.h\&.
.PP
References _value, isDPI(), and isNormal()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
163 { return (isNormal() && (_value\&.startsWith("mouse") || _value\&.startsWith("wheel"))) || isDPI(); }
.fi
.SS "bool KeyAction::isNormal () const\fC [inline]\fP"

.PP
Definition at line 153 of file keyaction\&.h\&.
.PP
References NORMAL, and type()\&.
.PP
Referenced by isMouse(), and RebindWidget::setSelection()\&.
.PP
.nf
153 { return type() == NORMAL; }
.fi
.SS "bool KeyAction::isProgram () const\fC [inline]\fP"

.PP
Definition at line 158 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by programInfo(), and RebindWidget::setSelection()\&.
.PP
.nf
158 { return _value\&.startsWith("$program:"); }
.fi
.SS "bool KeyAction::isSpecial () const\fC [inline]\fP"

.PP
Definition at line 154 of file keyaction\&.h\&.
.PP
References SPECIAL, and type()\&.
.PP
Referenced by driverName(), keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
154 { return type() == SPECIAL; }
.fi
.SS "bool KeyAction::isUnbound () const\fC [inline]\fP"

.PP
Definition at line 152 of file keyaction\&.h\&.
.PP
References type(), and UNBOUND\&.
.PP
.nf
152 { return type() == UNBOUND; }
.fi
.SS "bool KeyAction::isValidMacro () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
bool as true iff the macro definition contains all four elements\&. 
.RE
.PP

.PP
Definition at line 55 of file keyaction\&.h\&.
.PP
References _value, and isMacro()\&.
.PP
Referenced by macroContent(), macroDisplay(), macroLine(), macroTiming(), RebindWidget::setSelection(), and KbBind::update()\&.
.PP
.nf
55                                       {
56         if (isMacro()) {
57             QStringList ret;
58             ret =_value\&.split(":");
59             return ((ret\&.count() >= 4) && (ret\&.count() <= 5));
60         } else {
61             return false;
62         }
63     }
.fi
.SS "void KeyAction::keyEvent (\fBKbBind\fP *bind, booldown)"

.PP
Definition at line 245 of file keyaction\&.cpp\&.
.PP
References _value, adjustDisplay(), anim, animInfo(), KbPerf::baseDpiIdx(), KbProfile::currentMode(), Kb::currentProfile(), KbBind::devParent(), KbLight::dimming(), KbPerf::DPI_COUNT, DPI_CUSTOM, DPI_CYCLE_DOWN, DPI_CYCLE_UP, DPI_DOWN, DPI_SNIPER, DPI_UP, KbPerf::dpiCycleDown(), KbPerf::dpiCycleUp(), KbPerf::dpiDown(), dpiInfo(), KbPerf::dpiUp(), KbLight::findAnim(), KbProfile::indexOf(), KbAnim::isActive(), isSpecial(), KbBind::light(), LIGHT_DOWN, LIGHT_DOWN_WRAP, LIGHT_UP, LIGHT_UP_WRAP, LOCK_OFF, LOCK_ON, LOCK_TOGGLE, KbLight::MAX_DIM, MODE_NEXT, MODE_NEXT_WRAP, MODE_PREV, MODE_PREV_WRAP, KbProfile::modeCount(), KbProfile::modes(), KbBind::perf(), KbPerf::popDpi(), preProgram, PROGRAM_PR_KPSTOP, PROGRAM_PR_KRSTOP, PROGRAM_PR_MULTI, PROGRAM_RE_KPSTOP, PROGRAM_RE_MULTI, programInfo(), KbPerf::pushDpi(), KbPerf::pushSniper(), relProgram, Kb::setCurrentMode(), sniperValue, KbAnim::stop(), KbAnim::trigger(), and KbBind::winLock()\&.
.PP
Referenced by KbBind::keyEvent()\&.
.PP
.nf
245                                                {
246     // No need to respond to standard actions
247     if(!isSpecial())
248         return;
249     QStringList parts = _value\&.split(":");
250     if(parts\&.length() < 2)
251         return;
252     QString prefix = parts[0];
253     int suffix = parts[1]\&.toInt();
254     if(prefix == "$mode"){
255         if(!down)
256             return;
257         // Change mode
258         Kb* device = bind->devParent();
259         KbProfile* currentProfile = device->currentProfile();
260         int mode = currentProfile->indexOf(currentProfile->currentMode());
261         int modeCount = currentProfile->modeCount();
262         switch(suffix){
263         case MODE_PREV_WRAP:
264             mode--;
265             if(mode < 0)
266                 mode = modeCount - 1;
267             break;
268         case MODE_NEXT_WRAP:
269             mode++;
270             if(mode >= modeCount)
271                 mode = 0;
272             break;
273         case MODE_PREV:
274             mode--;
275             break;
276         case MODE_NEXT:
277             mode++;
278             break;
279         default:
280             // Absolute
281             mode = suffix;
282             break;
283         }
284         if(mode < 0 || mode >= modeCount)
285             return;
286         device->setCurrentMode(currentProfile->modes()[mode]);
287     } else if(prefix == "$dpi"){
288         KbPerf* perf = bind->perf();
289         int level = parts[1]\&.split("+")[0]\&.toInt();
290         switch(level){
291         case DPI_CYCLE_UP:
292             if(!down)
293                 return;
294             perf->dpiCycleUp();
295             break;
296         case DPI_CYCLE_DOWN:
297             if(!down)
298                 return;
299             perf->dpiCycleDown();
300             break;
301         case DPI_UP:
302             if(!down)
303                 return;
304             perf->dpiUp();
305             break;
306         case DPI_DOWN:
307             if(!down)
308                 return;
309             perf->dpiDown();
310             break;
311         case DPI_SNIPER:
312             if(down)
313                 sniperValue = perf->pushSniper();
314             else {
315                 perf->popDpi(sniperValue);
316                 sniperValue = 0;
317             }
318             break;
319         case DPI_CUSTOM:{
320             QPoint xy;
321             dpiInfo(xy);
322             if(xy\&.x() <= 0 || xy\&.y() <= 0)
323                 break;
324             if(down)
325                 sniperValue = perf->pushDpi(xy);
326             else {
327                 perf->popDpi(sniperValue);
328                 sniperValue = 0;
329             }
330             break;
331         }
332         default:
333             if(level < 1 || level >= KbPerf::DPI_COUNT
334                     || !down)
335                 return;
336             perf->baseDpiIdx(level);
337             break;
338         }
339     } else if(prefix == "$light"){
340         if(!down)
341             return;
342         // Change brightness
343         KbLight* light = bind->light();
344         int dim = light->dimming();
345         switch(suffix){
346         case LIGHT_UP:
347             if(dim > 0)
348                 dim--;
349             break;
350         case LIGHT_DOWN:
351             if(dim < KbLight::MAX_DIM)
352                 dim++;
353             break;
354         case LIGHT_UP_WRAP:
355             dim--;
356             if(dim < 0)
357                 dim = KbLight::MAX_DIM;
358             break;
359         case LIGHT_DOWN_WRAP:
360             dim++;
361             if(dim > KbLight::MAX_DIM)
362                 dim = 0;
363             break;
364         }
365         light->dimming(dim);
366     } else if(prefix == "$lock"){
367         if(!down)
368             return;
369         // Change win lock
370         switch(suffix){
371         case LOCK_TOGGLE:
372             bind->winLock(!bind->winLock());
373             break;
374         case LOCK_ON:
375             bind->winLock(true);
376             break;
377         case LOCK_OFF:
378             bind->winLock(false);
379             break;
380         }
381     } else if(prefix == "$anim"){
382         // Start animation
383         bool onlyOnce = false, stopOnRelease = false;
384         QUuid id = animInfo(onlyOnce, stopOnRelease);
385         KbAnim* anim = bind->light()->findAnim(id);
386         if(!anim)
387             return;
388         if(down){
389             if(!onlyOnce || !anim->isActive())
390                 // If "only once" is enabled, don't start the animation when it's already running
391                 anim->trigger(QDateTime::currentMSecsSinceEpoch(), true);
392         } else if(stopOnRelease){
393             // Key released - stop animation
394             anim->stop();
395         }
396     } else if(prefix == "$program"){
397         // Launch program
398         QString onPress, onRelease;
399         int stop = programInfo(onPress, onRelease);
400         // Stop running programs based on setting
401         QProcess* process = 0;
402         if(down){
403             if(stop & PROGRAM_PR_KPSTOP){
404                 process = preProgram;
405                 if(process)
406                     process->kill();
407                 process = 0;
408             }
409             if(stop & PROGRAM_RE_KPSTOP)
410                 process = relProgram;
411         } else {
412             if(stop & PROGRAM_PR_KRSTOP)
413                 process = preProgram;
414         }
415         if(process)
416             process->kill();
417         // Launch new process if requested
418         QString& program = down ? onPress : onRelease;
419         if(program\&.isEmpty())
420             return;
421         // Check if the program is running already\&. If so, don't start it again\&.
422         process = down ? preProgram : relProgram;
423         if(process){
424             if(process->state() == QProcess::NotRunning)
425                 delete process;
426             else
427                 return;
428         }
429 
430         // Adjust the selected display\&.
431         adjustDisplay();
432 
433         // Start the program\&. Wrap it around sh to parse arguments\&.
434         if((down && (stop & PROGRAM_PR_MULTI))
435                 || (!down && (stop & PROGRAM_RE_MULTI))){
436             // Multiple instances allowed? Start detached process
437             QProcess::startDetached("sh", QStringList() << "-c" << program);
438         } else {
439             process = new QProcess(this);
440             process->start("sh", QStringList() << "-c" << program);
441             if(down)
442                 preProgram = process;
443             else
444                 relProgram = process;
445         }
446     } else if (prefix == "$macro") {
447         // Do nothing, because all work is done by the keyboard itself\&.
448         // For now, there is no reason to react on G-key press or release\&.
449         // If u find some reason, then here is the place for it\&.
450     }
451 }
.fi
.SS "void KeyAction::keyRelease (\fBKbBind\fP *bind)"

.SS "QString KeyAction::lightAction (inttype = \fC\fBLIGHT_UP_WRAP\fP\fP)\fC [static]\fP"

.PP
Definition at line 169 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
169                                       {
170     return QString("$light:%1")\&.arg(type);
171 }
.fi
.SS "QString KeyAction::lockAction (inttype = \fC\fBLOCK_TOGGLE\fP\fP)\fC [static]\fP"

.PP
Definition at line 173 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
173                                      {
174     return QString("$lock:%1")\&.arg(type);
175 }
.fi
.SS "QString KeyAction::macroAction (QStringmacroDef)\fC [static]\fP"
\fBKeyAction::macroAction\fP is called when applying changes on a macro definition\&. macroAction ist called while being in the macro pane and clicking Apply with something in the Macro Text Box\&. It tags that input with '$macro:' for further recognition\&.
.PP
\fBParameters:\fP
.RS 4
\fImacroDef\fP holds the String containing parts 2-5 of a complete macro definition\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
QString holding the complete G-Key macro definition (parts 1-5) 
.RE
.PP

.PP
Definition at line 523 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
523                                                {
524     return QString ("$macro:%1")\&.arg(macroDef);
525 }
.fi
.SS "QString KeyAction::macroContent () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QString macroContent 
.RE
.PP

.PP
Definition at line 86 of file keyaction\&.h\&.
.PP
References _value, and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection(), and KbBind::update()\&.
.PP
.nf
86                                         {
87         // return isValidMacro() ? _value\&.split(":")[1]\&.replace(QRegExp("=\\d+"), "") : ""; ///< Is used if we have ckb without delay handling
88         return isValidMacro() ? _value\&.split(":")[1] : "";
89     }
.fi
.SS "void KeyAction::macroDisplay ()"
\fBKeyAction::macroDisplay\fP is just for debugging\&. It shows the content of the key action and some other info\&.
.PP
General Info on \fBKeyAction::_value\fP for macros: That string consists of 4 elements, all delimited by ':'\&.
.IP "1." 4
Macro command indicator '$macro:'
.IP "2." 4
Macro \fBKey\fP Definition (coming from pteMacroBox): This sequence will program the keyboard and is hardly readable
.IP "3." 4
Readable Macro String: This is displayed in pteMacroText
.IP "4." 4
Readable Macro Comment:This is displayed in pteMacroComment
.IP "5." 4
completely unreadable original macro information with timing values 
.PP

.PP
Definition at line 456 of file keyaction\&.cpp\&.
.PP
References _value, isMacro(), and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
456                              {
457     qDebug() << "isMacro returns" << (isMacro() ? "true" : "false");
458     qDebug() << "isValidMacro returns" << (isValidMacro() ? "true" : "false");
459     QStringList ret =_value\&.split(":");
460     qDebug() << "Macro definition conains" << ret\&.count() << "elements";
461     qDebug() << "Macro definition is" << _value;
462 }
.fi
.SS "QString KeyAction::macroFullLine () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QString All 5 parts are returned in one QString\&. If no definition exists, return '' 
.RE
.PP

.PP
Definition at line 43 of file keyaction\&.h\&.
.PP
References _value, and isMacro()\&.
.PP
.nf
43                                          {
44         return isMacro() ? _value\&.right(_value\&.length()-1) : "";
45     }
.fi
.SS "QStringList KeyAction::macroLine () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QStringList returns the Macro \fBKey\fP Definition, Readble Macro String, Readable Macro Comment and the original timing information (if it exists as a 5th part) as QStringList\&. 
.RE
.PP

.PP
Definition at line 73 of file keyaction\&.h\&.
.PP
References _value, and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
73                                          {
74         if (isValidMacro()) {
75             QStringList ret =_value\&.split(":");
76             ret\&.removeFirst();
77             return ret;
78         } else return QStringList();
79     }
.fi
.SS "QString KeyAction::macroTiming () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QString macroTiming 
.RE
.PP

.PP
Definition at line 98 of file keyaction\&.h\&.
.PP
References _value, and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
98                                        {
99         if (isValidMacro()) {
100             QStringList rval = _value\&.split(":");
101             return (rval\&.length() == 4)? rval[1] : rval[4];
102         }
103         return QString("");
104     }
.fi
.SS "QString KeyAction::modeAction (intmode)\fC [static]\fP"

.PP
Definition at line 158 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
158                                      {
159     return QString("$mode:%1")\&.arg(mode);
160 }
.fi
.SS "static QString KeyAction::noAction ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 25 of file keyaction\&.h\&.
.PP
.nf
25 { return ""; }
.fi
.SS "KeyAction::operator QString () const\fC [inline]\fP"

.PP
Definition at line 20 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
.nf
20 { return _value; }
.fi
.SS "void KeyAction::operator= (const \fBKeyAction\fP &rhs)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 186 of file keyaction\&.h\&.
.PP
.nf
186 {}
.fi
.SS "QString KeyAction::programAction (const QString &onPress, const QString &onRelease, intstop)\fC [static]\fP"

.PP
Definition at line 177 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
177                                                                                           {
178     // URL-encode the commands and place them in the string (":" and "+" are both replaced, so they won't interfere)
179     return "$program:" + QString::fromUtf8(QUrl::toPercentEncoding(onPress\&.trimmed())) + "+" + QString::fromUtf8(QUrl::toPercentEncoding(onRelease\&.trimmed())) + QString("+%1")\&.arg(stop);
180 }
.fi
.SS "int KeyAction::programInfo (QString &onPress, QString &onRelease) const"

.PP
Definition at line 199 of file keyaction\&.cpp\&.
.PP
References _value, and isProgram()\&.
.PP
Referenced by keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
199                                                                      {
200     if(!isProgram())
201         return 0;
202     QString param = _value\&.mid(9);
203     QStringList programs = param\&.split("+");
204     if(programs\&.length() != 3)
205         return 0;
206     onPress = QUrl::fromPercentEncoding(programs[0]\&.toUtf8());
207     onRelease = QUrl::fromPercentEncoding(programs[1]\&.toUtf8());
208     return programs[2]\&.toInt();
209 }
.fi
.SS "QString KeyAction::specialInfo (int &parameter) const"

.PP
Definition at line 189 of file keyaction\&.cpp\&.
.PP
References _value\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
189                                                    {
190     QStringList list = _value\&.split(":");
191     if(list\&.length() < 2){
192         parameter = INT_MIN;
193         return "";
194     }
195     parameter = list[1]\&.toInt();
196     return list[0]\&.replace("$", "");
197 }
.fi
.SS "\fBKeyAction::Type\fP KeyAction::type () const"

.PP
Definition at line 14 of file keyaction\&.cpp\&.
.PP
References _value, NORMAL, SPECIAL, and UNBOUND\&.
.PP
Referenced by isNormal(), isSpecial(), isUnbound(), KbBindWidget::on_copyButton_clicked(), and KbBindWidget::on_resetButton_clicked()\&.
.PP
.nf
14                                     {
15     if(_value\&.isEmpty())
16         return UNBOUND;
17     if(_value\&.at(0) == '$')
18         return SPECIAL;
19     return NORMAL;
20 }
.fi
.SS "QString KeyAction::value () const\fC [inline]\fP"

.PP
Definition at line 19 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by KbBind::action(), KbBind::KbBind(), KbBind::save(), and KbBind::update()\&.
.PP
.nf
19 { return _value; }
.fi
.SH "Field Documentation"
.PP 
.SS "QString KeyAction::_value\fC [private]\fP"

.PP
Definition at line 189 of file keyaction\&.h\&.
.PP
Referenced by animInfo(), dpiInfo(), driverName(), friendlyName(), isAnim(), isDPI(), isMacro(), isMedia(), isMouse(), isProgram(), isValidMacro(), keyEvent(), macroContent(), macroDisplay(), macroFullLine(), macroLine(), macroTiming(), operator QString(), programInfo(), specialInfo(), type(), and value()\&.
.SS "const int KeyAction::DPI_CUSTOM = 6\fC [static]\fP"

.PP
Definition at line 128 of file keyaction\&.h\&.
.PP
Referenced by dpiAction(), dpiInfo(), friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::DPI_CYCLE_DOWN = -3\fC [static]\fP"

.PP
Definition at line 126 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::DPI_CYCLE_UP = -4\fC [static]\fP"

.PP
Definition at line 126 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::DPI_DOWN = -1\fC [static]\fP"

.PP
Definition at line 127 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::DPI_SNIPER = 0\fC [static]\fP"

.PP
Definition at line 128 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::DPI_UP = -2\fC [static]\fP"

.PP
Definition at line 127 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::LIGHT_DOWN = 1\fC [static]\fP"

.PP
Definition at line 131 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LIGHT_DOWN_WRAP = 3\fC [static]\fP"

.PP
Definition at line 132 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LIGHT_UP = 0\fC [static]\fP"

.PP
Definition at line 131 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LIGHT_UP_WRAP = 2\fC [static]\fP"

.PP
Definition at line 132 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LOCK_OFF = 2\fC [static]\fP"

.PP
Definition at line 135 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::LOCK_ON = 1\fC [static]\fP"

.PP
Definition at line 135 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::LOCK_TOGGLE = 0\fC [static]\fP"

.PP
Definition at line 135 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::MODE_NEXT = -1\fC [static]\fP"

.PP
Definition at line 122 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::MODE_NEXT_WRAP = -3\fC [static]\fP"

.PP
Definition at line 123 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::MODE_PREV = -2\fC [static]\fP"

.PP
Definition at line 122 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::MODE_PREV_WRAP = -4\fC [static]\fP"

.PP
Definition at line 123 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "QProcess* KeyAction::preProgram\fC [private]\fP"

.PP
Definition at line 192 of file keyaction\&.h\&.
.PP
Referenced by keyEvent(), and ~KeyAction()\&.
.SS "const int KeyAction::PROGRAM_PR_INDEF = 0x00\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.SS "const int KeyAction::PROGRAM_PR_KPSTOP = 0x02\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.PP
Referenced by keyEvent()\&.
.SS "const int KeyAction::PROGRAM_PR_KRSTOP = 0x01\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.PP
Referenced by keyEvent()\&.
.SS "const int KeyAction::PROGRAM_PR_MULTI = 0x04\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::PROGRAM_RE_INDEF = 0x00\fC [static]\fP"

.PP
Definition at line 139 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::PROGRAM_RE_KPSTOP = 0x20\fC [static]\fP"

.PP
Definition at line 139 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::PROGRAM_RE_MULTI = 0x40\fC [static]\fP"

.PP
Definition at line 139 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "QProcess* KeyAction::relProgram\fC [private]\fP"

.PP
Definition at line 193 of file keyaction\&.h\&.
.PP
Referenced by keyEvent(), and ~KeyAction()\&.
.SS "quint64 KeyAction::sniperValue\fC [private]\fP"

.PP
Definition at line 196 of file keyaction\&.h\&.
.PP
Referenced by keyEvent()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
