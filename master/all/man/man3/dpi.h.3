.TH "src/ckb-daemon/dpi.h" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/dpi.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br
\fC#include 'device\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBupdatedpi\fP (\fBusbdevice\fP *kb, int force)"
.br
.ti -1c
.RI "int \fBsavedpi\fP (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"
.br
.ti -1c
.RI "int \fBloaddpi\fP (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"
.br
.ti -1c
.RI "char * \fBprintdpi\fP (const \fBdpiset\fP *dpi, const \fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBcmd_dpi\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, const char *stages, const char *values)"
.br
.ti -1c
.RI "void \fBcmd_dpisel\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *stage)"
.br
.ti -1c
.RI "void \fBcmd_lift\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *height)"
.br
.ti -1c
.RI "void \fBcmd_snap\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *enable)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void cmd_dpi (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, const char *stages, const char *values)"

.PP
Definition at line 4 of file dpi\&.c\&.
.PP
References usbmode::dpi, DPI_COUNT, dpiset::enabled, left, dpiset::x, x, dpiset::y, and y\&.
.PP
.nf
4                                                                                              {
5     (void)kb;
6     (void)dummy;
7 
8     int disable = 0;
9     ushort x, y;
10     // Try to scan X,Y values
11     if(sscanf(values, "%hu,%hu", &x, &y) != 2){
12         // If that doesn't work, scan single number
13         if(sscanf(values, "%hu", &x) == 1)
14             y = x;
15         else if(!strncmp(values, "off", 3))
16             // If the right side says "off", disable the level(s)
17             disable = 1;
18         else
19             // Otherwise, quit
20             return;
21     }
22     if((x == 0 || y == 0) && !disable)
23         return;
24     // Scan the left side for stage numbers (comma-separated)
25     int left = strlen(stages);
26     int position = 0, field = 0;
27     char stagename[3];
28     while(position < left && sscanf(stages + position, "%2[^,]%n", stagename, &field) == 1){
29         uchar stagenum;
30         if(sscanf(stagename, "%hhu", &stagenum) && stagenum < DPI_COUNT){
31             // Set DPI for this stage
32             if(disable){
33                 mode->dpi\&.enabled &= ~(1 << stagenum);
34                 mode->dpi\&.x[stagenum] = 0;
35                 mode->dpi\&.y[stagenum] = 0;
36             } else {
37                 mode->dpi\&.enabled |= 1 << stagenum;
38                 mode->dpi\&.x[stagenum] = x;
39                 mode->dpi\&.y[stagenum] = y;
40             }
41         }
42         if(stages[position += field] == ',')
43             position++;
44     }
45 }
.fi
.SS "void cmd_dpisel (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *stage)"

.PP
Definition at line 47 of file dpi\&.c\&.
.PP
References dpiset::current, usbmode::dpi, and DPI_COUNT\&.
.PP
.nf
47                                                                                         {
48     (void)kb;
49     (void)dummy1;
50     (void)dummy2;
51 
52     uchar stagenum;
53     if(sscanf(stage, "%hhu", &stagenum) != 1)
54         return;
55     if(stagenum > DPI_COUNT)
56         return;
57     mode->dpi\&.current = stagenum;
58 }
.fi
.SS "void cmd_lift (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *height)"

.PP
Definition at line 60 of file dpi\&.c\&.
.PP
References usbmode::dpi, dpiset::lift, LIFT_MAX, and LIFT_MIN\&.
.PP
.nf
60                                                                                        {
61     (void)kb;
62     (void)dummy1;
63     (void)dummy2;
64 
65     uchar heightnum;
66     if(sscanf(height, "%hhu", &heightnum) != 1)
67         return;
68     if(heightnum > LIFT_MAX || heightnum < LIFT_MIN)
69         return;
70     mode->dpi\&.lift = heightnum;
71 }
.fi
.SS "void cmd_snap (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *enable)"

.PP
Definition at line 73 of file dpi\&.c\&.
.PP
References usbmode::dpi, and dpiset::snap\&.
.PP
.nf
73                                                                                        {
74     (void)kb;
75     (void)dummy1;
76     (void)dummy2;
77 
78     if(!strcmp(enable, "on"))
79         mode->dpi\&.snap = 1;
80     if(!strcmp(enable, "off"))
81         mode->dpi\&.snap = 0;
82 }
.fi
.SS "int loaddpi (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"

.PP
Definition at line 222 of file dpi\&.c\&.
.PP
References lighting::b, ckb_err, dpiset::current, DPI_COUNT, dpiset::enabled, lighting::g, LED_MOUSE, dpiset::lift, LIFT_MAX, LIFT_MIN, MSG_SIZE, N_MOUSE_ZONES, lighting::r, dpiset::snap, usbrecv, dpiset::x, and dpiset::y\&.
.PP
Referenced by cmd_hwload_mouse()\&.
.PP
.nf
222                                                         {
223     // Ask for settings
224     uchar data_pkt[4][MSG_SIZE] = {
225         { 0x0e, 0x13, 0x05, 1, },
226         { 0x0e, 0x13, 0x02, 1, },
227         { 0x0e, 0x13, 0x03, 1, },
228         { 0x0e, 0x13, 0x04, 1, }
229     };
230     uchar in_pkt[4][MSG_SIZE];
231     for(int i = 0; i < 4; i++){
232         if(!usbrecv(kb, data_pkt[i], in_pkt[i]))
233             return -2;
234         if(memcmp(in_pkt[i], data_pkt[i], 4)){
235             ckb_err("Bad input header\n");
236             return -3;
237         }
238     }
239     // Copy data from device
240     dpi->enabled = in_pkt[0][4];
241     dpi->enabled &= (1 << DPI_COUNT) - 1;
242     dpi->current = in_pkt[1][4];
243     if(dpi->current >= DPI_COUNT)
244         dpi->current = 0;
245     dpi->lift = in_pkt[2][4];
246     if(dpi->lift < LIFT_MIN || dpi->lift > LIFT_MAX)
247         dpi->lift = LIFT_MIN;
248     dpi->snap = !!in_pkt[3][4];
249 
250     // Get X/Y DPIs
251     for(int i = 0; i < DPI_COUNT; i++){
252         uchar data_pkt[MSG_SIZE] = { 0x0e, 0x13, 0xd0, 1 };
253         uchar in_pkt[MSG_SIZE];
254         data_pkt[2] |= i;
255         if(!usbrecv(kb, data_pkt, in_pkt))
256             return -2;
257         if(memcmp(in_pkt, data_pkt, 4)){
258             ckb_err("Bad input header\n");
259             return -3;
260         }
261         // Copy to profile
262         dpi->x[i] = *(ushort*)(in_pkt + 5);
263         dpi->y[i] = *(ushort*)(in_pkt + 7);
264         light->r[LED_MOUSE + N_MOUSE_ZONES + i] = in_pkt[9];
265         light->g[LED_MOUSE + N_MOUSE_ZONES + i] = in_pkt[10];
266         light->b[LED_MOUSE + N_MOUSE_ZONES + i] = in_pkt[11];
267     }
268     // Finished\&. Set SW DPI light to the current hardware level
269     light->r[LED_MOUSE + 2] = light->r[LED_MOUSE + N_MOUSE_ZONES + dpi->current];
270     light->g[LED_MOUSE + 2] = light->g[LED_MOUSE + N_MOUSE_ZONES + dpi->current];
271     light->b[LED_MOUSE + 2] = light->b[LED_MOUSE + N_MOUSE_ZONES + dpi->current];
272     return 0;
273 }
.fi
.SS "char* printdpi (const \fBdpiset\fP *dpi, const \fBusbdevice\fP *kb)"

.PP
Definition at line 84 of file dpi\&.c\&.
.PP
References _readlines_ctx::buffer, DPI_COUNT, dpiset::enabled, dpiset::x, and dpiset::y\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
84                                                       {
85     (void)kb;
86 
87     // Print all DPI settings
88     const int BUFFER_LEN = 100;
89     char* buffer = malloc(BUFFER_LEN);
90     int length = 0;
91     for(int i = 0; i < DPI_COUNT; i++){
92         // Print the stage number
93         int newlen = 0;
94         snprintf(buffer + length, BUFFER_LEN - length, length == 0 ? "%d%n" : " %d%n", i, &newlen);
95         length += newlen;
96         // Print the DPI settings
97         if(!(dpi->enabled & (1 << i)))
98             snprintf(buffer + length, BUFFER_LEN - length, ":off%n", &newlen);
99         else
100             snprintf(buffer + length, BUFFER_LEN - length, ":%u,%u%n", dpi->x[i], dpi->y[i], &newlen);
101         length += newlen;
102     }
103     return buffer;
104 }
.fi
.SS "int savedpi (\fBusbdevice\fP *kb, \fBdpiset\fP *dpi, \fBlighting\fP *light)"

.PP
Definition at line 194 of file dpi\&.c\&.
.PP
References lighting::b, dpiset::current, DPI_COUNT, dpiset::enabled, lighting::g, LED_MOUSE, dpiset::lift, MSG_SIZE, N_MOUSE_ZONES, lighting::r, dpiset::snap, usbsend, dpiset::x, and dpiset::y\&.
.PP
Referenced by cmd_hwsave_mouse()\&.
.PP
.nf
194                                                         {
195     // Send X/Y DPIs
196     for(int i = 0; i < DPI_COUNT; i++){
197         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0xd0, 1 };
198         data_pkt[2] |= i;
199         *(ushort*)(data_pkt + 5) = dpi->x[i];
200         *(ushort*)(data_pkt + 7) = dpi->y[i];
201         // Save the RGB value for this setting too
202         data_pkt[9] = light->r[LED_MOUSE + N_MOUSE_ZONES + i];
203         data_pkt[10] = light->g[LED_MOUSE + N_MOUSE_ZONES + i];
204         data_pkt[11] = light->b[LED_MOUSE + N_MOUSE_ZONES + i];
205         if(!usbsend(kb, data_pkt, 1))
206             return -1;
207     }
208 
209     // Send settings
210     uchar data_pkt[4][MSG_SIZE] = {
211         { 0x07, 0x13, 0x05, 1, dpi->enabled },
212         { 0x07, 0x13, 0x02, 1, dpi->current },
213         { 0x07, 0x13, 0x03, 1, dpi->lift },
214         { 0x07, 0x13, 0x04, 1, dpi->snap, 0x05 }
215     };
216     if(!usbsend(kb, data_pkt[0], 4))
217         return -2;
218     // Finished
219     return 0;
220 }
.fi
.SS "int updatedpi (\fBusbdevice\fP *kb, intforce)"

.PP
Definition at line 106 of file dpi\&.c\&.
.PP
References usbdevice::active, dpiset::current, usbprofile::currentmode, usbmode::dpi, DPI_COUNT, dpiset::enabled, dpiset::forceupdate, usbprofile::lastdpi, dpiset::lift, MSG_SIZE, usbdevice::profile, dpiset::snap, usbsend, dpiset::x, and dpiset::y\&.
.PP
.nf
106                                        {
107     if(!kb->active)
108         return 0;
109     dpiset* lastdpi = &kb->profile->lastdpi;
110     dpiset* newdpi = &kb->profile->currentmode->dpi;
111     // Don't do anything if the settings haven't changed
112     if(!force && !lastdpi->forceupdate && !newdpi->forceupdate
113             && !memcmp(lastdpi, newdpi, sizeof(dpiset)))
114         return 0;
115     lastdpi->forceupdate = newdpi->forceupdate = 0;
116 
117     if (newdpi->current != lastdpi->current) {
118         // Before we switch the current DPI stage, make sure the stage we are
119         // switching to is both enabled and configured to the correct DPI\&.
120 
121         // Enable the stage if necessary\&.
122         if ((lastdpi->enabled & 1 << newdpi->current) == 0) {
123             uchar newenabled;
124             // If the new enabled flags contain both the current and previous
125             // stages, use it\&.
126             if (newdpi->enabled & 1 << newdpi->current &&
127                 newdpi->enabled & 1 << lastdpi->current) {
128                 newenabled = newdpi->enabled;
129             } else {
130                 // Otherwise just enable the new stage\&. We'll write the actual
131                 // requested flags after switching stages\&.
132                 newenabled = lastdpi->enabled | 1 << newdpi->current;
133             }
134             uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x05, 0, newenabled };
135             if(!usbsend(kb, data_pkt, 1))
136                 return -2;
137             // Cache the flags we wrote\&.
138             lastdpi->enabled = newenabled;
139         }
140         // Set the DPI for the new stage if necessary\&.
141         if (newdpi->x[newdpi->current] != lastdpi->x[newdpi->current] ||
142             newdpi->y[newdpi->current] != lastdpi->y[newdpi->current]) {
143             uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0xd0, 0 };
144             data_pkt[2] |= newdpi->current;
145             *(ushort*)(data_pkt + 5) = newdpi->x[newdpi->current];
146             *(ushort*)(data_pkt + 7) = newdpi->y[newdpi->current];
147             if(!usbsend(kb, data_pkt, 1))
148                 return -1;
149             // Set these values in the cache so we don't rewrite them\&.
150             lastdpi->x[newdpi->current] = newdpi->x[newdpi->current];
151             lastdpi->y[newdpi->current] = newdpi->y[newdpi->current];
152         }
153         // Set current DPI stage\&.
154         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x02, 0, newdpi->current };
155         if(!usbsend(kb, data_pkt, 1))
156             return -2;
157     }
158     
159     // Send X/Y DPIs\&. We've changed to the new stage already so these can be set
160     // safely\&.
161     for(int i = 0; i < DPI_COUNT; i++){
162         if (newdpi->x[i] == lastdpi->x[i] && newdpi->y[i] == lastdpi->y[i])
163             continue;
164         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0xd0, 0 };
165         data_pkt[2] |= i;
166         *(ushort*)(data_pkt + 5) = newdpi->x[i];
167         *(ushort*)(data_pkt + 7) = newdpi->y[i];
168         if(!usbsend(kb, data_pkt, 1))
169             return -1;
170     }
171 
172     // Send settings
173     if (newdpi->enabled != lastdpi->enabled) {
174         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x05, 0, newdpi->enabled };
175         if(!usbsend(kb, data_pkt, 1))
176             return -2;
177     }
178     if (newdpi->lift != lastdpi->lift) {
179         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x03, 0, newdpi->lift };
180         if(!usbsend(kb, data_pkt, 1))
181             return -2;
182     }
183     if (newdpi->snap != lastdpi->snap) {
184         uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x04, 0, newdpi->snap, 0x05 };
185         if(!usbsend(kb, data_pkt, 1))
186             return -2;
187     }
188 
189     // Finished
190     memcpy(lastdpi, newdpi, sizeof(dpiset));
191     return 0;
192 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
