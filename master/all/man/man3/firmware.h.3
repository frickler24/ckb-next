.TH "src/ckb-daemon/firmware.h" 3 "Thu Nov 2 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/firmware.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBgetfwversion\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBcmd_fwupdate\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int nnumber, int dummy2, const char *path)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int cmd_fwupdate (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intnnumber, intdummy2, const char *path)"

.PP
Definition at line 154 of file firmware\&.c\&.
.PP
References FEAT_FWUPDATE, FW_NOFILE, FW_OK, FW_USBFAIL, FW_WRONGDEV, fwupdate(), HAS_FEATURES, nprintf(), and usb_tryreset()\&.
.PP
.nf
154                                                                                            {
155     (void)dummy1;
156     (void)dummy2;
157 
158     if(!HAS_FEATURES(kb, FEAT_FWUPDATE))
159         return 0;
160     // Update the firmware
161     int ret = fwupdate(kb, path, nnumber);
162     while(ret == FW_USBFAIL){
163         // Try to reset the device if it fails
164         if(usb_tryreset(kb))
165             break;
166         ret = fwupdate(kb, path, nnumber);
167     }
168     switch(ret){
169     case FW_OK:
170         nprintf(kb, nnumber, 0, "fwupdate %s ok\n", path);
171         break;
172     case FW_NOFILE:
173     case FW_WRONGDEV:
174         nprintf(kb, nnumber, 0, "fwupdate %s invalid\n", path);
175         break;
176     case FW_USBFAIL:
177         nprintf(kb, nnumber, 0, "fwupdate %s fail\n", path);
178         return -1;
179     }
180     return 0;
181 }
.fi
.SS "int getfwversion (\fBusbdevice\fP *kb)"

.PP
Definition at line 11 of file firmware\&.c\&.
.PP
References ckb_err, ckb_warn, FEAT_POLLRATE, usbdevice::features, usbdevice::fwversion, MSG_SIZE, usbdevice::pollrate, usbdevice::product, usbrecv, and usbdevice::vendor\&.
.PP
Referenced by _start_dev()\&.
.PP
.nf
11                                {
12     // Ask board for firmware info
13     uchar data_pkt[MSG_SIZE] = { 0x0e, 0x01, 0 };
14     uchar in_pkt[MSG_SIZE];
15     if(!usbrecv(kb, data_pkt, in_pkt))
16         return -1;
17     if(in_pkt[0] != 0x0e || in_pkt[1] != 0x01){
18         ckb_err("Bad input header\n");
19         return -1;
20     }
21     short vendor, product, version, bootloader;
22     // Copy the vendor ID, product ID, version, and poll rate from the firmware data
23     memcpy(&version, in_pkt + 8, 2);
24     memcpy(&bootloader, in_pkt + 10, 2);
25     memcpy(&vendor, in_pkt + 12, 2);
26     memcpy(&product, in_pkt + 14, 2);
27     char poll = in_pkt[16];
28     if(poll <= 0){
29         poll = -1;
30         kb->features &= ~FEAT_POLLRATE;
31     }
32     // Print a warning if the message didn't match the expected data
33     if(vendor != kb->vendor)
34         ckb_warn("Got vendor ID %04x (expected %04x)\n", vendor, kb->vendor);
35     if(product != kb->product)
36         ckb_warn("Got product ID %04x (expected %04x)\n", product, kb->product);
37     // Set firmware version and poll rate
38     if(version == 0 || bootloader == 0){
39         // Needs firmware update
40         kb->fwversion = 0;
41         kb->pollrate = -1;
42     } else {
43         if(version != kb->fwversion && kb->fwversion != 0)
44             ckb_warn("Got firmware version %04x (expected %04x)\n", version, kb->fwversion);
45         kb->fwversion = version;
46         kb->pollrate = poll;
47     }
48     return 0;
49 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
