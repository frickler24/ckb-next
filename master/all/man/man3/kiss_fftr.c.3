.TH "src/ckb-mviz/kiss_fftr.c" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-mviz/kiss_fftr.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kiss_fftr\&.h'\fP
.br
\fC#include '_kiss_fft_guts\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBkiss_fftr_state\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBkiss_fftr_cfg\fP \fBkiss_fftr_alloc\fP (int nfft, int inverse_fft, void *mem, size_t *lenmem)"
.br
.ti -1c
.RI "void \fBkiss_fftr\fP (\fBkiss_fftr_cfg\fP st, const float *timedata, \fBkiss_fft_cpx\fP *freqdata)"
.br
.ti -1c
.RI "void \fBkiss_fftri\fP (\fBkiss_fftr_cfg\fP st, const \fBkiss_fft_cpx\fP *freqdata, float *timedata)"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct kiss_fftr_state"
.PP 
Definition at line 18 of file kiss_fftr\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
\fBkiss_fft_cfg\fP \fIsubstate\fP 
.br
.PP
\fBkiss_fft_cpx\fP * \fIsuper_twiddles\fP 
.br
.PP
\fBkiss_fft_cpx\fP * \fItmpbuf\fP 
.br
.PP
.RE
.PP
.SH "Function Documentation"
.PP 
.SS "void kiss_fftr (\fBkiss_fftr_cfg\fPst, const float *timedata, \fBkiss_fft_cpx\fP *freqdata)"

.PP
Definition at line 67 of file kiss_fftr\&.c\&.
.PP
References C_ADD, C_FIXDIV, C_MUL, C_SUB, CHECK_OVERFLOW_OP, HALF_OF, kiss_fft_cpx::i, kiss_fft_state::inverse, kiss_fft(), kiss_fft_state::nfft, kiss_fft_cpx::r, kiss_fftr_state::substate, kiss_fftr_state::super_twiddles, and kiss_fftr_state::tmpbuf\&.
.PP
.nf
68 {
69     /* input buffer timedata is stored row-wise */
70     int k,ncfft;
71     kiss_fft_cpx fpnk,fpk,f1k,f2k,tw,tdc;
72 
73     if ( st->substate->inverse) {
74         fprintf(stderr,"kiss fft usage error: improper alloc\n");
75         exit(1);
76     }
77 
78     ncfft = st->substate->nfft;
79 
80     /*perform the parallel fft of two real signals packed in real,imag*/
81     kiss_fft( st->substate , (const kiss_fft_cpx*)timedata, st->tmpbuf );
82     /* The real part of the DC element of the frequency spectrum in st->tmpbuf
83      * contains the sum of the even-numbered elements of the input time sequence
84      * The imag part is the sum of the odd-numbered elements
85      *
86      * The sum of tdc\&.r and tdc\&.i is the sum of the input time sequence\&. 
87      *      yielding DC of input time sequence
88      * The difference of tdc\&.r - tdc\&.i is the sum of the input (dot product) [1,-1,1,-1\&.\&.\&. 
89      *      yielding Nyquist bin of input time sequence
90      */
91  
92     tdc\&.r = st->tmpbuf[0]\&.r;
93     tdc\&.i = st->tmpbuf[0]\&.i;
94     C_FIXDIV(tdc,2);
95     CHECK_OVERFLOW_OP(tdc\&.r ,+, tdc\&.i);
96     CHECK_OVERFLOW_OP(tdc\&.r ,-, tdc\&.i);
97     freqdata[0]\&.r = tdc\&.r + tdc\&.i;
98     freqdata[ncfft]\&.r = tdc\&.r - tdc\&.i;
99 #ifdef USE_SIMD    
100     freqdata[ncfft]\&.i = freqdata[0]\&.i = _mm_set1_ps(0);
101 #else
102     freqdata[ncfft]\&.i = freqdata[0]\&.i = 0;
103 #endif
104 
105     for ( k=1;k <= ncfft/2 ; ++k ) {
106         fpk    = st->tmpbuf[k]; 
107         fpnk\&.r =   st->tmpbuf[ncfft-k]\&.r;
108         fpnk\&.i = - st->tmpbuf[ncfft-k]\&.i;
109         C_FIXDIV(fpk,2);
110         C_FIXDIV(fpnk,2);
111 
112         C_ADD( f1k, fpk , fpnk );
113         C_SUB( f2k, fpk , fpnk );
114         C_MUL( tw , f2k , st->super_twiddles[k-1]);
115 
116         freqdata[k]\&.r = HALF_OF(f1k\&.r + tw\&.r);
117         freqdata[k]\&.i = HALF_OF(f1k\&.i + tw\&.i);
118         freqdata[ncfft-k]\&.r = HALF_OF(f1k\&.r - tw\&.r);
119         freqdata[ncfft-k]\&.i = HALF_OF(tw\&.i - f1k\&.i);
120     }
121 }
.fi
.SS "\fBkiss_fftr_cfg\fP kiss_fftr_alloc (intnfft, intinverse_fft, void *mem, size_t *lenmem)"

.PP
Definition at line 27 of file kiss_fftr\&.c\&.
.PP
References kf_cexp, kiss_fft_alloc(), KISS_FFT_MALLOC, phase, kiss_fftr_state::substate, kiss_fftr_state::super_twiddles, and kiss_fftr_state::tmpbuf\&.
.PP
.nf
28 {
29     int i;
30     kiss_fftr_cfg st = NULL;
31     size_t subsize, memneeded;
32 
33     if (nfft & 1) {
34         fprintf(stderr,"Real FFT optimization must be even\&.\n");
35         return NULL;
36     }
37     nfft >>= 1;
38 
39     kiss_fft_alloc (nfft, inverse_fft, NULL, &subsize);
40     memneeded = sizeof(struct kiss_fftr_state) + subsize + sizeof(kiss_fft_cpx) * ( nfft * 3 / 2);
41 
42     if (lenmem == NULL) {
43         st = (kiss_fftr_cfg) KISS_FFT_MALLOC (memneeded);
44     } else {
45         if (*lenmem >= memneeded)
46             st = (kiss_fftr_cfg) mem;
47         *lenmem = memneeded;
48     }
49     if (!st)
50         return NULL;
51 
52     st->substate = (kiss_fft_cfg) (st + 1); /*just beyond kiss_fftr_state struct */
53     st->tmpbuf = (kiss_fft_cpx *) (((char *) st->substate) + subsize);
54     st->super_twiddles = st->tmpbuf + nfft;
55     kiss_fft_alloc(nfft, inverse_fft, st->substate, &subsize);
56 
57     for (i = 0; i < nfft/2; ++i) {
58         double phase =
59             -3\&.14159265358979323846264338327 * ((double) (i+1) / nfft + \&.5);
60         if (inverse_fft)
61             phase *= -1;
62         kf_cexp (st->super_twiddles+i,phase);
63     }
64     return st;
65 }
.fi
.SS "void kiss_fftri (\fBkiss_fftr_cfg\fPst, const \fBkiss_fft_cpx\fP *freqdata, float *timedata)"

.PP
Definition at line 123 of file kiss_fftr\&.c\&.
.PP
References C_ADD, C_FIXDIV, C_MUL, C_SUB, kiss_fft_cpx::i, kiss_fft_state::inverse, kiss_fft(), kiss_fft_state::nfft, kiss_fft_cpx::r, kiss_fftr_state::substate, kiss_fftr_state::super_twiddles, and kiss_fftr_state::tmpbuf\&.
.PP
.nf
124 {
125     /* input buffer timedata is stored row-wise */
126     int k, ncfft;
127 
128     if (st->substate->inverse == 0) {
129         fprintf (stderr, "kiss fft usage error: improper alloc\n");
130         exit (1);
131     }
132 
133     ncfft = st->substate->nfft;
134 
135     st->tmpbuf[0]\&.r = freqdata[0]\&.r + freqdata[ncfft]\&.r;
136     st->tmpbuf[0]\&.i = freqdata[0]\&.r - freqdata[ncfft]\&.r;
137     C_FIXDIV(st->tmpbuf[0],2);
138 
139     for (k = 1; k <= ncfft / 2; ++k) {
140         kiss_fft_cpx fk, fnkc, fek, fok, tmp;
141         fk = freqdata[k];
142         fnkc\&.r = freqdata[ncfft - k]\&.r;
143         fnkc\&.i = -freqdata[ncfft - k]\&.i;
144         C_FIXDIV( fk , 2 );
145         C_FIXDIV( fnkc , 2 );
146 
147         C_ADD (fek, fk, fnkc);
148         C_SUB (tmp, fk, fnkc);
149         C_MUL (fok, tmp, st->super_twiddles[k-1]);
150         C_ADD (st->tmpbuf[k],     fek, fok);
151         C_SUB (st->tmpbuf[ncfft - k], fek, fok);
152 #ifdef USE_SIMD        
153         st->tmpbuf[ncfft - k]\&.i *= _mm_set1_ps(-1\&.0);
154 #else
155         st->tmpbuf[ncfft - k]\&.i *= -1;
156 #endif
157     }
158     kiss_fft (st->substate, st->tmpbuf, (kiss_fft_cpx *) timedata);
159 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
