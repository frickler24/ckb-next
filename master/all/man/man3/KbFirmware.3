.TH "KbFirmware" 3 "Fri Nov 3 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KbFirmware \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kbfirmware\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBFW\fP"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBdownloaded\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBcheckUpdates\fP ()"
.br
.ti -1c
.RI "static bool \fBhasDownloaded\fP ()"
.br
.ti -1c
.RI "static float \fBversionForBoard\fP (const QString &features, bool waitForComplete=false)"
.br
.ti -1c
.RI "static QByteArray \fBdataForBoard\fP (const QString &features)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "QNetworkAccessManager * \fBnetworkManager\fP"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBUNKNOWN\fP = -1, \fBNO\fP, \fBYES\fP }"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBprocessDownload\fP (QNetworkReply *reply)"
.br
.ti -1c
.RI "void \fBdownloadFinished\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKbFirmware\fP ()"
.br
.ti -1c
.RI "\fB~KbFirmware\fP ()"
.br
.ti -1c
.RI "bool \fB_checkUpdates\fP ()"
.br
.ti -1c
.RI "float \fB_latestForBoard\fP (const QString &features, bool waitForComplete)"
.br
.ti -1c
.RI "QByteArray \fB_fileForBoard\fP (const QString &features)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "quint64 \fBlastCheck\fP"
.br
.ti -1c
.RI "quint64 \fBlastFinished\fP"
.br
.ti -1c
.RI "QMap< QString, \fBFW\fP > \fBfwTable\fP"
.br
.ti -1c
.RI "QByteArray \fBfwTableHash\fP"
.br
.ti -1c
.RI "QNetworkReply * \fBtableDownload\fP"
.br
.ti -1c
.RI "enum KbFirmware:: { \&.\&.\&. }  \fBhasGPG\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBKbFirmware\fP \fBinstance\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 10 of file kbfirmware\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN \fP\fP
.TP
\fB\fINO \fP\fP
.TP
\fB\fIYES \fP\fP
.PP
Definition at line 52 of file kbfirmware\&.h\&.
.PP
.nf
52 { UNKNOWN = -1, NO, YES } hasGPG :2;
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KbFirmware::KbFirmware ()\fC [private]\fP"

.PP
Definition at line 14 of file kbfirmware\&.cpp\&.
.PP
References networkManager\&.
.PP
.nf
14                        :
15     lastCheck(0), lastFinished(0), networkManager(0), tableDownload(0), hasGPG(UNKNOWN)
16 {
17     // Disable bearer polling\&. This corrects an issue with latency spikes when
18     // using WiFi\&. The problem and workaround are described here:
19     // https://lostdomain\&.org/2017/06/17/qt-qnetworkaccessmanager-causing-latency-spikes-on-wifi/
20     qputenv("QT_BEARER_POLL_TIMEOUT", QByteArray::number(-1));
21     networkManager = new QNetworkAccessManager();
22 }
.fi
.SS "KbFirmware::~KbFirmware ()\fC [private]\fP"

.PP
Definition at line 24 of file kbfirmware\&.cpp\&.
.PP
References networkManager\&.
.PP
.nf
24                        {
25     delete networkManager;
26 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool KbFirmware::_checkUpdates ()\fC [private]\fP"

.PP
Definition at line 28 of file kbfirmware\&.cpp\&.
.PP
References AUTO_CHECK_TIME, downloadFinished(), lastCheck, networkManager, and tableDownload\&.
.PP
Referenced by checkUpdates()\&.
.PP
.nf
28                               {
29     quint64 now = QDateTime::currentMSecsSinceEpoch();
30     if(now < lastCheck + AUTO_CHECK_TIME)
31         return false;
32     // First location is for debugging only\&.
33     // tableDownload = networkManager->get(QNetworkRequest(QUrl("https://raw\&.githubusercontent\&.com/frickler24/ckb-next/issues-26-Firmware-Incident/FIRMWARE")));
34     // This one is the production one\&.
35     tableDownload = networkManager->get(QNetworkRequest(QUrl("https://raw\&.githubusercontent\&.com/mattanger/ckb-next/master/FIRMWARE")));
36     connect(tableDownload, SIGNAL(finished()), this, SLOT(downloadFinished()));
37     lastCheck = now;
38     return true;
39 }
.fi
.SS "QByteArray KbFirmware::_fileForBoard (const QString &features)\fC [private]\fP"

.PP
Definition at line 180 of file kbfirmware\&.cpp\&.
.PP
References QuaZip::csInsensitive, KbFirmware::FW::fileName, fwTable, KbFirmware::FW::hash, QuaZip::mdUnzip, networkManager, QuaZip::open(), QuaZipFile::open(), quit(), QuaZip::setCurrentFile(), tableName(), and KbFirmware::FW::url\&.
.PP
Referenced by dataForBoard()\&.
.PP
.nf
180                                                            {
181     QString name = tableName(features);
182     FW info = fwTable\&.value(name);
183     if(info\&.hash\&.isEmpty())
184         return "";
185     // Download zip from URL\&. Wait for it to finish\&.
186     QNetworkReply* reply = networkManager->get(QNetworkRequest(QUrl(info\&.url)));
187     QEventLoop loop(this);
188     connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
189     loop\&.exec();
190     // Download finished, process data
191     if(reply->error() != QNetworkReply::NoError)
192         return "";
193     QByteArray zipData = reply->readAll();
194     QBuffer buffer(&zipData);
195     // Open zip archive
196     QuaZip zip(&buffer);
197     if(!zip\&.open(QuaZip::mdUnzip))
198         return "";
199     // Find the desired file
200     if(!zip\&.setCurrentFile(info\&.fileName, QuaZip::csInsensitive))
201         return "";
202     QuaZipFile binFile(&zip);
203     if(!binFile\&.open(QIODevice::ReadOnly))
204         return "";
205     QByteArray binary = binFile\&.readAll();
206     // Check the hash
207     if(QCryptographicHash::hash(binary, QCryptographicHash::Sha256) != info\&.hash)
208         return "";
209     return binary;
210 }
.fi
.SS "float KbFirmware::_latestForBoard (const QString &features, boolwaitForComplete)\fC [private]\fP"

.PP
Definition at line 162 of file kbfirmware\&.cpp\&.
.PP
References checkUpdates(), KbManager::ckbDaemonVersionF(), KbManager::ckbGuiVersionF(), KbFirmware::FW::ckbVersion, downloaded(), fwTable, KbFirmware::FW::fwVersion, KbFirmware::FW::hash, quit(), tableDownload, and tableName()\&.
.PP
Referenced by versionForBoard()\&.
.PP
.nf
162                                                                               {
163     if((tableDownload || checkUpdates()) && waitForComplete){
164         // If waiting is desired, enter an event loop and stay here until the download is finished
165         QEventLoop loop(this);
166         connect(this, SIGNAL(downloaded()), &loop, SLOT(quit()));
167         loop\&.exec();
168     }
169     // Find this board
170     QString name = tableName(features);
171     FW info = fwTable\&.value(name);
172     if(info\&.hash\&.isEmpty())
173         return 0\&.f;
174     // Don't return the new version if the current ckb doesn't support it
175     if(info\&.ckbVersion > KbManager::ckbGuiVersionF() || info\&.ckbVersion > KbManager::ckbDaemonVersionF())
176         return -1\&.f;
177     return info\&.fwVersion;
178 }
.fi
.SS "static bool KbFirmware::checkUpdates ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 15 of file kbfirmware\&.h\&.
.PP
References _checkUpdates(), and instance\&.
.PP
Referenced by _latestForBoard(), and MainWindow::timerTick()\&.
.PP
.nf
15 { return instance\&._checkUpdates(); }
.fi
.SS "static QByteArray KbFirmware::dataForBoard (const QString &features)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 25 of file kbfirmware\&.h\&.
.PP
References _fileForBoard(), and instance\&.
.PP
Referenced by FwUpgradeDialog::exec()\&.
.PP
.nf
25 { return instance\&._fileForBoard(features); }
.fi
.SS "void KbFirmware::downloaded ()\fC [signal]\fP"

.PP
Definition at line 148 of file moc_kbfirmware\&.cpp\&.
.PP
Referenced by _latestForBoard(), and downloadFinished()\&.
.PP
.nf
149 {
150     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
151 }
.fi
.SS "void KbFirmware::downloadFinished ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 141 of file kbfirmware\&.cpp\&.
.PP
References downloaded(), processDownload(), and tableDownload\&.
.PP
Referenced by _checkUpdates()\&.
.PP
.nf
141                                  {
142     if(!tableDownload)
143         return;
144     processDownload(tableDownload);
145     tableDownload->deleteLater();
146     tableDownload = 0;
147     emit downloaded();
148 }
.fi
.SS "static bool KbFirmware::hasDownloaded ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 18 of file kbfirmware\&.h\&.
.PP
References instance, and lastFinished\&.
.PP
Referenced by KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.PP
.nf
18 { return instance\&.lastFinished != 0; }
.fi
.SS "void KbFirmware::processDownload (QNetworkReply *reply)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 41 of file kbfirmware\&.cpp\&.
.PP
References KbFirmware::FW::ckbVersion, KbFirmware::FW::fileName, fwTable, fwTableHash, KbFirmware::FW::fwVersion, hasGPG, KbFirmware::FW::hash, lastCheck, lastFinished, NO, KbManager::parseVersionString(), UNKNOWN, KbFirmware::FW::url, and YES\&.
.PP
Referenced by downloadFinished()\&.
.PP
.nf
41                                                     {
42     if(reply->error() != QNetworkReply::NoError)
43         return;
44     // Update last check
45     lastCheck = lastFinished = QDateTime::currentMSecsSinceEpoch();
46     QByteArray data = reply->readAll();
47     // Don't do anything if this is the same as the last version downloaded
48     QByteArray hash = QCryptographicHash::hash(data, QCryptographicHash::Sha256);
49     if(hash == fwTableHash)
50         return;
51     fwTableHash = hash;
52     if(hasGPG == UNKNOWN){
53         // Check for a GPG installation
54         QProcess gpg;
55         gpg\&.start("gpg", QStringList("--version"));
56         gpg\&.waitForFinished();
57         if(gpg\&.error() == QProcess::FailedToStart)
58             // No GPG install
59             hasGPG = NO;
60         else {
61             QString output = QString::fromUtf8(gpg\&.readAll());
62             // Must support RSA keys and SHA256
63             if(output\&.contains("RSA", Qt::CaseInsensitive) && output\&.contains("SHA256", Qt::CaseInsensitive))
64                 hasGPG = YES;
65             else
66                 hasGPG = NO;
67         }
68         if(!hasGPG)
69             qDebug() << "No GPG detected, signature verification disabled";
70     }
71     if(hasGPG){
72         // If GPG is available, check the signature on the file before proceeding\&.
73         QDir tmp = QDir::temp();
74         // Save file to a temporary path\&. Include PID to avoid conflicts
75         qint64 pid = QCoreApplication::applicationPid();
76         QString fwPath = tmp\&.absoluteFilePath(QString("ckb-%1-firmware")\&.arg(pid));
77         QFile firmware(fwPath);
78         if(!firmware\&.open(QIODevice::WriteOnly)
79                 || firmware\&.write(data) != data\&.length()){
80             qDebug() << "Failed to write firmware file to temporary location, aborting firmware check";
81             return;
82         }
83         firmware\&.close();
84         // Write GPG key
85         QString keyPath = tmp\&.absoluteFilePath(QString("ckb-%1-key\&.gpg")\&.arg(pid));
86         if(!QFile::copy(":/bin/ckb-next-key\&.gpg", keyPath)){
87             firmware\&.remove();
88             qDebug() << "Failed to write GPG key to temporary location, aborting firmware check";
89             return;
90         }
91         // Check signature
92         QProcess gpg;
93         gpg\&.start("gpg", QStringList("--no-default-keyring") << "--keyring" << keyPath << "--verify" << fwPath);
94         gpg\&.waitForFinished();
95         // Clean up temp files
96         tmp\&.remove(fwPath);
97         tmp\&.remove(keyPath);
98         if(gpg\&.error() != QProcess::UnknownError || gpg\&.exitCode() != 0){
99             qDebug() << "GPG couldn't verify firmware signature:";
100             qDebug() << gpg\&.readAllStandardOutput();
101             qDebug() << gpg\&.readAllStandardError();
102             return;
103         }
104         // Signature good, proceed to update database
105     }
106     fwTable\&.clear();
107     QStringList lines = QString::fromUtf8(data)\&.split("\n");
108     bool scan = false;
109     foreach(QString line, lines){
110         // Collapse whitespace
111         line\&.replace(QRegExp("\\s+"), " ")\&.remove(QRegExp("^\\s"))\&.remove(QRegExp("\\s$"));
112         // Skip empty or commented-out lines
113         if(line\&.length() == 0 || line\&.at(0) == '#')
114             continue;
115         // Don't read anything until the entries begin and don't read anything after they end
116         if(!scan){
117             if(line == "!BEGIN FW ENTRIES")
118                 scan = true;
119             else
120                 continue;
121         }
122         if(line == "!END FW ENTRIES")
123             break;
124         QStringList components = line\&.split(" ");
125         if(components\&.length() != 7)
126             continue;
127         // "VENDOR-PRODUCT"
128         QString device = components[0]\&.toUpper() + "-" + components[1]\&.toUpper();
129         FW fw;
130         fw\&.fwVersion = components[2]\&.toFloat();                             // Firmware blob version
131         fw\&.url = QUrl::fromPercentEncoding(components[3]\&.toLatin1());       // URL to zip file
132         fw\&.ckbVersion = KbManager::parseVersionString(components[4]);       // Minimum ckb version
133         fw\&.fileName = QUrl::fromPercentEncoding(components[5]\&.toLatin1());  // Name of file inside zip
134         fw\&.hash = QByteArray::fromHex(components[6]\&.toLatin1());            // SHA256 of file inside zip
135         // Update entry
136         fwTable[device] = fw;
137     }
138     qDebug() << "Downloaded new firmware list\&." << fwTable\&.count() << "entries found\&.";
139 }
.fi
.SS "static float KbFirmware::versionForBoard (const QString &features, boolwaitForComplete = \fCfalse\fP)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 22 of file kbfirmware\&.h\&.
.PP
References _latestForBoard(), and instance\&.
.PP
Referenced by MainWindow::checkFwUpdates(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.PP
.nf
22 { return instance\&._latestForBoard(features, waitForComplete); }
.fi
.SH "Field Documentation"
.PP 
.SS "QMap<QString, \fBFW\fP> KbFirmware::fwTable\fC [private]\fP"

.PP
Definition at line 44 of file kbfirmware\&.h\&.
.PP
Referenced by _fileForBoard(), _latestForBoard(), and processDownload()\&.
.SS "QByteArray KbFirmware::fwTableHash\fC [private]\fP"

.PP
Definition at line 46 of file kbfirmware\&.h\&.
.PP
Referenced by processDownload()\&.
.SS "enum { \&.\&.\&. }   KbFirmware::hasGPG\fC [private]\fP"

.PP
Referenced by processDownload()\&.
.SS "\fBKbFirmware\fP KbFirmware::instance\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 58 of file kbfirmware\&.h\&.
.PP
Referenced by checkUpdates(), dataForBoard(), hasDownloaded(), and versionForBoard()\&.
.SS "quint64 KbFirmware::lastCheck\fC [private]\fP"

.PP
Definition at line 35 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), and processDownload()\&.
.SS "quint64 KbFirmware::lastFinished\fC [private]\fP"

.PP
Definition at line 35 of file kbfirmware\&.h\&.
.PP
Referenced by hasDownloaded(), and processDownload()\&.
.SS "QNetworkAccessManager* KbFirmware::networkManager"

.PP
Definition at line 28 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), _fileForBoard(), KbFirmware(), and ~KbFirmware()\&.
.SS "QNetworkReply* KbFirmware::tableDownload\fC [private]\fP"

.PP
Definition at line 49 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), _latestForBoard(), and downloadFinished()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
