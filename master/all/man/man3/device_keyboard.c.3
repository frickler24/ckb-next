.TH "src/ckb-daemon/device_keyboard.c" 3 "Thu Nov 2 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/device_keyboard.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'command\&.h'\fP
.br
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'firmware\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBstart_kb_nrgb\fP (\fBusbdevice\fP *kb, int makeactive)"
.br
.ti -1c
.RI "int \fBsetactive_kb\fP (\fBusbdevice\fP *kb, int active)"
.br
.ti -1c
.RI "int \fBcmd_active_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_idle_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "void \fBsetmodeindex_nrgb\fP (\fBusbdevice\fP *kb, int index)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int cmd_active_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 114 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
114                                                                                              {
115     (void)dummy1;
116     (void)dummy2;
117     (void)dummy3;
118     (void)dummy4;
119 
120     return setactive_kb(kb, 1);
121 }
.fi
.SS "int cmd_idle_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 123 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
123                                                                                            {
124     (void)dummy1;
125     (void)dummy2;
126     (void)dummy3;
127     (void)dummy4;
128 
129     return setactive_kb(kb, 0);
130 }
.fi
.SS "int setactive_kb (\fBusbdevice\fP *kb, intactive)"

.PP
Definition at line 20 of file device_keyboard\&.c\&.
.PP
References ACT_LIGHT, ACT_LOCK, ACT_M1, ACT_M2, ACT_M3, ACT_MR_RING, usbdevice::active, DELAY_MEDIUM, lighting::forceupdate, imutex, IN_CORSAIR, IN_HID, usbdevice::input, inputupdate(), keymap, usbinput::keys, usbprofile::lastlight, MSG_SIZE, N_KEYS_HW, NEEDS_FW_UPDATE, usbdevice::profile, usbsend, and usbdevice::vtable\&.
.PP
Referenced by cmd_active_kb(), and cmd_idle_kb()\&.
.PP
.nf
20                                            {
21     if(NEEDS_FW_UPDATE(kb))
22         return 0;
23 
24     pthread_mutex_lock(imutex(kb));
25     kb->active = !!active;
26     kb->profile->lastlight\&.forceupdate = 1;
27     // Clear input
28     memset(&kb->input\&.keys, 0, sizeof(kb->input\&.keys));
29     inputupdate(kb);
30     pthread_mutex_unlock(imutex(kb));
31 
32     uchar msg[3][MSG_SIZE] = {
33         { 0x07, 0x04, 0 },                  // Disables or enables HW control for top row
34         { 0x07, 0x40, 0 },                  // Selects key input
35         { 0x07, 0x05, 2, 0, 0x03, 0x00 }    // Commits key input selection
36     };
37     if(active){
38         // Put the M-keys (K95) as well as the Brightness/Lock keys into software-controlled mode\&.
39         msg[0][2] = 2;
40         if(!usbsend(kb, msg[0], 1))
41             return -1;
42         DELAY_MEDIUM(kb);
43         // Set input mode on the keys\&. They must be grouped into packets of 60 bytes (+ 4 bytes header)
44         // Keys are referenced in byte pairs, with the first byte representing the key and the second byte representing the mode\&.
45         for(int key = 0; key < N_KEYS_HW; ){
46             int pair;
47             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
48                 // Select both standard and Corsair input\&. The standard input will be ignored except in BIOS mode\&.
49                 uchar action = IN_HID | IN_CORSAIR;
50                 // Additionally, make MR activate the MR ring (this is disabled for now, may be back later)
51                 //if(keymap[key]\&.name && !strcmp(keymap[key]\&.name, "mr"))
52                 //    action |= ACT_MR_RING;
53                 msg[1][4 + pair * 2] = key;
54                 msg[1][5 + pair * 2] = action;
55             }
56             // Byte 2 = pair count (usually 30, less on final message)
57             msg[1][2] = pair;
58             if(!usbsend(kb, msg[1], 1))
59                 return -1;
60         }
61         // Commit new input settings
62         if(!usbsend(kb, msg[2], 1))
63             return -1;
64         DELAY_MEDIUM(kb);
65     } else {
66         // Set the M-keys back into hardware mode, restore hardware RGB profile\&. It has to be sent twice for some reason\&.
67         msg[0][2] = 1;
68         if(!usbsend(kb, msg[0], 1))
69             return -1;
70         DELAY_MEDIUM(kb);
71         if(!usbsend(kb, msg[0], 1))
72             return -1;
73         DELAY_MEDIUM(kb);
74 #ifdef OS_LINUX
75         // On OSX the default key mappings are fine\&. On Linux, the G keys will freeze the keyboard\&. Set the keyboard entirely to HID input\&.
76         for(int key = 0; key < N_KEYS_HW; ){
77             int pair;
78             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
79                 uchar action = IN_HID;
80                 // Enable hardware actions
81                 if(keymap[key]\&.name){
82                     if(!strcmp(keymap[key]\&.name, "mr"))
83                         action = ACT_MR_RING;
84                     else if(!strcmp(keymap[key]\&.name, "m1"))
85                         action = ACT_M1;
86                     else if(!strcmp(keymap[key]\&.name, "m2"))
87                         action = ACT_M2;
88                     else if(!strcmp(keymap[key]\&.name, "m3"))
89                         action = ACT_M3;
90                     else if(!strcmp(keymap[key]\&.name, "light"))
91                         action = ACT_LIGHT;
92                     else if(!strcmp(keymap[key]\&.name, "lock"))
93                         action = ACT_LOCK;
94                 }
95                 msg[1][4 + pair * 2] = key;
96                 msg[1][5 + pair * 2] = action;
97             }
98             // Byte 2 = pair count (usually 30, less on final message)
99             msg[1][2] = pair;
100             if(!usbsend(kb, msg[1], 1))
101                 return -1;
102         }
103         // Commit new input settings
104         if(!usbsend(kb, msg[2], 1))
105             return -1;
106         DELAY_MEDIUM(kb);
107 #endif
108     }
109     // Update indicator LEDs if the profile contains settings for them
110     kb->vtable->updateindicators(kb, 0);
111     return 0;
112 }
.fi
.SS "void setmodeindex_nrgb (\fBusbdevice\fP *kb, intindex)"

.PP
Definition at line 132 of file device_keyboard\&.c\&.
.PP
References NK95_M1, NK95_M2, NK95_M3, and nk95cmd\&.
.PP
.nf
132                                                 {
133     switch(index % 3){
134     case 0:
135         nk95cmd(kb, NK95_M1);
136         break;
137     case 1:
138         nk95cmd(kb, NK95_M2);
139         break;
140     case 2:
141         nk95cmd(kb, NK95_M3);
142         break;
143     }
144 }
.fi
.SS "int start_kb_nrgb (\fBusbdevice\fP *kb, intmakeactive)"

.PP
Definition at line 9 of file device_keyboard\&.c\&.
.PP
References usbdevice::active, NK95_HWOFF, nk95cmd, and usbdevice::pollrate\&.
.PP
.nf
9                                                 {
10     (void)makeactive;
11 
12     // Put the non-RGB K95 into software mode\&. Nothing else needs to be done hardware wise
13     nk95cmd(kb, NK95_HWOFF);
14     // Fill out RGB features for consistency, even though the keyboard doesn't have them
15     kb->active = 1;
16     kb->pollrate = -1;
17     return 0;
18 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
