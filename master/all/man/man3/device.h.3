.TH "src/ckb-daemon/device.h" 3 "Thu Nov 2 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/device.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br
\fC#include 'keymap\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEV_MAX\fP   9"
.br
.ti -1c
.RI "#define \fBIS_CONNECTED\fP(kb)   ((kb) && (kb)->handle && (kb)->uinput_kb && (kb)->uinput_mouse)"
.br
.ti -1c
.RI "#define \fBdmutex\fP(kb)   (\fBdevmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBimutex\fP(kb)   (\fBinputmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBmmutex\fP(kb)   (\fBmacromutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBmmutex2\fP(kb)   (\fBmacromutex2\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBmvar\fP(kb)   (\fBmacrovar\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBsetactive\fP(kb, makeactive)   ((makeactive) ? (kb)->vtable->active((kb), 0, 0, 0, 0) : (kb)->vtable->idle((kb), 0, 0, 0, 0))"
.br
.RI "\fI\fBsetactive()\fP calls via the corresponding kb->vtable either the active() or the idle() function\&. 
.br
 active() is called if the parameter makeactive is true, idle if it is false\&. 
.br
 What function is called effectively is device dependent\&. Have a look at \fI\fBdevice_vtable\&.c\fP\fP for more information\&. \fP"
.ti -1c
.RI "#define \fBIN_HID\fP   0x80"
.br
.ti -1c
.RI "#define \fBIN_CORSAIR\fP   0x40"
.br
.ti -1c
.RI "#define \fBACT_LIGHT\fP   1"
.br
.ti -1c
.RI "#define \fBACT_NEXT\fP   3"
.br
.ti -1c
.RI "#define \fBACT_NEXT_NOWRAP\fP   5"
.br
.ti -1c
.RI "#define \fBACT_LOCK\fP   8"
.br
.ti -1c
.RI "#define \fBACT_MR_RING\fP   9"
.br
.ti -1c
.RI "#define \fBACT_M1\fP   10"
.br
.ti -1c
.RI "#define \fBACT_M2\fP   11"
.br
.ti -1c
.RI "#define \fBACT_M3\fP   12"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBstart_dev\fP (\fBusbdevice\fP *kb, int makeactive)"
.br
.ti -1c
.RI "int \fBstart_kb_nrgb\fP (\fBusbdevice\fP *kb, int makeactive)"
.br
.ti -1c
.RI "int \fBsetactive_kb\fP (\fBusbdevice\fP *kb, int active)"
.br
.ti -1c
.RI "int \fBsetactive_mouse\fP (\fBusbdevice\fP *kb, int active)"
.br
.ti -1c
.RI "int \fBcmd_active_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_active_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_idle_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_idle_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_pollrate\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int rate, const char *dummy3)"
.br
.ti -1c
.RI "void \fBsetmodeindex_nrgb\fP (\fBusbdevice\fP *kb, int index)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBusbdevice\fP \fBkeyboard\fP [9]"
.br
.RI "\fIremember all usb devices\&. Needed for \fBcloseusb()\fP\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBdevmutex\fP [9]"
.br
.RI "\fIMutex for handling the usbdevice structure\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBinputmutex\fP [9]"
.br
.RI "\fIMutex for dealing with usb input frames\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmacromutex\fP [9]"
.br
.RI "\fIProtecting macros against lightning: Both use usb_send\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmacromutex2\fP [9]"
.br
.RI "\fIProtecting the single link list of threads and the macrovar\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBmacrovar\fP [9]"
.br
.RI "\fIThis variable is used to stop and wakeup all macro threads which have to wait\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ACT_LIGHT   1"

.PP
Definition at line 68 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_LOCK   8"

.PP
Definition at line 71 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_M1   10"

.PP
Definition at line 73 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_M2   11"

.PP
Definition at line 74 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_M3   12"

.PP
Definition at line 75 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_MR_RING   9"

.PP
Definition at line 72 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_NEXT   3"

.PP
Definition at line 69 of file device\&.h\&.
.SS "#define ACT_NEXT_NOWRAP   5"

.PP
Definition at line 70 of file device\&.h\&.
.SS "#define DEV_MAX   9"

.PP
Definition at line 8 of file device\&.h\&.
.PP
Referenced by _updateconnected(), quitWithLock(), usb_rm_device(), and usbadd()\&.
.SS "#define dmutex(kb)   (\fBdevmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 18 of file device\&.h\&.
.PP
Referenced by _ledthread(), _setupusb(), closeusb(), devmain(), and usbadd()\&.
.SS "#define imutex(kb)   (\fBinputmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 22 of file device\&.h\&.
.PP
Referenced by _setupusb(), closeusb(), cmd_bind(), cmd_erase(), cmd_eraseprofile(), cmd_get(), cmd_macro(), cmd_notify(), cmd_rebind(), cmd_unbind(), os_inputmain(), setactive_kb(), setactive_mouse(), and setupusb()\&.
.SS "#define IN_CORSAIR   0x40"

.PP
Definition at line 65 of file device\&.h\&.
.PP
Referenced by setactive_kb(), and setactive_mouse()\&.
.SS "#define IN_HID   0x80"

.PP
Definition at line 64 of file device\&.h\&.
.PP
Referenced by setactive_kb(), and setactive_mouse()\&.
.SS "#define IS_CONNECTED(kb)   ((kb) && (kb)->handle && (kb)->uinput_kb && (kb)->uinput_mouse)"

.PP
Definition at line 12 of file device\&.h\&.
.PP
Referenced by _updateconnected(), devmain(), quitWithLock(), and usbadd()\&.
.SS "#define mmutex(kb)   (\fBmacromutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 26 of file device\&.h\&.
.PP
Referenced by _usbrecv(), _usbsend(), and play_macro()\&.
.SS "#define mmutex2(kb)   (\fBmacromutex2\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 28 of file device\&.h\&.
.PP
Referenced by play_macro()\&.
.SS "#define mvar(kb)   (\fBmacrovar\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 30 of file device\&.h\&.
.PP
Referenced by play_macro()\&.
.SS "#define setactive(kb, makeactive)   ((makeactive) ? (kb)->vtable->active((kb), 0, 0, 0, 0) : (kb)->vtable->idle((kb), 0, 0, 0, 0))"

.PP
Definition at line 44 of file device\&.h\&.
.PP
Referenced by _start_dev(), and revertusb()\&.
.SH "Function Documentation"
.PP 
.SS "int cmd_active_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 114 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
114                                                                                              {
115     (void)dummy1;
116     (void)dummy2;
117     (void)dummy3;
118     (void)dummy4;
119 
120     return setactive_kb(kb, 1);
121 }
.fi
.SS "int cmd_active_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 44 of file device_mouse\&.c\&.
.PP
References setactive_mouse()\&.
.PP
.nf
44                                                                                                 {
45     (void)dummy1;
46     (void)dummy2;
47     (void)dummy3;
48     (void)dummy4;
49 
50     return setactive_mouse(kb, 1);
51 }
.fi
.SS "int cmd_idle_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 123 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
123                                                                                            {
124     (void)dummy1;
125     (void)dummy2;
126     (void)dummy3;
127     (void)dummy4;
128 
129     return setactive_kb(kb, 0);
130 }
.fi
.SS "int cmd_idle_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 53 of file device_mouse\&.c\&.
.PP
References setactive_mouse()\&.
.PP
.nf
53                                                                                               {
54     (void)dummy1;
55     (void)dummy2;
56     (void)dummy3;
57     (void)dummy4;
58 
59     return setactive_mouse(kb, 0);
60 }
.fi
.SS "int cmd_pollrate (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intrate, const char *dummy3)"

.PP
Definition at line 62 of file device_mouse\&.c\&.
.PP
References MSG_SIZE, usbdevice::pollrate, and usbsend\&.
.PP
.nf
62                                                                                           {
63     (void)dummy1;
64     (void)dummy2;
65     (void)dummy3;
66 
67     uchar msg[MSG_SIZE] = {
68         0x07, 0x0a, 0, 0, (uchar)rate
69     };
70     if(!usbsend(kb, msg, 1))
71         return -1;
72     // Device should disconnect+reconnect, but update the poll rate field in case it doesn't
73     kb->pollrate = rate;
74     return 0;
75 }
.fi
.SS "int setactive_kb (\fBusbdevice\fP *kb, intactive)"

.PP
Definition at line 20 of file device_keyboard\&.c\&.
.PP
References ACT_LIGHT, ACT_LOCK, ACT_M1, ACT_M2, ACT_M3, ACT_MR_RING, usbdevice::active, DELAY_MEDIUM, lighting::forceupdate, imutex, IN_CORSAIR, IN_HID, usbdevice::input, inputupdate(), keymap, usbinput::keys, usbprofile::lastlight, MSG_SIZE, N_KEYS_HW, NEEDS_FW_UPDATE, usbdevice::profile, usbsend, and usbdevice::vtable\&.
.PP
Referenced by cmd_active_kb(), and cmd_idle_kb()\&.
.PP
.nf
20                                            {
21     if(NEEDS_FW_UPDATE(kb))
22         return 0;
23 
24     pthread_mutex_lock(imutex(kb));
25     kb->active = !!active;
26     kb->profile->lastlight\&.forceupdate = 1;
27     // Clear input
28     memset(&kb->input\&.keys, 0, sizeof(kb->input\&.keys));
29     inputupdate(kb);
30     pthread_mutex_unlock(imutex(kb));
31 
32     uchar msg[3][MSG_SIZE] = {
33         { 0x07, 0x04, 0 },                  // Disables or enables HW control for top row
34         { 0x07, 0x40, 0 },                  // Selects key input
35         { 0x07, 0x05, 2, 0, 0x03, 0x00 }    // Commits key input selection
36     };
37     if(active){
38         // Put the M-keys (K95) as well as the Brightness/Lock keys into software-controlled mode\&.
39         msg[0][2] = 2;
40         if(!usbsend(kb, msg[0], 1))
41             return -1;
42         DELAY_MEDIUM(kb);
43         // Set input mode on the keys\&. They must be grouped into packets of 60 bytes (+ 4 bytes header)
44         // Keys are referenced in byte pairs, with the first byte representing the key and the second byte representing the mode\&.
45         for(int key = 0; key < N_KEYS_HW; ){
46             int pair;
47             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
48                 // Select both standard and Corsair input\&. The standard input will be ignored except in BIOS mode\&.
49                 uchar action = IN_HID | IN_CORSAIR;
50                 // Additionally, make MR activate the MR ring (this is disabled for now, may be back later)
51                 //if(keymap[key]\&.name && !strcmp(keymap[key]\&.name, "mr"))
52                 //    action |= ACT_MR_RING;
53                 msg[1][4 + pair * 2] = key;
54                 msg[1][5 + pair * 2] = action;
55             }
56             // Byte 2 = pair count (usually 30, less on final message)
57             msg[1][2] = pair;
58             if(!usbsend(kb, msg[1], 1))
59                 return -1;
60         }
61         // Commit new input settings
62         if(!usbsend(kb, msg[2], 1))
63             return -1;
64         DELAY_MEDIUM(kb);
65     } else {
66         // Set the M-keys back into hardware mode, restore hardware RGB profile\&. It has to be sent twice for some reason\&.
67         msg[0][2] = 1;
68         if(!usbsend(kb, msg[0], 1))
69             return -1;
70         DELAY_MEDIUM(kb);
71         if(!usbsend(kb, msg[0], 1))
72             return -1;
73         DELAY_MEDIUM(kb);
74 #ifdef OS_LINUX
75         // On OSX the default key mappings are fine\&. On Linux, the G keys will freeze the keyboard\&. Set the keyboard entirely to HID input\&.
76         for(int key = 0; key < N_KEYS_HW; ){
77             int pair;
78             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
79                 uchar action = IN_HID;
80                 // Enable hardware actions
81                 if(keymap[key]\&.name){
82                     if(!strcmp(keymap[key]\&.name, "mr"))
83                         action = ACT_MR_RING;
84                     else if(!strcmp(keymap[key]\&.name, "m1"))
85                         action = ACT_M1;
86                     else if(!strcmp(keymap[key]\&.name, "m2"))
87                         action = ACT_M2;
88                     else if(!strcmp(keymap[key]\&.name, "m3"))
89                         action = ACT_M3;
90                     else if(!strcmp(keymap[key]\&.name, "light"))
91                         action = ACT_LIGHT;
92                     else if(!strcmp(keymap[key]\&.name, "lock"))
93                         action = ACT_LOCK;
94                 }
95                 msg[1][4 + pair * 2] = key;
96                 msg[1][5 + pair * 2] = action;
97             }
98             // Byte 2 = pair count (usually 30, less on final message)
99             msg[1][2] = pair;
100             if(!usbsend(kb, msg[1], 1))
101                 return -1;
102         }
103         // Commit new input settings
104         if(!usbsend(kb, msg[2], 1))
105             return -1;
106         DELAY_MEDIUM(kb);
107 #endif
108     }
109     // Update indicator LEDs if the profile contains settings for them
110     kb->vtable->updateindicators(kb, 0);
111     return 0;
112 }
.fi
.SS "int setactive_mouse (\fBusbdevice\fP *kb, intactive)"

.PP
Definition at line 9 of file device_mouse\&.c\&.
.PP
References usbdevice::active, lighting::forceupdate, imutex, IN_CORSAIR, IN_HID, usbdevice::input, inputupdate(), usbinput::keys, usbprofile::lastlight, MSG_SIZE, NEEDS_FW_UPDATE, usbdevice::profile, and usbsend\&.
.PP
Referenced by cmd_active_mouse(), and cmd_idle_mouse()\&.
.PP
.nf
9                                               {
10     if(NEEDS_FW_UPDATE(kb))
11         return 0;
12     const int keycount = 20;
13     uchar msg[2][MSG_SIZE] = {
14         { 0x07, 0x04, 0 },                  // Disables or enables HW control for DPI and Sniper button
15         { 0x07, 0x40, keycount, 0 },        // Select button input (simlilar to the packet sent to keyboards, but lacks a commit packet)
16     };
17     if(active)
18         // Put the mouse into SW mode
19         msg[0][2] = 2;
20     else
21         // Restore HW mode
22         msg[0][2] = 1;
23     pthread_mutex_lock(imutex(kb));
24     kb->active = !!active;
25     kb->profile->lastlight\&.forceupdate = 1;
26     // Clear input
27     memset(&kb->input\&.keys, 0, sizeof(kb->input\&.keys));
28     inputupdate(kb);
29     pthread_mutex_unlock(imutex(kb));
30     if(!usbsend(kb, msg[0], 1))
31         return -1;
32     if(active){
33         // Set up key input
34         if(!usbsend(kb, msg[1], 1))
35             return -1;
36         for(int i = 0; i < keycount; i++){
37             msg[1][i * 2 + 4] = i + 1;
38             msg[1][i * 2 + 5] = (i < 6 ? IN_HID : IN_CORSAIR);
39         }
40     }
41     return 0;
42 }
.fi
.SS "void setmodeindex_nrgb (\fBusbdevice\fP *kb, intindex)"

.PP
Definition at line 132 of file device_keyboard\&.c\&.
.PP
References NK95_M1, NK95_M2, NK95_M3, and nk95cmd\&.
.PP
.nf
132                                                 {
133     switch(index % 3){
134     case 0:
135         nk95cmd(kb, NK95_M1);
136         break;
137     case 1:
138         nk95cmd(kb, NK95_M2);
139         break;
140     case 2:
141         nk95cmd(kb, NK95_M3);
142         break;
143     }
144 }
.fi
.SS "int start_dev (\fBusbdevice\fP *kb, intmakeactive)"

.PP
Definition at line 80 of file device\&.c\&.
.PP
References _start_dev(), USB_DELAY_DEFAULT, and usbdevice::usbdelay\&.
.PP
.nf
80                                             {
81     // Force USB interval to 10ms during initial setup phase; return to nominal 5ms after setup completes\&.
82     kb->usbdelay = 10;
83     int res = _start_dev(kb, makeactive);
84     kb->usbdelay = USB_DELAY_DEFAULT;
85     return res;
86 }
.fi
.SS "int start_kb_nrgb (\fBusbdevice\fP *kb, intmakeactive)"

.PP
Definition at line 9 of file device_keyboard\&.c\&.
.PP
References usbdevice::active, NK95_HWOFF, nk95cmd, and usbdevice::pollrate\&.
.PP
.nf
9                                                 {
10     (void)makeactive;
11 
12     // Put the non-RGB K95 into software mode\&. Nothing else needs to be done hardware wise
13     nk95cmd(kb, NK95_HWOFF);
14     // Fill out RGB features for consistency, even though the keyboard doesn't have them
15     kb->active = 1;
16     kb->pollrate = -1;
17     return 0;
18 }
.fi
.SH "Variable Documentation"
.PP 
.SS "pthread_mutex_t devmutex[9]"

.PP
Definition at line 12 of file device\&.c\&.
.PP
Referenced by _updateconnected(), quitWithLock(), and usb_rm_device()\&.
.SS "pthread_mutex_t inputmutex[9]"

.PP
Definition at line 13 of file device\&.c\&.
.SS "\fBusbdevice\fP keyboard[9]"

.PP
Definition at line 10 of file device\&.c\&.
.PP
Referenced by _mkdevpath(), _mknotifynode(), _rmnotifynode(), _setupusb(), _updateconnected(), closeusb(), main(), mkfwnode(), os_closeusb(), os_inputmain(), os_inputopen(), os_setupusb(), quitWithLock(), rmdevpath(), usb_rm_device(), and usbadd()\&.
.SS "pthread_mutex_t macromutex[9]"

.PP
Definition at line 14 of file device\&.c\&.
.SS "pthread_mutex_t macromutex2[9]"

.PP
Definition at line 15 of file device\&.c\&.
.SS "pthread_cond_t macrovar[9]"

.PP
Definition at line 16 of file device\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
