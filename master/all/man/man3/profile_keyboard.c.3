.TH "src/ckb-daemon/profile_keyboard.c" 3 "Thu Nov 2 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/profile_keyboard.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br
\fC#include 'led\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static int \fBhwloadmode\fP (\fBusbdevice\fP *kb, \fBhwprofile\fP *hw, int mode)"
.br
.ti -1c
.RI "int \fBcmd_hwload_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int apply, const char *dummy3)"
.br
.ti -1c
.RI "int \fBcmd_hwsave_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int cmd_hwload_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intapply, const char *dummy3)"

.PP
Definition at line 16 of file profile_keyboard\&.c\&.
.PP
References DELAY_LONG, usbdevice::hw, hwloadmode(), HWMODE_K70, HWMODE_K95, hwtonative(), hwprofile::id, IS_K95, MSG_SIZE, hwprofile::name, PR_NAME_LEN, usbdevice::profile, and usbrecv\&.
.PP
.nf
16                                                                                             {
17     (void)dummy1;
18     (void)dummy2;
19     (void)dummy3;
20 
21     DELAY_LONG(kb);
22     hwprofile* hw = calloc(1, sizeof(hwprofile));
23     // Ask for profile and mode IDs
24     uchar data_pkt[2][MSG_SIZE] = {
25         { 0x0e, 0x15, 0x01, 0 },
26         { 0x0e, 0x16, 0x01, 0 }
27     };
28     uchar in_pkt[MSG_SIZE];
29     int modes = (IS_K95(kb) ? HWMODE_K95 : HWMODE_K70);
30     for(int i = 0; i <= modes; i++){
31         data_pkt[0][3] = i;
32         if(!usbrecv(kb, data_pkt[0], in_pkt)){
33             free(hw);
34             return -1;
35         }
36         memcpy(hw->id + i, in_pkt + 4, sizeof(usbid));
37     }
38     // Ask for profile name
39     if(!usbrecv(kb, data_pkt[1], in_pkt)){
40         free(hw);
41         return -1;
42     }
43     memcpy(hw->name[0], in_pkt + 4, PR_NAME_LEN * 2);
44     // Load modes
45     for(int i = 0; i < modes; i++){
46         if(hwloadmode(kb, hw, i)){
47             free(hw);
48             return -1;
49         }
50     }
51     // Make the profile active (if requested)
52     if(apply)
53         hwtonative(kb->profile, hw, modes);
54     // Free the existing profile (if any)
55     free(kb->hw);
56     kb->hw = hw;
57     DELAY_LONG(kb);
58     return 0;
59 }
.fi
.SS "int cmd_hwsave_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 61 of file profile_keyboard\&.c\&.
.PP
References DELAY_LONG, usbdevice::hw, HWMODE_K70, HWMODE_K95, hwprofile::id, IS_K95, hwprofile::light, MD_NAME_LEN, MSG_SIZE, hwprofile::name, nativetohw(), usbdevice::profile, savergb_kb(), and usbsend\&.
.PP
.nf
61                                                                                              {
62     (void)dummy1;
63     (void)dummy2;
64     (void)dummy3;
65     (void)dummy4;
66 
67     DELAY_LONG(kb);
68     hwprofile* hw = kb->hw;
69     if(!hw)
70         hw = kb->hw = calloc(1, sizeof(hwprofile));
71     int modes = (IS_K95(kb) ? HWMODE_K95 : HWMODE_K70);
72     nativetohw(kb->profile, hw, modes);
73     // Save the profile and mode names
74     uchar data_pkt[2][MSG_SIZE] = {
75         { 0x07, 0x16, 0x01, 0 },
76         { 0x07, 0x15, 0x01, 0 },
77     };
78     // Save the mode names
79     for(int i = 0; i <= modes; i++){
80         data_pkt[0][3] = i;
81         memcpy(data_pkt[0] + 4, hw->name[i], MD_NAME_LEN * 2);
82         if(!usbsend(kb, data_pkt[0], 1))
83             return -1;
84     }
85     // Save the IDs
86     for(int i = 0; i <= modes; i++){
87         data_pkt[1][3] = i;
88         memcpy(data_pkt[1] + 4, hw->id + i, sizeof(usbid));
89         if(!usbsend(kb, data_pkt[1], 1))
90             return -1;
91     }
92     // Save the RGB data
93     for(int i = 0; i < modes; i++){
94         if(savergb_kb(kb, hw->light + i, i))
95             return -1;
96     }
97     DELAY_LONG(kb);
98     return 0;
99 }
.fi
.SS "static int hwloadmode (\fBusbdevice\fP *kb, \fBhwprofile\fP *hw, intmode)\fC [static]\fP"

.PP
Definition at line 5 of file profile_keyboard\&.c\&.
.PP
References hwprofile::light, loadrgb_kb(), MD_NAME_LEN, MSG_SIZE, hwprofile::name, and usbrecv\&.
.PP
Referenced by cmd_hwload_kb()\&.
.PP
.nf
5                                                              {
6     // Ask for mode's name
7     uchar data_pkt[MSG_SIZE] = { 0x0e, 0x16, 0x01, mode + 1, 0 };
8     uchar in_pkt[MSG_SIZE];
9     if(!usbrecv(kb, data_pkt, in_pkt))
10         return -1;
11     memcpy(hw->name[mode + 1], in_pkt + 4, MD_NAME_LEN * 2);
12     // Load the RGB setting
13     return loadrgb_kb(kb, hw->light + mode, mode);
14 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
