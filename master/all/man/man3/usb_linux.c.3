.TH "src/ckb-daemon/usb_linux.c" 3 "Tue May 16 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/usb_linux.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_model\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTEST_RESET\fP(op)"
.br
.ti -1c
.RI "#define \fBN_MODELS\fP   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBos_usbsend\fP (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, int is_recv, const char *file, int line)"
.br
.ti -1c
.RI "int \fBos_usbrecv\fP (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, int line)"
.br
.ti -1c
.RI "int \fB_nk95cmd\fP (\fBusbdevice\fP *kb, \fBuchar\fP bRequest, \fBushort\fP wValue, const char *file, int line)"
.br
.ti -1c
.RI "void \fBos_sendindicators\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void * \fBos_inputmain\fP (void *context)"
.br
.ti -1c
.RI "int \fBusbunclaim\fP (\fBusbdevice\fP *kb, int resetting)"
.br
.ti -1c
.RI "void \fBos_closeusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBusbclaim\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBos_resetusb\fP (\fBusbdevice\fP *kb, const char *file, int line)"
.br
.ti -1c
.RI "void \fBstrtrim\fP (char *string)"
.br
.ti -1c
.RI "int \fBos_setupusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBusbadd\fP (struct udev_device *dev, short vendor, short product)"
.br
.ti -1c
.RI "static int \fBusb_add_device\fP (struct udev_device *dev)"
.br
.ti -1c
.RI "static void \fBusb_rm_device\fP (struct udev_device *dev)"
.br
.ti -1c
.RI "static void \fBudev_enum\fP ()"
.br
.ti -1c
.RI "int \fBusbmain\fP ()"
.br
.ti -1c
.RI "void \fBusbkill\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static char \fBkbsyspath\fP [9][FILENAME_MAX]"
.br
.ti -1c
.RI "static struct udev * \fBudev\fP"
.br
.ti -1c
.RI "pthread_t \fBusbthread\fP"
.br
.ti -1c
.RI "pthread_t \fBudevthread\fP"
.br
.ti -1c
.RI "static \fB_model\fP \fBmodels\fP []"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct _model"
.PP 
Definition at line 355 of file usb_linux\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
const char * \fIname\fP 
.br
.PP
short \fInumber\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define N_MODELS   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"

.PP
Definition at line 386 of file usb_linux\&.c\&.
.PP
Referenced by usb_add_device()\&.
.SS "#define TEST_RESET(op)"
\fBValue:\fP
.PP
.nf
if(op){                                                                 \\
        ckb_err_fn("resetusb failed: %s\n", file, line, strerror(errno));   \
        if(errno == EINTR || errno == EAGAIN)                               \
            return -1;              /* try again if status code says so */  \
        return -2;                  /* else, remove device */               \
    }
.fi
.PP
Definition at line 237 of file usb_linux\&.c\&.
.PP
Referenced by os_resetusb()\&.
.SH "Function Documentation"
.PP 
.SS "int _nk95cmd (\fBusbdevice\fP *kb, \fBuchar\fPbRequest, \fBushort\fPwValue, const char *file, intline)"

.PP
Definition at line 74 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, usbdevice::handle, P_K95_NRGB, and usbdevice::product\&.
.PP
.nf
74                                                                                       {
75     if(kb->product != P_K95_NRGB)
76         return 0;
77     struct usbdevfs_ctrltransfer transfer = { 0x40, bRequest, wValue, 0, 0, 5000, 0 };
78     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
79     if(res <= 0){
80         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
81         return 1;
82     }
83     return 0;
84 }
.fi
.SS "void os_closeusb (\fBusbdevice\fP *kb)"

.PP
Definition at line 214 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, INDEX_OF, kbsyspath, keyboard, usbdevice::udev, and usbunclaim()\&.
.PP
Referenced by closeusb()\&.
.PP
.nf
214                                {
215     if(kb->handle){
216         usbunclaim(kb, 0);
217         close(kb->handle - 1);
218     }
219     if(kb->udev)
220         udev_device_unref(kb->udev);
221     kb->handle = 0;
222     kb->udev = 0;
223     kbsyspath[INDEX_OF(kb, keyboard)][0] = 0;
224 }
.fi
.SS "void* os_inputmain (void *context)"

.PP
Definition at line 93 of file usb_linux\&.c\&.
.PP
References usbdevice::active, ckb_info, corsair_kbcopy(), corsair_mousecopy(), devpath, usbdevice::epcount, usbdevice::handle, hid_kb_translate(), hid_mouse_translate(), imutex, INDEX_OF, usbdevice::input, inputupdate(), IS_MOUSE, IS_RGB, keyboard, usbinput::keys, MSG_SIZE, usbdevice::product, usbinput::rel_x, usbinput::rel_y, and usbdevice::vendor\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
93                                  {
94     usbdevice* kb = context;
95     int fd = kb->handle - 1;
96     short vendor = kb->vendor, product = kb->product;
97     int index = INDEX_OF(kb, keyboard);
98     ckb_info("Starting input thread for %s%d\n", devpath, index);
99 
100     // Monitor input transfers on all endpoints for non-RGB devices
101     // For RGB, monitor all but the last, as it's used for input/output
102     int urbcount = IS_RGB(vendor, product) ? (kb->epcount - 1) : kb->epcount;
103     struct usbdevfs_urb urbs[urbcount];
104     memset(urbs, 0, sizeof(urbs));
105     urbs[0]\&.buffer_length = 8;
106     if(IS_RGB(vendor, product)){
107         if(IS_MOUSE(vendor, product))
108             urbs[1]\&.buffer_length = 10;
109         else
110             urbs[1]\&.buffer_length = 21;
111         urbs[2]\&.buffer_length = MSG_SIZE;
112         if(urbcount != 3)
113             urbs[urbcount - 1]\&.buffer_length = MSG_SIZE;
114     } else {
115         urbs[1]\&.buffer_length = 4;
116         urbs[2]\&.buffer_length = 15;
117     }
118     // Submit URBs
119     for(int i = 0; i < urbcount; i++){
120         urbs[i]\&.type = USBDEVFS_URB_TYPE_INTERRUPT;
121         urbs[i]\&.endpoint = 0x80 | (i + 1);
122         urbs[i]\&.buffer = malloc(urbs[i]\&.buffer_length);
123         ioctl(fd, USBDEVFS_SUBMITURB, urbs + i);
124     }
125     // Start monitoring input
126     while(1){
127         struct usbdevfs_urb* urb = 0;
128         if(ioctl(fd, USBDEVFS_REAPURB, &urb)){
129             if(errno == ENODEV || errno == ENOENT || errno == ESHUTDOWN)
130                 // Stop the thread if the handle closes
131                 break;
132             else if(errno == EPIPE && urb){
133                 // On EPIPE, clear halt on the endpoint
134                 ioctl(fd, USBDEVFS_CLEAR_HALT, &urb->endpoint);
135                 // Re-submit the URB
136                 if(urb)
137                     ioctl(fd, USBDEVFS_SUBMITURB, urb);
138                 urb = 0;
139             }
140         }
141         if(urb){
142             // Process input (if any)
143             pthread_mutex_lock(imutex(kb));
144             if(IS_MOUSE(vendor, product)){
145                 switch(urb->actual_length){
146                 case 8:
147                 case 10:
148                 case 11:
149                     // HID mouse input
150                     hid_mouse_translate(kb->input\&.keys, &kb->input\&.rel_x, &kb->input\&.rel_y, -(urb->endpoint & 0xF), urb->actual_length, urb->buffer);
151                     break;
152                 case MSG_SIZE:
153                     // Corsair mouse input
154                     corsair_mousecopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
155                     break;
156                 }
157             } else if(IS_RGB(vendor, product)){
158                 switch(urb->actual_length){
159                 case 8:
160                     // RGB EP 1: 6KRO (BIOS mode) input
161                     hid_kb_translate(kb->input\&.keys, -1, urb->actual_length, urb->buffer);
162                     break;
163                 case 21:
164                 case 5:
165                     // RGB EP 2: NKRO (non-BIOS) input\&. Accept only if keyboard is inactive
166                     if(!kb->active)
167                         hid_kb_translate(kb->input\&.keys, -2, urb->actual_length, urb->buffer);
168                     break;
169                 case MSG_SIZE:
170                     // RGB EP 3: Corsair input
171                     corsair_kbcopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
172                     break;
173                 }
174             } else
175                 // Non-RGB input
176                 hid_kb_translate(kb->input\&.keys, urb->endpoint & 0xF, urb->actual_length, urb->buffer);
177             inputupdate(kb);
178             pthread_mutex_unlock(imutex(kb));
179             // Re-submit the URB
180             ioctl(fd, USBDEVFS_SUBMITURB, urb);
181             urb = 0;
182         }
183     }
184     // Clean up
185     ckb_info("Stopping input thread for %s%d\n", devpath, index);
186     for(int i = 0; i < urbcount; i++){
187         ioctl(fd, USBDEVFS_DISCARDURB, urbs + i);
188         free(urbs[i]\&.buffer);
189     }
190     return 0;
191 }
.fi
.SS "int os_resetusb (\fBusbdevice\fP *kb, const char *file, intline)"

.PP
Definition at line 245 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, TEST_RESET, usbclaim(), and usbunclaim()\&.
.PP
Referenced by _resetusb()\&.
.PP
.nf
245                                                           {
246     TEST_RESET(usbunclaim(kb, 1));
247     TEST_RESET(ioctl(kb->handle - 1, USBDEVFS_RESET));
248     TEST_RESET(usbclaim(kb));
249     // Success!
250     return 0;
251 }
.fi
.SS "void os_sendindicators (\fBusbdevice\fP *kb)"

.PP
Definition at line 86 of file usb_linux\&.c\&.
.PP
References ckb_err, usbdevice::handle, and usbdevice::ileds\&.
.PP
Referenced by updateindicators_kb()\&.
.PP
.nf
86                                      {
87     struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, 0x00, 1, 500, &kb->ileds };
88     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
89     if(res <= 0)
90         ckb_err("%s\n", res ? strerror(errno) : "No data written");
91 }
.fi
.SS "int os_setupusb (\fBusbdevice\fP *kb)"

.PP
Definition at line 271 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, ckb_warn, devpath, usbdevice::epcount, FEAT_RGB, usbdevice::fwversion, HAS_FEATURES, INDEX_OF, KB_NAME_LEN, keyboard, usbdevice::name, usbdevice::serial, SERIAL_LEN, strtrim(), usbdevice::udev, and usbclaim()\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
271                               {
272     // Copy device description and serial
273     struct udev_device* dev = kb->udev;
274     const char* name = udev_device_get_sysattr_value(dev, "product");
275     if(name)
276         strncpy(kb->name, name, KB_NAME_LEN);
277     strtrim(kb->name);
278     const char* serial = udev_device_get_sysattr_value(dev, "serial");
279     if(serial)
280         strncpy(kb->serial, serial, SERIAL_LEN);
281     strtrim(kb->serial);
282     // Copy firmware version (needed to determine USB protocol)
283     const char* firmware = udev_device_get_sysattr_value(dev, "bcdDevice");
284     if(firmware)
285         sscanf(firmware, "%hx", &kb->fwversion);
286     else
287         kb->fwversion = 0;
288     int index = INDEX_OF(kb, keyboard);
289     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
290 
291     // Claim the USB interfaces
292     const char* ep_str = udev_device_get_sysattr_value(dev, "bNumInterfaces");
293     kb->epcount = 0;
294     if(ep_str)
295         sscanf(ep_str, "%d", &kb->epcount);
296     if(kb->epcount == 0){
297         // This shouldn't happen, but if it does, assume EP count based on what the device is supposed to have
298         kb->epcount = (HAS_FEATURES(kb, FEAT_RGB) ? 4 : 3);
299         ckb_warn("Unable to read endpoint count from udev, assuming %d\&.\&.\&.\n", kb->epcount);
300     }
301     if(usbclaim(kb)){
302         ckb_err("Failed to claim interfaces: %s\n", strerror(errno));
303         return -1;
304     }
305     return 0;
306 }
.fi
.SS "int os_usbrecv (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, intline)"

.PP
Definition at line 42 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv()\&.
.PP
.nf
42                                                                         {
43     int res;
44     // This is what CUE does, but it doesn't seem to work on linux\&.
45     /*if(kb->fwversion >= 0x130){
46         struct usbdevfs_bulktransfer transfer;
47         memset(&transfer, 0, sizeof(transfer));
48         transfer\&.ep = 0x84;
49         transfer\&.len = MSG_SIZE;
50         transfer\&.timeout = 5000;
51         transfer\&.data = in_msg;
52         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
53     } else {*/
54         struct usbdevfs_ctrltransfer transfer = { 0xa1, 0x01, 0x0300, kb->epcount - 1, MSG_SIZE, 5000, in_msg };
55         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
56     //}
57     if(res <= 0){
58         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data read");
59         if(res == -1 && errno == ETIMEDOUT)
60             return -1;
61         else
62             return 0;
63     } else if(res != MSG_SIZE)
64         ckb_warn_fn("Read %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
65 #ifdef DEBUG_USB_RECV
66     char converted[MSG_SIZE*3 + 1];
67     for(int i=0;i<MSG_SIZE;i++)
68         sprintf(&converted[i*3], "%02x ", in_msg[i]);
69     ckb_warn_fn("Recv %s\n", file, line, converted);
70 #endif
71     return res;
72 }
.fi
.SS "int os_usbsend (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, intis_recv, const char *file, intline)"

.PP
Definition at line 11 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::fwversion, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv(), and _usbsend()\&.
.PP
.nf
11                                                                                             {
12     int res;
13     if(kb->fwversion >= 0x120 && !is_recv){
14         struct usbdevfs_bulktransfer transfer;
15         memset(&transfer, 0, sizeof(transfer));
16         transfer\&.ep = (kb->fwversion >= 0x130 && kb->fwversion < 0x200) ? 4 : 3;
17         transfer\&.len = MSG_SIZE;
18         transfer\&.timeout = 5000;
19         transfer\&.data = (void*)out_msg;
20         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
21     } else {
22         struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, kb->epcount - 1, MSG_SIZE, 5000, (void*)out_msg };
23         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
24     }
25     if(res <= 0){
26         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
27         if(res == -1 && errno == ETIMEDOUT)
28             return -1;
29         else
30             return 0;
31     } else if(res != MSG_SIZE)
32         ckb_warn_fn("Wrote %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
33 #ifdef DEBUG_USB
34     char converted[MSG_SIZE*3 + 1];
35     for(int i=0;i<MSG_SIZE;i++)
36         sprintf(&converted[i*3], "%02x ", out_msg[i]);
37     ckb_warn_fn("Sent %s\n", file, line, converted);
38 #endif
39     return res;
40 }
.fi
.SS "void strtrim (char *string)"

.PP
Definition at line 253 of file usb_linux\&.c\&.
.PP
Referenced by os_setupusb()\&.
.PP
.nf
253                           {
254     // Find last non-space
255     char* last = string;
256     for(char* c = string; *c != 0; c++){
257         if(!isspace(*c))
258             last = c;
259     }
260     last[1] = 0;
261     // Find first non-space
262     char* first = string;
263     for(; *first != 0; first++){
264         if(!isspace(*first))
265             break;
266     }
267     if(first != string)
268         memmove(string, first, last - first);
269 }
.fi
.SS "static void udev_enum ()\fC [static]\fP"

.PP
Definition at line 418 of file usb_linux\&.c\&.
.PP
References usb_add_device(), and V_CORSAIR_STR\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
418                        {
419     struct udev_enumerate* enumerator = udev_enumerate_new(udev);
420     udev_enumerate_add_match_subsystem(enumerator, "usb");
421     udev_enumerate_add_match_sysattr(enumerator, "idVendor", V_CORSAIR_STR);
422     udev_enumerate_scan_devices(enumerator);
423     struct udev_list_entry* devices, *dev_list_entry;
424     devices = udev_enumerate_get_list_entry(enumerator);
425 
426     udev_list_entry_foreach(dev_list_entry, devices){
427         const char* path = udev_list_entry_get_name(dev_list_entry);
428         if(!path)
429             continue;
430         struct udev_device* dev = udev_device_new_from_syspath(udev, path);
431         if(!dev)
432             continue;
433         // If the device matches a recognized device ID, open it
434         if(usb_add_device(dev))
435             // Release device if not
436             udev_device_unref(dev);
437     }
438     udev_enumerate_unref(enumerator);
439 }
.fi
.SS "static int usb_add_device (struct udev_device *dev)\fC [static]\fP"

.PP
Definition at line 389 of file usb_linux\&.c\&.
.PP
References N_MODELS, usbadd(), V_CORSAIR, and V_CORSAIR_STR\&.
.PP
Referenced by udev_enum(), and usbmain()\&.
.PP
.nf
389                                                   {
390     const char* vendor = udev_device_get_sysattr_value(dev, "idVendor");
391     if(vendor && !strcmp(vendor, V_CORSAIR_STR)){
392         const char* product = udev_device_get_sysattr_value(dev, "idProduct");
393         if(product){
394             for(_model* model = models; model < models + N_MODELS; model++){
395                 if(!strcmp(product, model->name)){
396                     return usbadd(dev, V_CORSAIR, model->number);
397                 }
398             }
399         }
400     }
401     return 1;
402 }
.fi
.SS "static void usb_rm_device (struct udev_device *dev)\fC [static]\fP"

.PP
Definition at line 405 of file usb_linux\&.c\&.
.PP
References closeusb(), DEV_MAX, devmutex, kbsyspath, and keyboard\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
405                                                   {
406     // Device removed\&. Look for it in our list of keyboards
407     const char* syspath = udev_device_get_syspath(dev);
408     if(!syspath || syspath[0] == 0)
409         return;
410     for(int i = 1; i < DEV_MAX; i++){
411         pthread_mutex_lock(devmutex + i);
412         if(!strcmp(syspath, kbsyspath[i]))
413             closeusb(keyboard + i);
414         pthread_mutex_unlock(devmutex + i);
415     }
416 }
.fi
.SS "int usbadd (struct udev_device *dev, shortvendor, shortproduct)"

.PP
Definition at line 308 of file usb_linux\&.c\&.
.PP
References ckb_err, DEV_MAX, dmutex, usbdevice::handle, IS_CONNECTED, kbsyspath, keyboard, usbdevice::product, setupusb(), usbdevice::udev, and usbdevice::vendor\&.
.PP
Referenced by usb_add_device()\&.
.PP
.nf
308                                                                 {
309     const char* path = udev_device_get_devnode(dev);
310     const char* syspath = udev_device_get_syspath(dev);
311     if(!path || !syspath || path[0] == 0 || syspath[0] == 0){
312         ckb_err("Failed to get device path\n");
313         return -1;
314     }
315     // Find a free USB slot
316     for(int index = 1; index < DEV_MAX; index++){
317         usbdevice* kb = keyboard + index;
318         if(pthread_mutex_trylock(dmutex(kb))){
319             // If the mutex is locked then the device is obviously in use, so keep going
320             if(!strcmp(syspath, kbsyspath[index])){
321                 // Make sure this existing keyboard doesn't have the same syspath (this shouldn't happen)
322                 return 0;
323             }
324             continue;
325         }
326         if(!IS_CONNECTED(kb)){
327             // Open the sysfs device
328             kb->handle = open(path, O_RDWR) + 1;
329             if(kb->handle <= 0){
330                 ckb_err("Failed to open USB device: %s\n", strerror(errno));
331                 kb->handle = 0;
332                 pthread_mutex_unlock(dmutex(kb));
333                 return -1;
334             } else {
335                 // Set up device
336                 kb->udev = dev;
337                 kb->vendor = vendor;
338                 kb->product = product;
339                 strncpy(kbsyspath[index], syspath, FILENAME_MAX);
340                 // Mutex remains locked
341                 setupusb(kb);
342                 return 0;
343             }
344         }
345         pthread_mutex_unlock(dmutex(kb));
346     }
347     ckb_err("No free devices\n");
348     return -1;
349 }
.fi
.SS "int usbclaim (\fBusbdevice\fP *kb)"

.PP
Definition at line 226 of file usb_linux\&.c\&.
.PP
References usbdevice::epcount, and usbdevice::handle\&.
.PP
Referenced by os_resetusb(), and os_setupusb()\&.
.PP
.nf
226                            {
227     int count = kb->epcount;
228     for(int i = 0; i < count; i++){
229         struct usbdevfs_ioctl ctl = { i, USBDEVFS_DISCONNECT, 0 };
230         ioctl(kb->handle - 1, USBDEVFS_IOCTL, &ctl);
231         if(ioctl(kb->handle - 1, USBDEVFS_CLAIMINTERFACE, &i))
232             return -1;
233     }
234     return 0;
235 }
.fi
.SS "void usbkill ()"

.PP
Definition at line 492 of file usb_linux\&.c\&.
.PP
Referenced by quitWithLock()\&.
.PP
.nf
492               {
493     udev_unref(udev);
494     udev = 0;
495 }
.fi
.SS "int usbmain ()"

.PP
Definition at line 441 of file usb_linux\&.c\&.
.PP
References ckb_fatal, ckb_warn, udev_enum(), usb_add_device(), and usb_rm_device()\&.
.PP
Referenced by main()\&.
.PP
.nf
441              {
442     // Load the uinput module (if it's not loaded already)
443     if(system("modprobe uinput") != 0)
444         ckb_warn("Failed to load uinput module\n");
445 
446     // Create the udev object
447     if(!(udev = udev_new())){
448         ckb_fatal("Failed to initialize udev\n");
449         return -1;
450     }
451 
452     // Enumerate all currently connected devices
453     udev_enum();
454 
455     // Done scanning\&. Enter a loop to poll for device updates
456     struct udev_monitor* monitor = udev_monitor_new_from_netlink(udev, "udev");
457     udev_monitor_filter_add_match_subsystem_devtype(monitor, "usb", 0);
458     udev_monitor_enable_receiving(monitor);
459     // Get an fd for the monitor
460     int fd = udev_monitor_get_fd(monitor);
461     fd_set fds;
462     while(udev){
463         FD_ZERO(&fds);
464         FD_SET(fd, &fds);
465         // Block until an event is read
466         if(select(fd + 1, &fds, 0, 0, 0) > 0 && FD_ISSET(fd, &fds)){
467             struct udev_device* dev = udev_monitor_receive_device(monitor);
468             if(!dev)
469                 continue;
470             const char* action = udev_device_get_action(dev);
471             if(!action){
472                 udev_device_unref(dev);
473                 continue;
474             }
475             // Add/remove device
476             if(!strcmp(action, "add")){
477                 int res = usb_add_device(dev);
478                 if(res == 0)
479                     continue;
480                 // If the device matched but the handle wasn't opened correctly, re-enumerate (this sometimes solves the problem)
481                 if(res == -1)
482                     udev_enum();
483             } else if(!strcmp(action, "remove"))
484                 usb_rm_device(dev);
485             udev_device_unref(dev);
486         }
487     }
488     udev_monitor_unref(monitor);
489     return 0;
490 }
.fi
.SS "int usbunclaim (\fBusbdevice\fP *kb, intresetting)"

.PP
Definition at line 193 of file usb_linux\&.c\&.
.PP
References usbdevice::epcount, FEAT_RGB, usbdevice::handle, and HAS_FEATURES\&.
.PP
Referenced by os_closeusb(), and os_resetusb()\&.
.PP
.nf
193                                             {
194     int handle = kb->handle - 1;
195     int count = kb->epcount;
196     for(int i = 0; i < count; i++)
197         ioctl(handle, USBDEVFS_RELEASEINTERFACE, &i);
198     // For RGB keyboards, the kernel driver should only be reconnected to interfaces 0 and 1 (HID), and only if we're not about to do a USB reset\&.
199     // Reconnecting any of the others causes trouble\&.
200     if(!resetting){
201         struct usbdevfs_ioctl ctl = { 0, USBDEVFS_CONNECT, 0 };
202         ioctl(handle, USBDEVFS_IOCTL, &ctl);
203         ctl\&.ifno = 1;
204         ioctl(handle, USBDEVFS_IOCTL, &ctl);
205         // Also reconnect iface #2 (HID) for non-RGB keyboards
206         if(!HAS_FEATURES(kb, FEAT_RGB)){
207             ctl\&.ifno = 2;
208             ioctl(handle, USBDEVFS_IOCTL, &ctl);
209         }
210     }
211     return 0;
212 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char kbsyspath[9][FILENAME_MAX]\fC [static]\fP"

.PP
Definition at line 9 of file usb_linux\&.c\&.
.PP
Referenced by os_closeusb(), usb_rm_device(), and usbadd()\&.
.SS "\fB_model\fP models[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    
    {  "1b17" ,  0x1b17  },
    {  "1b07" ,  0x1b07  },
    {  "1b37" ,  0x1b37  },
    {  "1b39" ,  0x1b39  },
    {  "1b13" ,  0x1b13  },
    {  "1b09" ,  0x1b09  },
    {  "1b33" ,  0x1b33  },
    {  "1b36" ,  0x1b36  },
    {  "1b38" ,  0x1b38  },
    {  "1b3a" ,  0x1b3a  },
    {  "1b11" ,  0x1b11  },
    {  "1b08" ,  0x1b08  },
    {  "1b2d" ,  0x1b2d  },
    {  "1b20" ,  0x1b20  },
    {  "1b15" ,  0x1b15  },
    
    {  "1b12" ,  0x1b12  },
    {  "1b2e" ,  0x1b2e  },
    {  "1b14" ,  0x1b14   },
    {  "1b19" ,  0x1b19   },
    {  "1b2f" ,  0x1b2f   },
    {  "1b1e" ,  0x1b1e  },
    {  "1b3e" ,  0x1b3e  },
    {  "1b32" ,  0x1b32   }
}
.fi
.PP
Definition at line 359 of file usb_linux\&.c\&.
.SS "struct udev* udev\fC [static]\fP"

.PP
Definition at line 351 of file usb_linux\&.c\&.
.SS "pthread_t udevthread"

.PP
Definition at line 352 of file usb_linux\&.c\&.
.SS "pthread_t usbthread"

.PP
Definition at line 352 of file usb_linux\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
