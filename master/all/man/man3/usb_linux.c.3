.TH "src/ckb-daemon/usb_linux.c" 3 "Fri Nov 3 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/usb_linux.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_model\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEBUG\fP"
.br
.RI "\fIall open usb devices have their system path names here in this array\&. \fP"
.ti -1c
.RI "#define \fBTEST_RESET\fP(op)"
.br
.RI "\fITEST_RESET doesa 'try / catch' for resetting the usb interface\&. \fP"
.ti -1c
.RI "#define \fBN_MODELS\fP   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBos_usbsend\fP (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, int is_recv, const char *file, int line)"
.br
.RI "\fIos_usbsend sends a data packet (MSG_SIZE = 64) Bytes long \fP"
.ti -1c
.RI "int \fBos_usbrecv\fP (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, int line)"
.br
.RI "\fIos_usbrecv receives a max MSGSIZE long buffer from usb device \fP"
.ti -1c
.RI "int \fB_nk95cmd\fP (\fBusbdevice\fP *kb, \fBuchar\fP bRequest, \fBushort\fP wValue, const char *file, int line)"
.br
.RI "\fI_nk95cmd If we control a non RGB keyboard, set the keyboard via ioctl with usbdevfs_ctrltransfer \fP"
.ti -1c
.RI "void \fBos_sendindicators\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void * \fBos_inputmain\fP (void *context)"
.br
.RI "\fIos_inputmain This function is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&. \fP"
.ti -1c
.RI "static int \fBusbunclaim\fP (\fBusbdevice\fP *kb, int resetting)"
.br
.ti -1c
.RI "void \fBos_closeusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "static int \fBusbclaim\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBos_resetusb\fP (\fBusbdevice\fP *kb, const char *file, int line)"
.br
.ti -1c
.RI "void \fBstrtrim\fP (char *string)"
.br
.ti -1c
.RI "int \fBos_setupusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBusbadd\fP (struct udev_device *dev, short vendor, short product)"
.br
.ti -1c
.RI "static int \fBusb_add_device\fP (struct udev_device *dev)"
.br
.RI "\fIAdd a udev device\&. Returns 0 if device was recognized/added\&. \fP"
.ti -1c
.RI "static void \fBusb_rm_device\fP (struct udev_device *dev)"
.br
.RI "\fIusb_rm_device find the usb port to remove and close it via \fBcloseusb()\fP\&. \fP"
.ti -1c
.RI "static void \fBudev_enum\fP ()"
.br
.RI "\fIudev_enum use the udev_enumerate_add_match_subsystem() to get all you need but only that\&. \fP"
.ti -1c
.RI "int \fBusbmain\fP ()"
.br
.ti -1c
.RI "void \fBusbkill\fP ()"
.br
.RI "\fIStop the USB system\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static char \fBkbsyspath\fP [9][FILENAME_MAX]"
.br
.ti -1c
.RI "static struct udev * \fBudev\fP"
.br
.RI "\fIstruct udef is defined in /usr/include/libudev\&.h \fP"
.ti -1c
.RI "pthread_t \fBusbthread\fP"
.br
.ti -1c
.RI "pthread_t \fBudevthread\fP"
.br
.ti -1c
.RI "static \fB_model\fP \fBmodels\fP []"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct _model"
.PP 
Definition at line 645 of file usb_linux\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
const char * \fIname\fP 
.br
.PP
short \fInumber\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define DEBUG"

.PP
Definition at line 11 of file usb_linux\&.c\&.
.SS "#define N_MODELS   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"

.PP
Definition at line 685 of file usb_linux\&.c\&.
.PP
Referenced by usb_add_device()\&.
.SS "#define TEST_RESET(op)"
\fBValue:\fP
.PP
.nf
if(op){                                                                 \\
        ckb_err_fn("resetusb failed: %s\n", file, line, strerror(errno));   \
        if(errno == EINTR || errno == EAGAIN)                               \
            return -1;              /* try again if status code says so */  \
        return -2;                  /* else, remove device */               \
    }
.fi
.PP
Definition at line 479 of file usb_linux\&.c\&.
.PP
Referenced by os_resetusb()\&.
.SH "Function Documentation"
.PP 
.SS "int _nk95cmd (\fBusbdevice\fP *kb, \fBuchar\fPbRequest, \fBushort\fPwValue, const char *file, intline)"
To send control packets to a non RGB non color K95 Keyboard, use this function\&. Normally it is called via the \fBnk95cmd()\fP macro\&.
.PP
If it is the wrong device for which the function is called, 0 is returned and nothing done\&. Otherwise a usbdevfs_ctrltransfer structure is filled and an USBDEVFS_CONTROL ioctl() called\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x40 see table below to switch hardware-modus at Keyboard wValue device MSG_SIZE 5ms the message buffer pointer Host to Device, Type=Vendor, Recipient=Device bRequest parameter given wValue Parameter device 0 0 data to write 5000 null If a 0 or a negative error number is returned by the ioctl, an error message is shown depending on the errno or 'No data written' if retval was 0\&. In either case 1 is returned to indicate the error\&. If the ioctl returned a value > 0, 0 is returned to indicate no error\&.
.PP
Currently the following combinations for bRequest and wValue are used: Device what it might to do constant bRequest wValue  non RGB Keyboard set HW-modus on (leave the ckb driver) HWON 0x0002 0x0030 non RGB Keyboard set HW-modus off (initialize the ckb driver) HWOFF 0x0002 0x0001 non RGB Keyboard set light modus M1 in single-color keyboards NK95_M1 0x0014 0x0001 non RGB Keyboard set light modus M2 in single-color keyboards NK95_M2 0x0014 0x0002 non RGB Keyboard set light modus M3 in single-color keyboards NK95_M3 0x0014 0x0003 
.PP
\fBSee Also:\fP
.RS 4
\fBusb\&.h\fP 
.RE
.PP

.PP
Definition at line 188 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, usbdevice::handle, P_K95_NRGB, and usbdevice::product\&.
.PP
.nf
188                                                                                       {
189     if(kb->product != P_K95_NRGB)
190         return 0;
191     struct usbdevfs_ctrltransfer transfer = { 0x40, bRequest, wValue, 0, 0, 5000, 0 };
192     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
193     if(res <= 0){
194         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
195         return 1;
196     }
197     return 0;
198 }
.fi
.SS "void os_closeusb (\fBusbdevice\fP *kb)"
os_closeusb unclaim it, destroy the udev device and clear data structures at kb
.PP
os_closeusb is the linux specific implementation for closing an active usb port\&. 
.br
 If a valid handle is given in the kb structure, the usb port is unclaimed (\fBusbunclaim()\fP)\&. 
.br
 The device in unrefenced via library function udev_device_unref()\&. 
.br
 handle, udev and the first char of kbsyspath are cleared to 0 (empty string for kbsyspath)\&. 
.PP
Definition at line 435 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, INDEX_OF, kbsyspath, keyboard, usbdevice::udev, and usbunclaim()\&.
.PP
Referenced by closeusb()\&.
.PP
.nf
435                                {
436     if(kb->handle){
437         usbunclaim(kb, 0);
438         close(kb->handle - 1);
439     }
440     if(kb->udev)
441         udev_device_unref(kb->udev);
442     kb->handle = 0;
443     kb->udev = 0;
444     kbsyspath[INDEX_OF(kb, keyboard)][0] = 0;
445 }
.fi
.SS "void* os_inputmain (void *context)"
os_inputmain is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&.
.PP
\fBTodo\fP
.RS 4
This function is a collection of many tasks\&. It should be divided into several sub-functions for the sake of greater convenience:
.RE
.PP
.PP
.IP "1." 4
set up an URB (Userspace Ressource Buffer) to communicate with the USBDEVFS_* ioctl()s
.IP "2." 4
perform the ioctl()
.IP "3." 4
interpretate the information got into the URB buffer or handle error situations and retry operation or leave the endless loop
.IP "4." 4
inform the os about the data
.IP "5." 4
loop endless via 2\&.
.IP "6." 4
if endless loop has gone, deinitalize the interface, free buffers etc\&.
.IP "7." 4
return null 
.PP
Here the actions in detail:
.PP
Monitor input transfers on all endpoints for non-RGB devices For RGB, monitor all but the last, as it's used for input/output
.PP
Get an usbdevfs_urb data structure and clear it via memset()
.PP
Hopefully the buffer lengths are equal for all devices with congruent types\&. You can find out the correctness for your device with lsusb --v or similar on macOS\&. Currently the following combinations are known and implemented:
.PP
device detect with macro combination endpoint # buffer-length  each none 0 8 RGB Mouse IS_RGB && IS_MOUSE 1 10 RGB Keyboard IS_RGB && !IS_MOUSE 1 21 RGB Mouse or Keyboard IS_RGB 2 MSG_SIZE (64) non RGB Mouse or Keyboard !IS_RGB 1 4 non RGB Mouse or Keyboard !IS_RGB 2 15 
.PP
Now submit all the URBs via ioctl(USBDEVFS_SUBMITURB) with type USBDEVFS_URB_TYPE_INTERRUPT (the endpoints are defined as type interrupt)\&. Endpoint number is 0x80\&.\&.0x82 or 0x83, depending on the model\&.
.PP
The userSpaceFS knows the URBs now, so start monitoring input
.PP
if the ioctl returns something != 0, let's have a deeper look what happened\&. Broken devices or shutting down the entire system leads to closing the device and finishing this thread\&.
.PP
If just an EPIPE ocurred, give the device a CLEAR_HALT and resubmit the URB\&.
.PP
A correct REAPURB returns a Pointer to the URB which we now have a closer look into\&. Lock all following actions with imutex\&.
.PP
Process the input depending on type of device\&. Interprete the actual size of the URB buffer
.PP
device detect with macro combination seems to be endpoint # actual buffer-length function called  mouse (RGB and non RGB) IS_MOUSE nA 8, 10 or 11 \fBhid_mouse_translate()\fP mouse (RGB and non RGB) IS_MOUSE nA MSG_SIZE (64) \fBcorsair_mousecopy()\fP RGB Keyboard IS_RGB && !IS_MOUSE 1 8 (BIOS Mode) \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 2 5 or 21, KB inactive! \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 3? MSG_SIZE \fBcorsair_kbcopy()\fP non RGB Keyboard !IS_RGB && !IS_MOUSE nA nA \fBhid_kb_translate()\fP 
.PP
The input data is transformed and copied to the kb structure\&. Now give it to the OS and unlock the imutex afterwards\&.
.PP
Re-submit the URB for the next run\&.
.PP
If the endless loop is terminated, clean up by discarding the URBs via ioctl(USBDEVFS_DISCARDURB), free the URB buffers and return a null pointer as thread exit code\&. 
.PP
Definition at line 238 of file usb_linux\&.c\&.
.PP
References usbdevice::active, ckb_err, ckb_info, corsair_kbcopy(), corsair_mousecopy(), devpath, usbdevice::epcount, usbdevice::handle, hid_kb_translate(), hid_mouse_translate(), imutex, INDEX_OF, usbdevice::input, inputupdate(), IS_MOUSE, IS_RGB, keyboard, usbinput::keys, MSG_SIZE, usbdevice::product, usbinput::rel_x, usbinput::rel_y, and usbdevice::vendor\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
238                                  {
239     usbdevice* kb = context;
240     int fd = kb->handle - 1;
241     short vendor = kb->vendor, product = kb->product;
242     int index = INDEX_OF(kb, keyboard);
243     ckb_info("Starting input thread for %s%d\n", devpath, index);
244 
249     int urbcount = IS_RGB(vendor, product) ? (kb->epcount - 1) : kb->epcount;
250     if (urbcount == 0) {
251         ckb_err("urbcount = 0, so there is nothing to claim in os_inputmain()\n");
252         return 0;
253     }
254 
256     struct usbdevfs_urb urbs[urbcount + 1];
257     memset(urbs, 0, sizeof(urbs));
258 
272     urbs[0]\&.buffer_length = 8;
273     if(urbcount > 1 && IS_RGB(vendor, product)) {
274         if(IS_MOUSE(vendor, product))
275             urbs[1]\&.buffer_length = 10;
276         else
277             urbs[1]\&.buffer_length = 21;
278         urbs[2]\&.buffer_length = MSG_SIZE;
279         if(urbcount != 3)
280             urbs[urbcount - 1]\&.buffer_length = MSG_SIZE;
281     } else {
282         urbs[1]\&.buffer_length = 4;
283         urbs[2]\&.buffer_length = 15;
284     }
285 
288     for(int i = 0; i < urbcount; i++){
289         urbs[i]\&.type = USBDEVFS_URB_TYPE_INTERRUPT;
290         urbs[i]\&.endpoint = 0x80 | (i + 1);
291         urbs[i]\&.buffer = malloc(urbs[i]\&.buffer_length);
292         ioctl(fd, USBDEVFS_SUBMITURB, urbs + i);
293     }
294 
296     while (1) {
297         struct usbdevfs_urb* urb = 0;
298 
301         if (ioctl(fd, USBDEVFS_REAPURB, &urb)) {
302             if (errno == ENODEV || errno == ENOENT || errno == ESHUTDOWN)
303                 // Stop the thread if the handle closes
304                 break;
305             else if(errno == EPIPE && urb){
307                 ioctl(fd, USBDEVFS_CLEAR_HALT, &urb->endpoint);
308                 // Re-submit the URB
309                 if(urb)
310                     ioctl(fd, USBDEVFS_SUBMITURB, urb);
311                 urb = 0;
312             }
313             continue;
314         }
315 
319         if (urb) {
320 
332             pthread_mutex_lock(imutex(kb));
333             if(IS_MOUSE(vendor, product)){
334                 switch(urb->actual_length){
335                 case 8:
336                 case 10:
337                 case 11:
338                     // HID mouse input
339                     hid_mouse_translate(kb->input\&.keys, &kb->input\&.rel_x, &kb->input\&.rel_y, -(urb->endpoint & 0xF), urb->actual_length, urb->buffer);
340                     break;
341                 case MSG_SIZE:
342                     // Corsair mouse input
343                     corsair_mousecopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
344                     break;
345                 }
346             } else if(IS_RGB(vendor, product)){
347                 switch(urb->actual_length){
348                 case 8:
349                     // RGB EP 1: 6KRO (BIOS mode) input
350                     hid_kb_translate(kb->input\&.keys, -1, urb->actual_length, urb->buffer);
351                     break;
352                 case 21:
353                 case 5:
354                     // RGB EP 2: NKRO (non-BIOS) input\&. Accept only if keyboard is inactive
355                     if(!kb->active)
356                         hid_kb_translate(kb->input\&.keys, -2, urb->actual_length, urb->buffer);
357                     break;
358                 case MSG_SIZE:
359                     // RGB EP 3: Corsair input
360                     corsair_kbcopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
361                     break;
362                 }
363             } else {
364                 // Non-RGB input
365                 hid_kb_translate(kb->input\&.keys, urb->endpoint & 0xF, urb->actual_length, urb->buffer);
366             }
369             inputupdate(kb);
370             pthread_mutex_unlock(imutex(kb));
371 
373             ioctl(fd, USBDEVFS_SUBMITURB, urb);
374             urb = 0;
375         }
376     }
377 
381     ckb_info("Stopping input thread for %s%d\n", devpath, index);
382     for(int i = 0; i < urbcount; i++){
383         ioctl(fd, USBDEVFS_DISCARDURB, urbs + i);
384         free(urbs[i]\&.buffer);
385     }
386     return 0;
387 }
.fi
.SS "int os_resetusb (\fBusbdevice\fP *kb, const char *file, intline)"
os_resetusb is the os specific implementation for resetting usb
.PP
Try to reset an usb device in a linux user space driver\&.
.IP "1." 4
unclaim the device, but do not reconnect the system driver (second param resetting = true)
.IP "2." 4
reset the device via USBDEVFS_RESET command
.IP "3." 4
claim the device again\&. Returns 0 on success, -2 if device should be removed and -1 if reset should by tried again
.PP
.PP
\fBTodo\fP
.RS 4
it seems that no one wants to try the reset again\&. But I'v seen it somewhere\&.\&.\&. 
.RE
.PP

.PP
Definition at line 497 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, TEST_RESET, usbclaim(), and usbunclaim()\&.
.PP
Referenced by _resetusb()\&.
.PP
.nf
497                                                            {
498     TEST_RESET(usbunclaim(kb, 1));
499     TEST_RESET(ioctl(kb->handle - 1, USBDEVFS_RESET));
500     TEST_RESET(usbclaim(kb));
501     // Success!
502     return 0;
503 }
.fi
.SS "void os_sendindicators (\fBusbdevice\fP *kb)"
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
Read the data from kb->ileds ans send them via ioctl() to the keyboard\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 Interface 0 MSG_SIZE 1 Byte timeout 0,5ms the message buffer pointer Host to Device, Type=Class, Recipient=Interface (why not endpoint?) 9 = SEND? specific 0 1 500 struct* kb->ileds 
.br
 The ioctl command is USBDEVFS_CONTROL\&. 
.PP
Definition at line 213 of file usb_linux\&.c\&.
.PP
References ckb_err, usbdevice::handle, usbdevice::ileds, and usb_tryreset()\&.
.PP
Referenced by updateindicators_kb()\&.
.PP
.nf
213                                       {
214     static int countForReset = 0;
215     struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, 0x00, 1, 500, &kb->ileds };
216     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
217     if(res <= 0) {
218         ckb_err("%s\n", res ? strerror(errno) : "No data written");
219         if (usb_tryreset(kb) == 0 && countForReset++ < 3) {
220             os_sendindicators(kb);
221         }
222     }
223 }
.fi
.SS "int os_setupusb (\fBusbdevice\fP *kb)"
os_setupusb OS-specific setup for a specific usb device\&.
.PP
Perform the operating system-specific opening of the interface in \fBos_setupusb()\fP\&. As a result, some parameters should be set in kb (name, serial, fwversion, epcount = number of usb endpoints), and all endpoints should be claimed with \fBusbclaim()\fP\&. Claiming is the only point where \fBos_setupusb()\fP can produce an error (-1)\&. 
.IP "\(bu" 2
Copy device description and serial
.IP "\(bu" 2
Copy firmware version (needed to determine USB protocol)
.IP "\(bu" 2
Do some output about connecting interfaces
.IP "\(bu" 2
Claim the USB interfaces
.PP
.PP
\fBTodo\fP
.RS 4
in these modules a pullrequest is outstanding 
.RE
.PP
.PP
< Try to reset the device and recall the function
.PP
< Don't do this endless in recursion
.PP
< \fBos_setupusb()\fP has a return value (used as boolean) 
.PP
Definition at line 535 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, devpath, usbdevice::epcount, usbdevice::fwversion, INDEX_OF, KB_NAME_LEN, keyboard, usbdevice::name, usbdevice::serial, SERIAL_LEN, strtrim(), usbdevice::udev, usb_tryreset(), and usbclaim()\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
535                                {
538     struct udev_device* dev = kb->udev;
539     const char* name = udev_device_get_sysattr_value(dev, "product");
540     if(name)
541         strncpy(kb->name, name, KB_NAME_LEN);
542     strtrim(kb->name);
543     const char* serial = udev_device_get_sysattr_value(dev, "serial");
544     if(serial)
545         strncpy(kb->serial, serial, SERIAL_LEN);
546     strtrim(kb->serial);
549     const char* firmware = udev_device_get_sysattr_value(dev, "bcdDevice");
550     if(firmware)
551         sscanf(firmware, "%hx", &kb->fwversion);
552     else
553         kb->fwversion = 0;
554     int index = INDEX_OF(kb, keyboard);
555 
557     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
558 
564     const char* ep_str = udev_device_get_sysattr_value(dev, "bNumInterfaces");
565 #ifdef DEBUG
566     ckb_info("claiming interfaces\&. name=%s, firmware=%s; Got >>%s<< as ep_str\n", name, firmware, ep_str);
567 #endif //DEBUG
568     kb->epcount = 0;
569     if(ep_str)
570         sscanf(ep_str, "%d", &kb->epcount);
571     if(kb->epcount < 2){
572         // IF we have an RGB KB with 0 or 1 endpoints, it will be in BIOS mode\&.
573         ckb_err("Unable to read endpoint count from udev, assuming %d and reading >>%s<< or device is in BIOS mode\n", kb->epcount, ep_str);
574         if (usb_tryreset(kb) == 0) { 
575             static int retryCount = 0; 
576             if (retryCount++ < 5) {
577                 return os_setupusb(kb); 
578             }
579         }
580         return -1;
581         // ToDo are there special versions we have to detect? If there are, that was the old code to handle it:
582         // This shouldn't happen, but if it does, assume EP count based onckb_warn what the device is supposed to have
583         // kb->epcount = (HAS_FEATURES(kb, FEAT_RGB) ? 4 : 3);
584         // ckb_warn("Unable to read endpoint count from udev, assuming %d and reading >>%s<<\&.\&.\&.\n", kb->epcount, ep_str);
585     }
586     if(usbclaim(kb)){
587         ckb_err("Failed to claim interfaces: %s\n", strerror(errno));
588         return -1;
589     }
590     return 0;
591 }
.fi
.SS "int os_usbrecv (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, intline)"
os_usbrecv does what its name says:
.PP
The comment at the beginning of the procedure causes the suspicion that the firmware versionspecific distinction is missing for receiving from usb endpoint 3 or 4\&. The commented code contains only the reception from EP4, but this may be wrong for a software version 2\&.0 or higher (see the code for os-usbsend ())\&.
.PP

.br
 So all the receiving is done via an ioctl() like in os_usbsend\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0xA1 0x01 0x0200 endpoint to be addressed from epcount - 1 MSG_SIZE 5ms the message buffer pointer Device to Host, Type=Class, Recipient=Interface 1 = RECEIVE? specific Interface # 64 5000 in_msg The ioctl() returns the number of bytes received\&. Here is the usual check again:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbrecv()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes are received, 0 is returned as an identifier for a heavy error\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes received\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Read YY bytes (expected 64)']\&. 
.PP
Definition at line 129 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv()\&.
.PP
.nf
129                                                                         {
130     int res;
131     // This is what CUE does, but it doesn't seem to work on linux\&.
132     /*if(kb->fwversion >= 0x130){
133         struct usbdevfs_bulktransfer transfer = {0};
134         transfer\&.ep = 0x84;
135         transfer\&.len = MSG_SIZE;
136         transfer\&.timeout = 5000;
137         transfer\&.data = in_msg;
138         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
139     } else {*/
140         struct usbdevfs_ctrltransfer transfer = { 0xa1, 0x01, 0x0300, kb->epcount - 1, MSG_SIZE, 5000, in_msg };
141         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
142     //}
143     if(res <= 0){
144         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data read");
145         if(res == -1 && errno == ETIMEDOUT)
146             return -1;
147         else
148             return 0;
149     } else if(res != MSG_SIZE)
150         ckb_warn_fn("Read %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
151 #ifdef DEBUG_USB_RECV
152     char converted[MSG_SIZE*3 + 1];
153     for(int i=0;i<MSG_SIZE;i++)
154         sprintf(&converted[i*3], "%02x ", in_msg[i]);
155     ckb_warn_fn("Recv %s\n", file, line, converted);
156 #endif
157     return res;
158 }
.fi
.SS "int os_usbsend (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, intis_recv, const char *file, intline)"
os_usbsend has two functions:
.IP "\(bu" 2
if is_recv == false, it tries to send a given MSG_SIZE buffer via the usb interface given with kb\&.
.IP "\(bu" 2
otherwise a request is sent via the usb device to initiate the receiving of a message from the remote device\&.
.PP
.PP
The functionality for sending distinguishes two cases, depending on the version number of the firmware of the connected device: 
.br
 If the firmware is less or equal 1\&.2, the transmission is done via an ioctl()\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 endpoint / IF to be addressed from epcount-1 MSG_SIZE 5000 (=5ms) the message buffer pointer Host to Device, Type=Class, Recipient=Interface 9 = Send data? specific last or pre-last device # 64 5000 out_msg 
.br
 The ioctl command is USBDEVFS_CONTROL\&.
.PP
The same constellation is used if the device is requested to send its data (is_recv = true)\&.
.PP
For a more recent firmware and is_recv = false, the ioctl command USBDEVFS_CONTROL is not used (this tells the bus to enter the control mode), but the bulk method is used: USBDEVFS_BULK\&. This is astonishing, because all of the endpoints are type Interrupt, not bulk\&.
.PP
Anyhow, forthis purpose a different structure is used for the ioctl() (struct \fBusbdevfs_bulktransfer\fP) and this is also initialized differently: 
.br
 The length and timeout parameters are given the same values as above\&. The formal parameter out_msg is also passed as a buffer pointer\&. For the endpoints, the firmware version is differentiated again: 
.br
 For a firmware version between 1\&.3 and <2\&.0 endpoint 4 is used, otherwise (it can only be >=2\&.0) endpoint 3 is used\&.
.PP
\fBTodo\fP
.RS 4
Since the handling of endpoints has already led to problems elsewhere, this implementation is extremely hardware-dependent and critical! 
.br
 Eg\&. the new keyboard K95PLATINUMRGB has a version number significantly less than 2\&.0 - will it run with this implementation?
.RE
.PP
.PP
The ioctl() - no matter what type - returns the number of bytes sent\&. Now comes the usual check:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbsend()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes sent, 0 is returned as a heavy error identifier\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes sent\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Wrote YY bytes (expected 64)']\&.
.PP
If DEBUG_USB_SEND is set during compilation, the number of bytes sent and their representation are logged to the error channel\&. 
.PP
Definition at line 68 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::fwversion, usbdevice::handle, IS_NEW_PROTOCOL, and MSG_SIZE\&.
.PP
Referenced by _usbrecv(), and _usbsend()\&.
.PP
.nf
68                                                                                              {
69     int res;
70     if ((kb->fwversion >= 0x120 || IS_NEW_PROTOCOL(kb)) && !is_recv){
71         struct usbdevfs_bulktransfer transfer = {0};
72         transfer\&.ep = (kb->fwversion >= 0x130 && kb->fwversion < 0x200) ? 4 : 3;
73         transfer\&.len = MSG_SIZE;
74         transfer\&.timeout = 5000;
75         transfer\&.data = (void*)out_msg;
76         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
77     } else {
78         struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, kb->epcount - 1, MSG_SIZE, 5000, (void*)out_msg };
79         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
80     }
81 
82     if (res <= 0){
83         ckb_err_fn(" %s, res = 0x%x\n", file, line, res ? strerror(errno) : "No data written", res);
84         if(res == -1 && errno == ETIMEDOUT)
85             return -1;
86         else
87             return 0;
88     } else if (res != MSG_SIZE)
89         ckb_warn_fn("Wrote %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
90 #ifdef DEBUG_USB_SEND
91     char converted[MSG_SIZE*3 + 1];
92     for(int i=0;i<MSG_SIZE;i++)
93         sprintf(&converted[i*3], "%02x ", out_msg[i]);
94     ckb_warn_fn("Sent %s\n", file, line, converted);
95 #endif
96     return res;
97 }
.fi
.SS "void strtrim (char *string)"
strtrim trims a string by removing leading and trailing spaces\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP 
.RE
.PP

.PP
Definition at line 510 of file usb_linux\&.c\&.
.PP
Referenced by os_setupusb()\&.
.PP
.nf
510                           {
511     // Find last non-space
512     char* last = string;
513     for(char* c = string; *c != 0; c++){
514         if(!isspace(*c))
515             last = c;
516     }
517     last[1] = 0;
518     // Find first non-space
519     char* first = string;
520     for(; *first != 0; first++){
521         if(!isspace(*first))
522             break;
523     }
524     if(first != string)
525         memmove(string, first, last - first);
526 }
.fi
.SS "static void udev_enum ()\fC [static]\fP"
Reduce the hits of the enumeration by limiting to usb as technology and corsair as idVendor\&. Then filter with udev_enumerate_scan_devices () all hits\&.
.PP
The following call to udev_enumerate_get_list_entry() fetches the entire hitlist as udev_list_entry *\&. 
.br
 Use udev_list_entry_foreach() to iterate through the hit set\&. 
.br
 If both the device name exists (udev_list_entry_get_name) and the subsequent creation of a new udev_device (udev_device_new_from_syspath) is ok, the new device is added to the list with \fBusb_add_device()\fP\&.
.PP
If the latter does not work, the new device is released again (udev_device_unref ())\&. 
.br
 After the last iteration, the enumerator is released with udev_enumerate_unref ()\&. 
.PP
Definition at line 750 of file usb_linux\&.c\&.
.PP
References usb_add_device(), and V_CORSAIR_STR\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
750                        {
751     struct udev_enumerate* enumerator = udev_enumerate_new(udev);
752     udev_enumerate_add_match_subsystem(enumerator, "usb");
753     udev_enumerate_add_match_sysattr(enumerator, "idVendor", V_CORSAIR_STR);
754     udev_enumerate_scan_devices(enumerator);
755     struct udev_list_entry* devices, *dev_list_entry;
756     devices = udev_enumerate_get_list_entry(enumerator);
757 
758     udev_list_entry_foreach(dev_list_entry, devices){
759         const char* path = udev_list_entry_get_name(dev_list_entry);
760         if(!path)
761             continue;
762         struct udev_device* dev = udev_device_new_from_syspath(udev, path);
763         if(!dev)
764             continue;
765         // If the device matches a recognized device ID, open it
766         if(usb_add_device(dev))
767             // Release device if not
768             udev_device_unref(dev);
769     }
770     udev_enumerate_unref(enumerator);
771 }
.fi
.SS "static int usb_add_device (struct udev_device *dev)\fC [static]\fP"
If the device id can be found, call \fBusbadd()\fP with the appropriate parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the retval of \fBusbadd()\fP or 1 if either vendor is not corsair or product is not mentioned in model[]\&.
.RE
.PP
First get the idVendor via udev_device_get_sysattr_value()\&. If this is equal to the ID-string of corsair ('1b1c'), get the idProduct on the same way\&. 
.br
 If we can find the model name in the model array, call \fBusbadd()\fP with the model number\&. 
.PP
\fBTodo\fP
.RS 4
So why the hell not a transformation between the string and the short presentation? Lets check if the string representation is used elsewhere\&. 
.RE
.PP

.PP
Definition at line 698 of file usb_linux\&.c\&.
.PP
References N_MODELS, usbadd(), V_CORSAIR, and V_CORSAIR_STR\&.
.PP
Referenced by udev_enum(), and usbmain()\&.
.PP
.nf
698                                                   {
699     const char* vendor = udev_device_get_sysattr_value(dev, "idVendor");
700     if(vendor && !strcmp(vendor, V_CORSAIR_STR)){
701         const char* product = udev_device_get_sysattr_value(dev, "idProduct");
702         if(product){
703             for(_model* model = models; model < models + N_MODELS; model++){
704                 if(!strcmp(product, model->name)){
705                     return usbadd(dev, V_CORSAIR, model->number);
706                 }
707             }
708         }
709     }
710     return 1;
711 }
.fi
.SS "static void usb_rm_device (struct udev_device *dev)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&.
.RE
.PP
First try to find the system path of the device given in parameter dev\&. The index where the name is found is the same index we need to address the global keyboard array\&. That array holds all usbdevices\&. 
.br
 Searching for the correct name in kbsyspath-array and closing the usb via \fBcloseusb()\fP are protected by lock\&.\&.unlock of the corresponding devmutex arraymember\&. 
.PP
Definition at line 723 of file usb_linux\&.c\&.
.PP
References closeusb(), DEV_MAX, devmutex, kbsyspath, and keyboard\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
723                                                   {
724     // Device removed\&. Look for it in our list of keyboards
725     const char* syspath = udev_device_get_syspath(dev);
726     if(!syspath || syspath[0] == 0)
727         return;
728     for(int i = 1; i < DEV_MAX; i++){
729         pthread_mutex_lock(devmutex + i);
730         if(!strcmp(syspath, kbsyspath[i]))
731             closeusb(keyboard + i);
732         pthread_mutex_unlock(devmutex + i);
733     }
734 }
.fi
.SS "int usbadd (struct udev_device *dev, shortvendor, shortproduct)"

.PP
Definition at line 593 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, DEV_MAX, dmutex, usbdevice::handle, IS_CONNECTED, kbsyspath, keyboard, usbdevice::product, setupusb(), usbdevice::udev, and usbdevice::vendor\&.
.PP
Referenced by usb_add_device()\&.
.PP
.nf
593                                                                  {
594     const char* path = udev_device_get_devnode(dev);
595     const char* syspath = udev_device_get_syspath(dev);
596     if(!path || !syspath || path[0] == 0 || syspath[0] == 0){
597         ckb_err("Failed to get device path\n");
598         return -1;
599     }
600 #ifdef DEBUG
601     ckb_info(">>>vendor = 0x%x, product = 0x%x, path = %s, syspath = %s\n", vendor, product, path, syspath);
602 #endif // DEDBUG
603     // Find a free USB slot
604     for(int index = 1; index < DEV_MAX; index++){
605         usbdevice* kb = keyboard + index;
606         if(pthread_mutex_trylock(dmutex(kb))){
607             // If the mutex is locked then the device is obviously in use, so keep going
608             if(!strcmp(syspath, kbsyspath[index])){
609                 // Make sure this existing keyboard doesn't have the same syspath (this shouldn't happen)
610                 return 0;
611             }
612             continue;
613         }
614         if(!IS_CONNECTED(kb)){
615             // Open the sysfs device
616             kb->handle = open(path, O_RDWR) + 1;
617             if(kb->handle <= 0){
618                 ckb_err("Failed to open USB device: %s\n", strerror(errno));
619                 kb->handle = 0;
620                 pthread_mutex_unlock(dmutex(kb));
621                 return -1;
622             } else {
623                 // Set up device
624                 kb->udev = dev;
625                 kb->vendor = vendor;
626                 kb->product = product;
627                 strncpy(kbsyspath[index], syspath, FILENAME_MAX);
628                 // Mutex remains locked
629                 setupusb(kb);
630                 return 0;
631             }
632         }
633         pthread_mutex_unlock(dmutex(kb));
634     }
635     ckb_err("No free devices\n");
636     return -1;
637 }
.fi
.SS "static int usbclaim (\fBusbdevice\fP *kb)\fC [static]\fP"
usbclaim does claiming all EPs for the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 otherwise\&.
.RE
.PP
Claim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCONNECT) and ioctl(USBDEVFS_CLAIMINTERFACE)\&.
.PP
Error handling is done for the ioctl(USBDEVFS_CLAIMINTERFACE) only\&. If this fails, now an error message is thrown and -1 is returned\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 459 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, usbdevice::epcount, and usbdevice::handle\&.
.PP
Referenced by os_resetusb(), and os_setupusb()\&.
.PP
.nf
459                                   {
460     int count = kb->epcount;
461 #ifdef DEBUG
462     ckb_info("claiming %d endpoints\n", count);
463 #endif // DEBUG
464 
465     for(int i = 0; i < count; i++){
466         struct usbdevfs_ioctl ctl = { i, USBDEVFS_DISCONNECT, 0 };
467         ioctl(kb->handle - 1, USBDEVFS_IOCTL, &ctl);
468         if(ioctl(kb->handle - 1, USBDEVFS_CLAIMINTERFACE, &i)) {
469             ckb_err("Failed to claim interface %d: %s\n", i, strerror(errno));
470             return -1;
471         }
472     }
473     return 0;
474 }
.fi
.SS "void usbkill ()"

.PP
Definition at line 838 of file usb_linux\&.c\&.
.PP
Referenced by quitWithLock()\&.
.PP
.nf
838               {
839     udev_unref(udev);
840     udev = 0;
841 }
.fi
.SS "int usbmain ()"
Start the USB main loop\&. Returns program exit code when finished\&.
.PP
usbmain is called by \fBmain()\fP after setting up all other stuff\&. 
.PP
\fBReturns:\fP
.RS 4
0 normally or -1 if fatal error occurs (up to now only if no new devices are available) 
.RE
.PP
First check whether the uinput module is loaded by the kernel\&. 
.PP
\fBTodo\fP
.RS 4
Why isn't missing of uinput a fatal error? 
.RE
.PP
.PP
Create the udev object with udev_new() (is a function from libudev\&.h) terminate -1 if error
.PP
Enumerate all currently connected devices
.PP
\fBTodo\fP
.RS 4
lae\&. here the work has to go on\&.\&.\&. 
.RE
.PP

.PP
Definition at line 778 of file usb_linux\&.c\&.
.PP
References ckb_fatal, ckb_warn, udev_enum(), usb_add_device(), and usb_rm_device()\&.
.PP
Referenced by main()\&.
.PP
.nf
778              {
783     // Load the uinput module (if it's not loaded already)
784     if(system("modprobe uinput") != 0)
785         ckb_warn("Failed to load uinput module\n");
786 
790     if(!(udev = udev_new())) {
791         ckb_fatal("Failed to initialize udev in usbmain(), usb_linux\&.c\n");
792         return -1;
793     }
794 
797     udev_enum();
798 
801     // Done scanning\&. Enter a loop to poll for device updates
802     struct udev_monitor* monitor = udev_monitor_new_from_netlink(udev, "udev");
803     udev_monitor_filter_add_match_subsystem_devtype(monitor, "usb", 0);
804     udev_monitor_enable_receiving(monitor);
805     // Get an fd for the monitor
806     int fd = udev_monitor_get_fd(monitor);
807     fd_set fds;
808     while(udev){
809         FD_ZERO(&fds);
810         FD_SET(fd, &fds);
811         // Block until an event is read
812         if(select(fd + 1, &fds, 0, 0, 0) > 0 && FD_ISSET(fd, &fds)){
813             struct udev_device* dev = udev_monitor_receive_device(monitor);
814             if(!dev)
815                 continue;
816             const char* action = udev_device_get_action(dev);
817             if(!action){
818                 udev_device_unref(dev);
819                 continue;
820             }
821             // Add/remove device
822             if(!strcmp(action, "add")){
823                 int res = usb_add_device(dev);
824                 if(res == 0)
825                     continue;
826                 // If the device matched but the handle wasn't opened correctly, re-enumerate (this sometimes solves the problem)
827                 if(res == -1)
828                     udev_enum();
829             } else if(!strcmp(action, "remove"))
830                 usb_rm_device(dev);
831             udev_device_unref(dev);
832         }
833     }
834     udev_monitor_unref(monitor);
835     return 0;
836 }
.fi
.SS "static int usbunclaim (\fBusbdevice\fP *kb, intresetting)\fC [static]\fP"
usbunclaim do an unclaiming of the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.br
\fIresetting\fP boolean flag: If resseting is true, the caller will perform a bus reset command after unclaiming the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
always 0\&.
.RE
.PP
Unclaim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCARDURB)\&.
.PP
Afterwards - if ressetting is false - do a USBDEVFS_CONNECT for EP 0 and 1\&. If it is a non RGB device, connect EP 2 also\&. The comment mentions RGB keyboards only, but as I understand the code, this is valid also for RGB mice\&.
.PP
There is no error handling yet\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 406 of file usb_linux\&.c\&.
.PP
References usbdevice::epcount, FEAT_RGB, usbdevice::handle, and HAS_FEATURES\&.
.PP
Referenced by os_closeusb(), and os_resetusb()\&.
.PP
.nf
406                                                     {
407     int handle = kb->handle - 1;
408     int count = kb->epcount;
409     for (int i = 0; i < count; i++) {
410         ioctl(handle, USBDEVFS_RELEASEINTERFACE, &i);
411     }
412     // For RGB keyboards, the kernel driver should only be reconnected to interfaces 0 and 1 (HID), and only if we're not about to do a USB reset\&.
413     // Reconnecting any of the others causes trouble\&.
414     if (!resetting) {
415         struct usbdevfs_ioctl ctl = { 0, USBDEVFS_CONNECT, 0 };
416         ioctl(handle, USBDEVFS_IOCTL, &ctl);
417         ctl\&.ifno = 1;
418         ioctl(handle, USBDEVFS_IOCTL, &ctl);
419         // Also reconnect iface #2 (HID) for non-RGB keyboards
420         if(!HAS_FEATURES(kb, FEAT_RGB)){
421             ctl\&.ifno = 2;
422             ioctl(handle, USBDEVFS_IOCTL, &ctl);
423         }
424     }
425     return 0;
426 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char kbsyspath[9][FILENAME_MAX]\fC [static]\fP"

.PP
Definition at line 13 of file usb_linux\&.c\&.
.PP
Referenced by os_closeusb(), usb_rm_device(), and usbadd()\&.
.SS "\fB_model\fP models[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    
    {  "1b40" ,  0x1b40  },
    {  "1b17" ,  0x1b17  },
    {  "1b07" ,  0x1b07  },
    {  "1b37" ,  0x1b37  },
    {  "1b39" ,  0x1b39  },
    {  "1b13" ,  0x1b13  },
    {  "1b09" ,  0x1b09  },
    {  "1b33" ,  0x1b33  },
    {  "1b36" ,  0x1b36  },
    {  "1b38" ,  0x1b38  },
    {  "1b3a" ,  0x1b3a  },
    {  "1b11" ,  0x1b11  },
    {  "1b08" ,  0x1b08  },
    {  "1b2d" ,  0x1b2d  },
    {  "1b20" ,  0x1b20  },
    {  "1b15" ,  0x1b15  },
    
    {  "1b12" ,  0x1b12  },
    {  "1b2e" ,  0x1b2e  },
    {  "1b34" ,  0x1b34  },
    {  "1b14" ,  0x1b14   },
    {  "1b19" ,  0x1b19   },
    {  "1b2f" ,  0x1b2f   },
    {  "1b1e" ,  0x1b1e  },
    {  "1b3e" ,  0x1b3e  },
    {  "1b32" ,  0x1b32   },
    {  "1b3c" ,  0x1b3c  }
}
.fi

.PP
\fBAttention:\fP
.RS 4
when adding new hardware this file hat to be changed too\&.
.RE
.PP
In this structure array \fImodels\fP[] for each device the name (the device id as string in hex without leading 0x) and its usb device id as short must be entered in this array\&. 
.PP
Definition at line 655 of file usb_linux\&.c\&.
.SS "struct udev* udev\fC [static]\fP"

.PP
Definition at line 639 of file usb_linux\&.c\&.
.SS "pthread_t udevthread"

.PP
Definition at line 642 of file usb_linux\&.c\&.
.SS "pthread_t usbthread"

.PP
\fBTodo\fP
.RS 4
These two thread vasriables seem to be unused: usbtread, udevthread 
.RE
.PP

.PP
Definition at line 642 of file usb_linux\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
