.TH "KbPerf" 3 "Thu Nov 2 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KbPerf \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kbperf\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBheight\fP { \fBLOW\fP = 1, \fBLOWMED\fP, \fBMEDIUM\fP, \fBMEDHIGH\fP, \fBHIGH\fP }"
.br
.ti -1c
.RI "enum \fBindicator\fP { \fBNUM\fP, \fBCAPS\fP, \fBSCROLL\fP, \fBHW_IMAX\fP = SCROLL, \fBMODE\fP, \fBMACRO\fP, \fBLIGHT\fP, \fBLOCK\fP, \fBMUTE\fP }"
.br
.ti -1c
.RI "enum \fBi_hw\fP { \fBNONE\fP = -1, \fBNORMAL\fP, \fBON\fP, \fBOFF\fP }"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBdidLoad\fP ()"
.br
.ti -1c
.RI "void \fBsettingsUpdated\fP ()"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKbPerf\fP (\fBKbMode\fP *parent)"
.br
.ti -1c
.RI "\fBKbPerf\fP (\fBKbMode\fP *parent, const \fBKbPerf\fP &other)"
.br
.ti -1c
.RI "const \fBKbPerf\fP & \fBoperator=\fP (const \fBKbPerf\fP &rhs)"
.br
.ti -1c
.RI "void \fBload\fP (\fBCkbSettings\fP &settings)"
.br
.ti -1c
.RI "void \fBsave\fP (\fBCkbSettings\fP &settings)"
.br
.ti -1c
.RI "bool \fBneedsSave\fP () const "
.br
.ti -1c
.RI "\fBheight\fP \fBliftHeight\fP () const "
.br
.ti -1c
.RI "void \fBliftHeight\fP (\fBheight\fP newHeight)"
.br
.ti -1c
.RI "bool \fBangleSnap\fP () const "
.br
.ti -1c
.RI "void \fBangleSnap\fP (bool newAngleSnap)"
.br
.ti -1c
.RI "QPoint \fBdpi\fP (int index) const "
.br
.ti -1c
.RI "void \fBdpi\fP (int index, const QPoint &newValue)"
.br
.ti -1c
.RI "QPoint \fBsniperDpi\fP () const "
.br
.ti -1c
.RI "void \fBsniperDpi\fP (const QPoint &newValue)"
.br
.ti -1c
.RI "void \fBdpi\fP (int index, int newValue)"
.br
.ti -1c
.RI "void \fBsniperDpi\fP (int newValue)"
.br
.ti -1c
.RI "int \fBbaseDpiIdx\fP () const "
.br
.ti -1c
.RI "void \fBbaseDpiIdx\fP (int newIdx)"
.br
.ti -1c
.RI "void \fBdpiUp\fP ()"
.br
.ti -1c
.RI "void \fBdpiDown\fP ()"
.br
.ti -1c
.RI "void \fBdpiCycleUp\fP ()"
.br
.ti -1c
.RI "void \fBdpiCycleDown\fP ()"
.br
.ti -1c
.RI "bool \fBdpiEnabled\fP (int index) const "
.br
.ti -1c
.RI "void \fBdpiEnabled\fP (int index, bool newEnabled)"
.br
.ti -1c
.RI "quint64 \fBpushDpi\fP (const QPoint &newDpi)"
.br
.ti -1c
.RI "quint64 \fBpushDpi\fP (int newDpi)"
.br
.ti -1c
.RI "quint64 \fBpushSniper\fP ()"
.br
.ti -1c
.RI "void \fBpopDpi\fP (quint64 pushIdx)"
.br
.ti -1c
.RI "float \fBiOpacity\fP () const "
.br
.ti -1c
.RI "void \fBiOpacity\fP (float newIOpacity)"
.br
.ti -1c
.RI "bool \fBdpiIndicator\fP () const "
.br
.ti -1c
.RI "void \fBdpiIndicator\fP (bool newDpiIndicator)"
.br
.ti -1c
.RI "QColor \fBdpiColor\fP (int index) const "
.br
.ti -1c
.RI "void \fBdpiColor\fP (int index, const QColor &newColor)"
.br
.ti -1c
.RI "void \fBgetIndicator\fP (\fBindicator\fP index, QColor &color1, QColor &color2, QColor &color3, bool &software_enable, \fBi_hw\fP &hardware_enable)"
.br
.ti -1c
.RI "void \fBsetIndicator\fP (\fBindicator\fP index, const QColor &color1, const QColor &color2, const QColor &color3=QColor(), bool software_enable=true, \fBi_hw\fP hardware_enable=\fBNORMAL\fP)"
.br
.ti -1c
.RI "void \fBupdate\fP (QFile &\fBcmd\fP, int notifyNumber, bool force, bool saveCustomDpi)"
.br
.ti -1c
.RI "void \fBsetNeedsUpdate\fP ()"
.br
.ti -1c
.RI "void \fBapplyIndicators\fP (int modeIndex, const bool indicatorState[\fBHW_I_COUNT\fP])"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBDPI_COUNT\fP = 6"
.br
.ti -1c
.RI "static const int \fBSNIPER\fP = 0"
.br
.ti -1c
.RI "static const int \fBDPI_MIN\fP = 100"
.br
.ti -1c
.RI "static const int \fBDPI_MAX\fP = 12000"
.br
.ti -1c
.RI "static const int \fBOTHER\fP = \fBDPI_COUNT\fP"
.br
.ti -1c
.RI "static const int \fBI_COUNT\fP = (int)\fBMUTE\fP + 1"
.br
.ti -1c
.RI "static const int \fBHW_I_COUNT\fP = (int)\fBHW_IMAX\fP + 1"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKbMode\fP * \fBmodeParent\fP () const "
.br
.ti -1c
.RI "\fBKbBind\fP * \fBbind\fP () const "
.br
.ti -1c
.RI "\fBKbLight\fP * \fBlight\fP () const "
.br
.ti -1c
.RI "void \fBlightIndicator\fP (const char *name, QRgb rgba)"
.br
.ti -1c
.RI "void \fB_curDpi\fP (const QPoint &newDpi)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fBdpiX\fP [\fBDPI_COUNT\fP]"
.br
.ti -1c
.RI "int \fBdpiY\fP [\fBDPI_COUNT\fP]"
.br
.ti -1c
.RI "int \fBdpiCurX\fP"
.br
.ti -1c
.RI "int \fBdpiCurY\fP"
.br
.ti -1c
.RI "int \fBdpiBaseIdx\fP"
.br
.ti -1c
.RI "QColor \fBdpiClr\fP [\fBDPI_COUNT\fP+1]"
.br
.ti -1c
.RI "bool \fBdpiOn\fP [\fBDPI_COUNT\fP]"
.br
.ti -1c
.RI "QMap< quint64, QPoint > \fBpushedDpis\fP"
.br
.ti -1c
.RI "uint \fBrunningPushIdx\fP"
.br
.ti -1c
.RI "float \fB_iOpacity\fP"
.br
.ti -1c
.RI "QColor \fBiColor\fP [\fBI_COUNT\fP][2]"
.br
.ti -1c
.RI "QColor \fBlight100Color\fP"
.br
.ti -1c
.RI "QColor \fBmuteNAColor\fP"
.br
.ti -1c
.RI "bool \fBiEnable\fP [\fBI_COUNT\fP]"
.br
.ti -1c
.RI "\fBi_hw\fP \fBhwIType\fP [\fBHW_I_COUNT\fP]"
.br
.ti -1c
.RI "bool \fB_dpiIndicator\fP"
.br
.ti -1c
.RI "\fBheight\fP \fB_liftHeight\fP"
.br
.ti -1c
.RI "bool \fB_angleSnap\fP"
.br
.ti -1c
.RI "bool \fB_needsUpdate\fP"
.br
.ti -1c
.RI "bool \fB_needsSave\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 15 of file kbperf\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBKbPerf::height\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILOW \fP\fP
.TP
\fB\fILOWMED \fP\fP
.TP
\fB\fIMEDIUM \fP\fP
.TP
\fB\fIMEDHIGH \fP\fP
.TP
\fB\fIHIGH \fP\fP
.PP
Definition at line 31 of file kbperf\&.h\&.
.PP
.nf
31                 {
32         LOW = 1,
33         LOWMED,
34         MEDIUM,
35         MEDHIGH,
36         HIGH
37     };
.fi
.SS "enum \fBKbPerf::i_hw\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINONE \fP\fP
.TP
\fB\fINORMAL \fP\fP
.TP
\fB\fION \fP\fP
.TP
\fB\fIOFF \fP\fP
.PP
Definition at line 101 of file kbperf\&.h\&.
.PP
.nf
101               {
102         NONE = -1,  // For non-hardware indicators
103         NORMAL,
104         ON,
105         OFF
106     };
.fi
.SS "enum \fBKbPerf::indicator\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINUM \fP\fP
.TP
\fB\fICAPS \fP\fP
.TP
\fB\fISCROLL \fP\fP
.TP
\fB\fIHW_IMAX \fP\fP
.TP
\fB\fIMODE \fP\fP
.TP
\fB\fIMACRO \fP\fP
.TP
\fB\fILIGHT \fP\fP
.TP
\fB\fILOCK \fP\fP
.TP
\fB\fIMUTE \fP\fP
.PP
Definition at line 88 of file kbperf\&.h\&.
.PP
.nf
88                    {
89         // Hardware
90         NUM,
91         CAPS,
92         SCROLL, HW_IMAX = SCROLL,
93         // Software
94         MODE,
95         MACRO,
96         LIGHT,
97         LOCK,
98         MUTE
99     };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KbPerf::KbPerf (\fBKbMode\fP *parent)\fC [explicit]\fP"

.PP
Definition at line 13 of file kbperf\&.cpp\&.
.PP
References CAPS, DPI_COUNT, dpiBaseIdx, dpiClr, dpiCurX, dpiCurY, dpiOn, dpiX, dpiY, HW_I_COUNT, hwIType, I_COUNT, iColor, iEnable, LIGHT, light100Color, LOCK, MACRO, MODE, MUTE, muteNAColor, NORMAL, NUM, and SCROLL\&.
.PP
.nf
13                              :
14     QObject(parent), runningPushIdx(1),
15     _iOpacity(1\&.f), _dpiIndicator(true), _liftHeight(MEDIUM), _angleSnap(false),
16     _needsUpdate(true), _needsSave(true) {
17     // Default DPI settings
18     dpiX[0] = dpiY[0] = 400;
19     dpiX[1] = dpiY[1] = 450;
20     dpiX[2] = dpiY[2] = 800;
21     dpiX[3] = dpiY[3] = 1500;
22     dpiX[4] = dpiY[4] = 3000;
23     dpiX[5] = dpiY[5] = 6000;
24     dpiClr[0] = QColor(255, 0, 0);
25     dpiClr[1] = QColor(255, 192, 0);
26     dpiClr[2] = QColor(255, 255, 0);
27     dpiClr[3] = QColor(0, 255, 0);
28     dpiClr[4] = QColor(0, 255, 255);
29     dpiClr[5] = QColor(255, 255, 255);
30     dpiClr[6] = QColor(192, 192, 192);
31     for(int i = 0; i < DPI_COUNT; i++)
32         dpiOn[i] = true;
33     dpiBaseIdx = 3;
34     dpiCurX = dpiX[dpiBaseIdx];
35     dpiCurY = dpiY[dpiBaseIdx];
36     // Default indicators
37     iColor[NUM][0] = iColor[CAPS][0] = iColor[SCROLL][0] = QColor(0, 255, 0);   // Lock lights: on = green, off = black
38     iColor[NUM][1] = iColor[CAPS][1] = iColor[SCROLL][1] = QColor(0, 0, 0);
39     iColor[MACRO][0] = QColor(255, 0, 0);                                       // Macro: on = red, off = black
40     iColor[LOCK][0] = QColor(255, 255, 255);                                    // Win lock: on = white, off = black
41     iColor[MODE][0] = iColor[MUTE][0] = QColor(255, 255, 255, 0);               // Mode, mute: on = transparent, off = black
42     iColor[MODE][1] = iColor[MACRO][1] = iColor[LOCK][1] = iColor[MUTE][1] = muteNAColor = QColor(0, 0, 0);
43     iColor[LIGHT][0] = QColor(255, 0, 0);       // Brightness: red, yellow, white
44     iColor[LIGHT][1] = QColor(255, 255, 0);
45     light100Color = QColor(255, 255, 255);
46     for(int i = 0; i < HW_I_COUNT; i++){
47         // Set all lock lights to HW mode
48         iEnable[i] = false;
49         hwIType[i] = NORMAL;
50     }
51     for(int i = HW_I_COUNT; i < I_COUNT; i++){
52         // Turn all other indicators on
53         iEnable[i] = true;
54     }
55 }
.fi
.SS "KbPerf::KbPerf (\fBKbMode\fP *parent, const \fBKbPerf\fP &other)"

.PP
Definition at line 57 of file kbperf\&.cpp\&.
.PP
References _curDpi(), dpi(), DPI_COUNT, dpiBaseIdx, dpiClr, dpiOn, dpiX, dpiY, hwIType, I_COUNT, iColor, and iEnable\&.
.PP
.nf
57                                                   :
58     QObject(parent), dpiCurX(other\&.dpiCurX), dpiCurY(other\&.dpiCurY), dpiBaseIdx(other\&.dpiBaseIdx), runningPushIdx(1),
59     _iOpacity(other\&._iOpacity), light100Color(other\&.light100Color), muteNAColor(other\&.muteNAColor), _dpiIndicator(other\&._dpiIndicator),
60     _liftHeight(other\&._liftHeight), _angleSnap(other\&._angleSnap),
61     _needsUpdate(true), _needsSave(true) {
62     memcpy(dpiX, other\&.dpiX, sizeof(dpiX));
63     memcpy(dpiY, other\&.dpiY, sizeof(dpiY));
64     for(int i = 0; i < DPI_COUNT + 1; i++)
65         dpiClr[i] = other\&.dpiClr[i];
66     memcpy(dpiOn, other\&.dpiOn, sizeof(dpiOn));
67     for(int i = 0; i < I_COUNT; i++){
68         iColor[i][0] = other\&.iColor[i][0];
69         iColor[i][1] = other\&.iColor[i][1];
70     }
71     memcpy(iEnable, other\&.iEnable, sizeof(iEnable));
72     memcpy(hwIType, other\&.hwIType, sizeof(hwIType));
73     // Don't copy pushed DPI states\&. If the other mode has any, restore the original DPI
74     _curDpi(dpi(dpiBaseIdx));
75 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void KbPerf::_curDpi (const QPoint &newDpi)\fC [private]\fP"

.PP
Definition at line 259 of file kbperf\&.cpp\&.
.PP
References _needsSave, _needsUpdate, dpiCurX, and dpiCurY\&.
.PP
Referenced by baseDpiIdx(), dpi(), KbPerf(), load(), operator=(), popDpi(), and pushDpi()\&.
.PP
.nf
259                                          {
260     dpiCurX = newDpi\&.x();
261     dpiCurY = newDpi\&.y();
262     _needsUpdate = _needsSave = true;
263 }
.fi
.SS "bool KbPerf::angleSnap () const\fC [inline]\fP"

.PP
Definition at line 42 of file kbperf\&.h\&.
.PP
References _angleSnap\&.
.PP
Referenced by MPerfWidget::on_aSnapBox_clicked(), Kb::readNotify(), and MPerfWidget::setPerf()\&.
.PP
.nf
42 { return _angleSnap; }
.fi
.SS "void KbPerf::angleSnap (boolnewAngleSnap)"

.PP
Definition at line 380 of file kbperf\&.cpp\&.
.PP
References _angleSnap, _needsSave, and _needsUpdate\&.
.PP
.nf
380                                        {
381     _angleSnap = newAngleSnap;
382     _needsUpdate = _needsSave = true;
383 }
.fi
.SS "void KbPerf::applyIndicators (intmodeIndex, const boolindicatorState[HW_I_COUNT])"

.PP
Definition at line 439 of file kbperf\&.cpp\&.
.PP
References _dpiIndicator, _iOpacity, baseDpiIdx(), bind(), CAPS, dpiClr, getMuteState(), Kb::HWMODE_MAX, iColor, iEnable, LIGHT, light(), light100Color, lightIndicator(), LOCK, MACRO, MODE, MUTE, MUTED, muteNAColor, NUM, OTHER, KbLight::resetIndicators(), SCROLL, and UNMUTED\&.
.PP
Referenced by Kb::frameUpdate()\&.
.PP
.nf
439                                                                       {
440     light()->resetIndicators();
441     if(_iOpacity <= 0\&.f)
442         return;
443     if(_dpiIndicator){
444         // Set DPI indicator according to index
445         int index = baseDpiIdx();
446         if(index == -1 || index > OTHER)
447             index = OTHER;
448         lightIndicator("dpi", dpiClr[index]\&.rgba());
449     }
450     // KB indicators
451     if(iEnable[MODE]){
452         for(int i = 0; i < Kb::HWMODE_MAX; i++){
453             char name[4];
454             snprintf(name, sizeof(name), "m%d", i + 1);
455             if(modeIndex == i)
456                 lightIndicator(name, iColor[MODE][0]\&.rgba());
457             else
458                 lightIndicator(name, iColor[MODE][1]\&.rgba());
459         }
460     }
461     if(iEnable[MACRO])
462         lightIndicator("mr", iColor[MUTE][1]\&.rgba());
463     if(iEnable[LIGHT]){
464         switch(light()->dimming()){
465         case 0: // 100%
466             lightIndicator("light", light100Color\&.rgba());
467             break;
468         case 1: // 67%
469             lightIndicator("light", iColor[LIGHT][1]\&.rgba());
470             break;
471         case 2: // 33%
472         case 3: // light off
473             lightIndicator("light", iColor[LIGHT][0]\&.rgba());
474             break;
475         }
476     }
477     if(iEnable[LOCK]){
478         if(bind()->winLock())
479             lightIndicator("lock", iColor[LOCK][0]\&.rgba());
480         else
481             lightIndicator("lock", iColor[LOCK][1]\&.rgba());
482     }
483     if(iEnable[MUTE]){
484         switch(getMuteState()){
485         case MUTED:
486             lightIndicator("mute", iColor[MUTE][0]\&.rgba());
487             break;
488         case UNMUTED:
489             lightIndicator("mute", iColor[MUTE][1]\&.rgba());
490             break;
491         default:
492             lightIndicator("mute", muteNAColor\&.rgba());
493             break;
494         }
495     }
496     // Lock lights
497     if(iEnable[NUM])
498         lightIndicator("numlock", indicatorState[0] ? iColor[NUM][0]\&.rgba() : iColor[NUM][1]\&.rgba());
499     if(iEnable[CAPS])
500         lightIndicator("caps", indicatorState[1] ? iColor[CAPS][0]\&.rgba() : iColor[CAPS][1]\&.rgba());
501     if(iEnable[SCROLL])
502         lightIndicator("scroll", indicatorState[2] ? iColor[SCROLL][0]\&.rgba() : iColor[SCROLL][1]\&.rgba());
503 }
.fi
.SS "int KbPerf::baseDpiIdx () const\fC [inline]\fP"

.PP
Definition at line 61 of file kbperf\&.h\&.
.PP
References dpiBaseIdx\&.
.PP
Referenced by applyIndicators(), dpiCycleDown(), dpiCycleUp(), dpiDown(), dpiUp(), KeyAction::keyEvent(), and Kb::readNotify()\&.
.PP
.nf
61 { return dpiBaseIdx; }
.fi
.SS "void KbPerf::baseDpiIdx (intnewIdx)"

.PP
Definition at line 265 of file kbperf\&.cpp\&.
.PP
References _curDpi(), _needsSave, _needsUpdate, dpi(), dpiBaseIdx, and pushedDpis\&.
.PP
.nf
265                                   {
266     if (pushedDpis\&.isEmpty() && dpiBaseIdx == newIdx)
267         return;
268     pushedDpis\&.clear();
269     dpiBaseIdx = newIdx;
270     _curDpi(dpi(dpiBaseIdx));
271     _needsUpdate = _needsSave = true; 
272 }
.fi
.SS "\fBKbBind\fP * KbPerf::bind () const\fC [private]\fP"

.PP
Definition at line 98 of file kbperf\&.cpp\&.
.PP
References KbMode::bind(), and modeParent()\&.
.PP
Referenced by applyIndicators()\&.
.PP
.nf
98                            {
99     return modeParent()->bind();
100 }
.fi
.SS "void KbPerf::didLoad ()\fC [signal]\fP"

.PP
Definition at line 134 of file moc_kbperf\&.cpp\&.
.PP
Referenced by load()\&.
.PP
.nf
135 {
136     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
137 }
.fi
.SS "QPoint KbPerf::dpi (intindex) const\fC [inline]\fP"

.PP
Definition at line 50 of file kbperf\&.h\&.
.PP
References DPI_COUNT, dpiX, and dpiY\&.
.PP
Referenced by baseDpiIdx(), MPerfWidget::boxXChanged(), MPerfWidget::boxYChanged(), KbPerf(), load(), operator=(), popDpi(), Kb::readNotify(), RebindWidget::setBind(), MPerfWidget::setPerf(), MPerfWidget::sliderXMoved(), MPerfWidget::sliderYMoved(), and sniperDpi()\&.
.PP
.nf
50 { if(index < 0 || index >= DPI_COUNT) return QPoint(); return QPoint(dpiX[index], dpiY[index]); }
.fi
.SS "void KbPerf::dpi (intindex, const QPoint &newValue)"

.PP
Definition at line 247 of file kbperf\&.cpp\&.
.PP
References _curDpi(), _needsSave, _needsUpdate, DPI_COUNT, dpiBaseIdx, dpiX, dpiY, and pushedDpis\&.
.PP
.nf
247                                                  {
248     if(index < 0 || index >= DPI_COUNT)
249         return;
250     dpiX[index] = newValue\&.x();
251     dpiY[index] = newValue\&.y();
252     // Update current DPI if needed
253     if(dpiBaseIdx == index && pushedDpis\&.isEmpty()) {
254         _curDpi(QPoint(dpiX[index], dpiY[index]));
255     }
256     _needsUpdate = _needsSave = true;
257 }
.fi
.SS "void KbPerf::dpi (intindex, intnewValue)\fC [inline]\fP"

.PP
Definition at line 55 of file kbperf\&.h\&.
.PP
References dpi()\&.
.PP
Referenced by dpi()\&.
.PP
.nf
55 { dpi(index, QPoint(newValue, newValue)); }
.fi
.SS "QColor KbPerf::dpiColor (intindex) const\fC [inline]\fP"

.PP
Definition at line 85 of file kbperf\&.h\&.
.PP
References dpiClr\&.
.PP
Referenced by MPerfWidget::colorChanged(), Kb::readNotify(), MPerfWidget::setPerf(), and update()\&.
.PP
.nf
85 { return dpiClr[index]; }
.fi
.SS "void KbPerf::dpiColor (intindex, const QColor &newColor)\fC [inline]\fP"

.PP
Definition at line 86 of file kbperf\&.h\&.
.PP
References _needsSave, _needsUpdate, and dpiClr\&.
.PP
.nf
86 { dpiClr[index] = newColor; _needsUpdate = _needsSave = true; }
.fi
.SS "void KbPerf::dpiCycleDown ()"

.PP
Definition at line 329 of file kbperf\&.cpp\&.
.PP
References baseDpiIdx(), DPI_COUNT, dpiOn, and SNIPER\&.
.PP
Referenced by KeyAction::keyEvent()\&.
.PP
.nf
329                          {
330     int idx = baseDpiIdx();
331     do {
332         idx--;
333         if(idx <= SNIPER)
334             idx = DPI_COUNT - 1;
335     if(idx == baseDpiIdx())
336             return;
337     } while(!dpiOn[idx]);
338     baseDpiIdx(idx);
339 }
.fi
.SS "void KbPerf::dpiCycleUp ()"

.PP
Definition at line 317 of file kbperf\&.cpp\&.
.PP
References baseDpiIdx(), DPI_COUNT, dpiOn, and SNIPER\&.
.PP
Referenced by KeyAction::keyEvent()\&.
.PP
.nf
317                        {
318     int idx = baseDpiIdx();
319     do {
320         idx++;
321         if(idx >= DPI_COUNT)
322             idx = SNIPER + 1;
323         if(idx == baseDpiIdx())
324             return;
325     } while(!dpiOn[idx]);
326     baseDpiIdx(idx);
327 }
.fi
.SS "void KbPerf::dpiDown ()"

.PP
Definition at line 306 of file kbperf\&.cpp\&.
.PP
References baseDpiIdx(), dpiOn, and SNIPER\&.
.PP
Referenced by KeyAction::keyEvent()\&.
.PP
.nf
306                     {
307     int idx = baseDpiIdx();
308     do {
309         idx--;
310         if(idx <= SNIPER)
311             return;
312     } while(!dpiOn[idx]);
313     baseDpiIdx(idx);
314 }
.fi
.SS "bool KbPerf::dpiEnabled (intindex) const\fC [inline]\fP"

.PP
Definition at line 68 of file kbperf\&.h\&.
.PP
References dpiOn\&.
.PP
Referenced by MPerfWidget::enableChanged(), Kb::readNotify(), and MPerfWidget::setPerf()\&.
.PP
.nf
68 { return dpiOn[index]; }
.fi
.SS "void KbPerf::dpiEnabled (intindex, boolnewEnabled)\fC [inline]\fP"

.PP
Definition at line 69 of file kbperf\&.h\&.
.PP
References _needsSave, _needsUpdate, and dpiOn\&.
.PP
.nf
69 { if(index <= 0) return; dpiOn[index] = newEnabled; _needsUpdate = _needsSave = true; }
.fi
.SS "bool KbPerf::dpiIndicator () const\fC [inline]\fP"

.PP
Definition at line 82 of file kbperf\&.h\&.
.PP
References _dpiIndicator\&.
.PP
Referenced by MPerfWidget::on_indicBox_clicked(), and MPerfWidget::setPerf()\&.
.PP
.nf
82 { return _dpiIndicator; }
.fi
.SS "void KbPerf::dpiIndicator (boolnewDpiIndicator)\fC [inline]\fP"

.PP
Definition at line 83 of file kbperf\&.h\&.
.PP
References _dpiIndicator, and _needsSave\&.
.PP
.nf
83 { _dpiIndicator = newDpiIndicator; _needsSave = true; }
.fi
.SS "void KbPerf::dpiUp ()"

.PP
Definition at line 295 of file kbperf\&.cpp\&.
.PP
References baseDpiIdx(), DPI_COUNT, and dpiOn\&.
.PP
Referenced by KeyAction::keyEvent()\&.
.PP
.nf
295                   {
296     // Scroll past disabled DPIs and choose the next one up
297     int idx = baseDpiIdx();
298     do {
299         idx++;
300         if(idx >= DPI_COUNT)
301             return;
302     } while(!dpiOn[idx]);
303     baseDpiIdx(idx);
304 }
.fi
.SS "void KbPerf::getIndicator (\fBindicator\fPindex, QColor &color1, QColor &color2, QColor &color3, bool &software_enable, \fBi_hw\fP &hardware_enable)"

.PP
Definition at line 341 of file kbperf\&.cpp\&.
.PP
References HW_IMAX, hwIType, I_COUNT, iColor, iEnable, LIGHT, light100Color, MUTE, muteNAColor, and NONE\&.
.PP
Referenced by KPerfWidget::setPerf()\&.
.PP
.nf
341                                                                                                                                       {
342     if(index < 0 || index >= I_COUNT)
343         return;
344     color1 = iColor[index][0];
345     color2 = iColor[index][1];
346     if(index == LIGHT)
347         color3 = light100Color;
348     else if(index == MUTE)
349         color3 = muteNAColor;
350     else
351         color3 = QColor();
352     software_enable = iEnable[index];
353     hardware_enable = (index <= HW_IMAX ? hwIType[index] : NONE);
354 }
.fi
.SS "float KbPerf::iOpacity () const\fC [inline]\fP"

.PP
Definition at line 79 of file kbperf\&.h\&.
.PP
References _iOpacity\&.
.PP
Referenced by KPerfWidget::on_intensityBox_valueChanged(), MPerfWidget::on_spinBox_valueChanged(), KPerfWidget::setPerf(), and MPerfWidget::setPerf()\&.
.PP
.nf
79 { return _iOpacity; }
.fi
.SS "void KbPerf::iOpacity (floatnewIOpacity)\fC [inline]\fP"

.PP
Definition at line 80 of file kbperf\&.h\&.
.PP
References _iOpacity, and _needsSave\&.
.PP
.nf
80 { _iOpacity = newIOpacity; _needsSave = true; }
.fi
.SS "\fBheight\fP KbPerf::liftHeight () const\fC [inline]\fP"

.PP
Definition at line 38 of file kbperf\&.h\&.
.PP
References _liftHeight\&.
.PP
Referenced by MPerfWidget::on_lHeightBox_activated(), Kb::readNotify(), and MPerfWidget::setPerf()\&.
.PP
.nf
38 { return _liftHeight; }
.fi
.SS "void KbPerf::liftHeight (\fBheight\fPnewHeight)"

.PP
Definition at line 373 of file kbperf\&.cpp\&.
.PP
References _liftHeight, _needsSave, _needsUpdate, and HIGH\&.
.PP
.nf
373                                        {
374     if(newHeight < LOW || newHeight > HIGH)
375         return;
376     _liftHeight = newHeight;
377     _needsUpdate = _needsSave = true;
378 }
.fi
.SS "\fBKbLight\fP * KbPerf::light () const\fC [private]\fP"

.PP
Definition at line 102 of file kbperf\&.cpp\&.
.PP
References KbMode::light(), and modeParent()\&.
.PP
Referenced by applyIndicators(), and lightIndicator()\&.
.PP
.nf
102                              {
103     return modeParent()->light();
104 }
.fi
.SS "void KbPerf::lightIndicator (const char *name, QRgbrgba)\fC [private]\fP"

.PP
Definition at line 432 of file kbperf\&.cpp\&.
.PP
References _iOpacity, light(), and KbLight::setIndicator()\&.
.PP
Referenced by applyIndicators()\&.
.PP
.nf
432                                                       {
433     int a = round(qAlpha(rgba) * _iOpacity);
434     if(a <= 0)
435         return;
436     light()->setIndicator(name, qRgba(qRed(rgba), qGreen(rgba), qBlue(rgba), a));
437 }
.fi
.SS "void KbPerf::load (\fBCkbSettings\fP &settings)"

.PP
Definition at line 106 of file kbperf\&.cpp\&.
.PP
References _angleSnap, _curDpi(), _dpiIndicator, _iOpacity, _liftHeight, _needsSave, CkbSettings::contains(), CkbSettings::containsGroup(), didLoad(), dpi(), DPI_COUNT, dpiBaseIdx, dpiClr, dpiOn, dpiX, dpiY, HIGH, HW_IMAX, hwIType, I_COUNT, iColor, iEnable, LIGHT, light100Color, LOCK, MACRO, MEDIUM, MODE, MUTE, muteNAColor, NORMAL, OTHER, pushedDpis, runningPushIdx, and CkbSettings::value()\&.
.PP
Referenced by KbMode::KbMode()\&.
.PP
.nf
106                                       {
107     pushedDpis\&.clear();
108     runningPushIdx = 1;
109     _needsSave = false;
110     bool readIndicators = true;
111     if(!settings\&.containsGroup("Performance/Indicators")){
112         // Read old indicator settings from the lighting group, if present
113         // (ckb <= v0\&.2\&.0)
114         SGroup group(settings, "Lighting");
115         if(settings\&.contains("InactiveIndicators")){
116             bool inOk = false;
117             int inactive = settings\&.value("InactiveIndicators")\&.toInt(&inOk);
118             if(!inOk || inactive > 2)
119                 inactive = 2;
120             if(inactive == 1)
121                 _iOpacity = 0\&.75f;
122             else if(inactive == 0)
123                 _iOpacity = 0\&.5f;
124             else if(inactive < 0){
125                 // Indicators disabled
126                 iEnable[MODE] = iEnable[MACRO] = iEnable[LIGHT] = iEnable[LOCK]  = iEnable[MUTE] = false;
127             }
128             bool showMute = (settings\&.value("ShowMute")\&.toInt(&inOk) != 0);
129             if(inOk && !showMute)
130                 iEnable[MUTE] = false;
131             readIndicators = false;
132         }
133     }
134     SGroup group(settings, "Performance");
135     // Read DPI settings
136     {
137         SGroup group(settings, "DPI");
138         for(int i = 0; i < DPI_COUNT; i++){
139             QString iStr = QString::number(i);
140             QPoint value = settings\&.value(iStr)\&.toPoint();
141             if(value\&.isNull())
142                 continue;
143             dpiX[i] = value\&.x(); dpiY[i] = value\&.y();
144             QColor color = settings\&.value(iStr + "RGB")\&.toString();
145             if(color\&.isValid())
146                 dpiClr[i] = color;
147             if(i != 0)
148                 dpiOn[i] = !settings\&.value(iStr + "Disabled")\&.toBool();
149         }
150         QColor color = settings\&.value("6RGB")\&.toString();
151         if(color\&.isValid())
152             dpiClr[OTHER] = color;
153         if (settings\&.contains("CurIdx")) {
154             dpiBaseIdx = settings\&.value("CurIdx")\&.toInt();
155         } else {
156             // If there isn't a setting for current DPI stage, pick the first
157             // enabled one\&. Failing that just pick stage 1\&.
158             dpiBaseIdx = 1;
159             for (int i = 1; i < DPI_COUNT; i++) {
160                 if (dpiOn[i]) {
161                     dpiBaseIdx = i;
162                     break;
163                 }
164             }    
165         }
166         _curDpi(dpi(dpiBaseIdx));
167     }
168     // Read misc\&. mouse settings
169     _liftHeight = (height)settings\&.value("LiftHeight")\&.toInt();
170     if(_liftHeight < LOW || _liftHeight > HIGH)
171         _liftHeight = MEDIUM;
172     _angleSnap = settings\&.value("AngleSnap")\&.toBool();
173     if(settings\&.contains("NoIndicator")){
174         // ckb <= v0\&.2\&.0
175         _dpiIndicator = !settings\&.value("NoIndicator")\&.toBool();
176     } else {
177         _dpiIndicator = settings\&.value("Indicators/DPI", true)\&.toBool();
178     }
179     // Read indicator settings
180     if(readIndicators){
181         SGroup group(settings, "Indicators");
182         _iOpacity = settings\&.value("Opacity", 100)\&.toInt() / 100\&.f;
183         for(int i = 0; i < I_COUNT; i++){
184             SGroup group(settings, QString::number(i));
185             QColor color = settings\&.value("RGB0")\&.toString();
186             if(color\&.isValid())
187                 iColor[i][0] = color;
188             color = settings\&.value("RGB1")\&.toString();
189             if(color\&.isValid())
190                 iColor[i][1] = color;
191             if(i == LIGHT){
192                 color = settings\&.value("RGB2")\&.toString();
193                 if(color\&.isValid())
194                     light100Color = color;
195             } else if(i == MUTE){
196                 color = settings\&.value("RGB2")\&.toString();
197                 if(color\&.isValid())
198                     muteNAColor = color;
199             }
200             if(i <= HW_IMAX){
201                 iEnable[i] = settings\&.value("Enable", false)\&.toBool();
202                 hwIType[i] = (i_hw)settings\&.value("Hardware", (int)NORMAL)\&.toInt();
203             } else {
204                 iEnable[i] = settings\&.value("Enable", true)\&.toBool();
205             }
206         }
207     }
208     emit didLoad();
209 }
.fi
.SS "\fBKbMode\fP* KbPerf::modeParent () const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 127 of file kbperf\&.h\&.
.PP
Referenced by bind(), and light()\&.
.PP
.nf
127 { return (KbMode*)parent(); }
.fi
.SS "bool KbPerf::needsSave () const\fC [inline]\fP"

.PP
Definition at line 28 of file kbperf\&.h\&.
.PP
References _needsSave\&.
.PP
Referenced by KbMode::needsSave()\&.
.PP
.nf
28 { return _needsSave; }
.fi
.SS "const \fBKbPerf\fP & KbPerf::operator= (const \fBKbPerf\fP &rhs)"

.PP
Definition at line 77 of file kbperf\&.cpp\&.
.PP
References _angleSnap, _curDpi(), _dpiIndicator, _iOpacity, _liftHeight, _needsSave, _needsUpdate, dpi(), DPI_COUNT, dpiBaseIdx, dpiClr, dpiCurX, dpiCurY, dpiOn, dpiX, dpiY, hwIType, I_COUNT, iColor, iEnable, light100Color, muteNAColor, and runningPushIdx\&.
.PP
.nf
77                                                    {
78     dpiCurX = other\&.dpiCurX; dpiCurY = other\&.dpiCurY; dpiBaseIdx = other\&.dpiBaseIdx; runningPushIdx = 1;
79     _iOpacity = other\&._iOpacity; light100Color = other\&.light100Color; muteNAColor = other\&.muteNAColor; _dpiIndicator = other\&._dpiIndicator;
80     _liftHeight = other\&._liftHeight; _angleSnap = other\&._angleSnap;
81     _needsUpdate = true; _needsSave = true;
82     memcpy(dpiX, other\&.dpiX, sizeof(dpiX));
83     memcpy(dpiY, other\&.dpiY, sizeof(dpiY));
84     for(int i = 0; i < DPI_COUNT + 1; i++)
85         dpiClr[i] = other\&.dpiClr[i];
86     memcpy(dpiOn, other\&.dpiOn, sizeof(dpiOn));
87     for(int i = 0; i < I_COUNT; i++){
88         iColor[i][0] = other\&.iColor[i][0];
89         iColor[i][1] = other\&.iColor[i][1];
90     }
91     memcpy(iEnable, other\&.iEnable, sizeof(iEnable));
92     memcpy(hwIType, other\&.hwIType, sizeof(hwIType));
93     // Don't copy pushed DPI states\&. If the other mode has any, restore the original DPI
94     _curDpi(dpi(dpiBaseIdx));
95     return other;
96 }
.fi
.SS "void KbPerf::popDpi (quint64pushIdx)"

.PP
Definition at line 281 of file kbperf\&.cpp\&.
.PP
References _curDpi(), _needsSave, _needsUpdate, dpi(), dpiBaseIdx, map_last, and pushedDpis\&.
.PP
Referenced by KeyAction::keyEvent()\&.
.PP
.nf
281                                   {
282     if(!pushedDpis\&.contains(pushIdx)) {   
283       return;
284     }
285     pushedDpis\&.remove(pushIdx);
286     if (pushedDpis\&.isEmpty()) {
287         _curDpi(dpi(dpiBaseIdx));
288     } else {
289         // Set the DPI to the last-pushed value still on the stack
290         _curDpi(map_last(pushedDpis));
291     } 
292     _needsUpdate = _needsSave = true;
293 }
.fi
.SS "quint64 KbPerf::pushDpi (const QPoint &newDpi)"

.PP
Definition at line 274 of file kbperf\&.cpp\&.
.PP
References _curDpi(), pushedDpis, and runningPushIdx\&.
.PP
Referenced by KeyAction::keyEvent(), and pushSniper()\&.
.PP
.nf
274                                            {
275     quint64 index = runningPushIdx++;
276     pushedDpis[index] = newDpi;
277     _curDpi(newDpi);
278     return index;
279 }
.fi
.SS "quint64 KbPerf::pushDpi (intnewDpi)\fC [inline]\fP"

.PP
Definition at line 74 of file kbperf\&.h\&.
.PP
References pushDpi()\&.
.PP
Referenced by pushDpi()\&.
.PP
.nf
74 { return pushDpi(QPoint(newDpi, newDpi)); }
.fi
.SS "quint64 KbPerf::pushSniper ()\fC [inline]\fP"

.PP
Definition at line 75 of file kbperf\&.h\&.
.PP
References pushDpi(), and sniperDpi()\&.
.PP
Referenced by KeyAction::keyEvent()\&.
.PP
.nf
75 { return pushDpi(sniperDpi()); }
.fi
.SS "void KbPerf::save (\fBCkbSettings\fP &settings)"

.PP
Definition at line 211 of file kbperf\&.cpp\&.
.PP
References _angleSnap, _dpiIndicator, _liftHeight, _needsSave, DPI_COUNT, dpiBaseIdx, dpiClr, dpiOn, dpiX, dpiY, HW_IMAX, hwIType, I_COUNT, iColor, iEnable, LIGHT, light100Color, MUTE, muteNAColor, OTHER, and CkbSettings::setValue()\&.
.PP
Referenced by KbMode::save()\&.
.PP
.nf
211                                       {
212     _needsSave = false;
213     SGroup group(settings, "Performance");
214     {
215         SGroup group(settings, "DPI");
216         for(int i = 0; i < DPI_COUNT; i++){
217             QString iStr = QString::number(i);
218             settings\&.setValue(iStr, QPoint(dpiX[i], dpiY[i]));
219             settings\&.setValue(iStr + "RGB", dpiClr[i]\&.name(QColor::HexArgb));
220             if(i != 0)
221                 settings\&.setValue(iStr + "Disabled", !dpiOn[i]);
222         }
223         settings\&.setValue("6RGB", dpiClr[OTHER]\&.name(QColor::HexArgb));
224     // Ignore pushed modes when saving current DPI\&.
225         settings\&.setValue("CurIdx", dpiBaseIdx);
226     }
227     settings\&.setValue("LiftHeight", _liftHeight);
228     settings\&.setValue("AngleSnap", _angleSnap);
229     {
230         SGroup group(settings, "Indicators");
231         settings\&.setValue("DPI", _dpiIndicator);
232         for(int i = 0; i < I_COUNT; i++){
233             SGroup group(settings, QString::number(i));
234             settings\&.setValue("RGB0", iColor[i][0]\&.name(QColor::HexArgb));
235             settings\&.setValue("RGB1", iColor[i][1]\&.name(QColor::HexArgb));
236             if(i == LIGHT)
237                 settings\&.setValue("RGB2", light100Color\&.name(QColor::HexArgb));
238             else if(i == MUTE)
239                 settings\&.setValue("RGB2", muteNAColor\&.name(QColor::HexArgb));
240             settings\&.setValue("Enable", iEnable[i]);
241             if(i <= HW_IMAX)
242                 settings\&.setValue("Hardware", (int)hwIType[i]);
243         }
244     }
245 }
.fi
.SS "void KbPerf::setIndicator (\fBindicator\fPindex, const QColor &color1, const QColor &color2, const QColor &color3 = \fCQColor()\fP, boolsoftware_enable = \fCtrue\fP, \fBi_hw\fPhardware_enable = \fC\fBNORMAL\fP\fP)"

.PP
Definition at line 356 of file kbperf\&.cpp\&.
.PP
References _needsSave, _needsUpdate, HW_IMAX, hwIType, I_COUNT, iColor, iEnable, LIGHT, light100Color, MUTE, muteNAColor, NONE, and NORMAL\&.
.PP
Referenced by KPerfWidget::uiUpdated()\&.
.PP
.nf
356                                                                                                                                                       {
357     if(index < 0 || index >= I_COUNT)
358         return;
359     iColor[index][0] = color1;
360     iColor[index][1] = color2;
361     if(index == LIGHT)
362         light100Color = color3;
363     else if(index == MUTE)
364         muteNAColor = color3;
365     iEnable[index] = software_enable;
366     if(hardware_enable == NONE)
367         hardware_enable = NORMAL;
368     if(index <= HW_IMAX)
369         hwIType[index] = hardware_enable;
370     _needsUpdate = _needsSave = true;
371 }
.fi
.SS "void KbPerf::setNeedsUpdate ()\fC [inline]\fP"

.PP
Definition at line 116 of file kbperf\&.h\&.
.PP
References _needsUpdate\&.
.PP
Referenced by KbMode::setNeedsUpdate()\&.
.PP
.nf
116 { _needsUpdate = true; }
.fi
.SS "void KbPerf::settingsUpdated ()\fC [signal]\fP"

.PP
Definition at line 140 of file moc_kbperf\&.cpp\&.
.PP
Referenced by update()\&.
.PP
.nf
141 {
142     QMetaObject::activate(this, &staticMetaObject, 1, Q_NULLPTR);
143 }
.fi
.SS "QPoint KbPerf::sniperDpi () const\fC [inline]\fP"

.PP
Definition at line 52 of file kbperf\&.h\&.
.PP
References dpi(), and SNIPER\&.
.PP
Referenced by pushSniper()\&.
.PP
.nf
52 { return dpi(SNIPER); }
.fi
.SS "void KbPerf::sniperDpi (const QPoint &newValue)\fC [inline]\fP"

.PP
Definition at line 53 of file kbperf\&.h\&.
.PP
References dpi(), and SNIPER\&.
.PP
.nf
53 { dpi(SNIPER, newValue); }
.fi
.SS "void KbPerf::sniperDpi (intnewValue)\fC [inline]\fP"

.PP
Definition at line 56 of file kbperf\&.h\&.
.PP
References sniperDpi()\&.
.PP
Referenced by sniperDpi()\&.
.PP
.nf
56 { sniperDpi(QPoint(newValue, newValue)); }
.fi
.SS "void KbPerf::update (QFile &cmd, intnotifyNumber, boolforce, boolsaveCustomDpi)"

.PP
Definition at line 385 of file kbperf\&.cpp\&.
.PP
References _angleSnap, _liftHeight, _needsUpdate, DPI_COUNT, dpiBaseIdx, dpiColor(), dpiCurX, dpiCurY, dpiOn, dpiX, dpiY, HW_I_COUNT, hwIType, OFF, ON, pushedDpis, and settingsUpdated()\&.
.PP
Referenced by Kb::frameUpdate(), and Kb::hwSave()\&.
.PP
.nf
385                                                                                {
386     if(!force && !_needsUpdate)
387         return;
388     emit settingsUpdated();
389     _needsUpdate = false;
390     // Save DPI stage 0 (sniper)
391     // If the mouse is set to a custom DPI, save it in stage 0
392     int stage = pushedDpis\&.isEmpty() ? dpiBaseIdx : 0;
393     if(!pushedDpis\&.isEmpty() && saveCustomDpi) {
394         cmd\&.write(QString("dpi 0:%1,%2")\&.arg(dpiCurX)\&.arg(dpiCurY)\&.toLatin1());
395     } else {
396         // Otherwise, save stage 0 normally
397         cmd\&.write(QString("dpi 0:%1,%2")\&.arg(dpiX[0])\&.arg(dpiY[0])\&.toLatin1());
398     }
399     // Save stages 1 - 5
400     for(int i = 1; i < DPI_COUNT; i++){
401         if(!dpiOn[i] && stage != i)
402             cmd\&.write(QString(" %1:off")\&.arg(i)\&.toLatin1());
403         else
404         cmd\&.write(QString(" %1:%2,%3")\&.arg(i)\&.arg(dpiX[i])\&.arg(dpiY[i])\&.toLatin1());
405     }
406     // Save stage selection, lift height, and angle snap
407     cmd\&.write(QString(" dpisel %1 lift %2 snap %3")\&.arg(stage)\&.arg(_liftHeight)\&.arg(_angleSnap ? "on" : "off")\&.toLatin1());
408     // Save DPI colors
409     cmd\&.write(" rgb");
410     for(int i = 0; i < DPI_COUNT; i++){
411         QColor color = dpiColor(i);
412         cmd\&.write(" dpi");
413         char output[9];
414         snprintf(output, sizeof(output), "%1d:%02x%02x%02x", i, color\&.red(), color\&.green(), color\&.blue());
415         cmd\&.write(output);
416     }
417     // Enable indicator notifications
418     cmd\&.write(QString("\n@%1 inotify all")\&.arg(notifyNumber)\&.toLatin1());
419     // Set indicator state
420     const char* iNames[HW_I_COUNT] = { "num", "caps", "scroll" };
421     for(int i = 0; i < HW_I_COUNT; i++){
422         if(hwIType[i] == ON)
423             cmd\&.write(" ion ");
424         else if(hwIType[i] == OFF)
425             cmd\&.write(" ioff ");
426         else
427             cmd\&.write(" iauto ");
428         cmd\&.write(iNames[i]);
429     }
430 }
.fi
.SH "Field Documentation"
.PP 
.SS "bool KbPerf::_angleSnap\fC [private]\fP"

.PP
Definition at line 164 of file kbperf\&.h\&.
.PP
Referenced by angleSnap(), load(), operator=(), save(), and update()\&.
.SS "bool KbPerf::_dpiIndicator\fC [private]\fP"

.PP
Definition at line 160 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), dpiIndicator(), load(), operator=(), and save()\&.
.SS "float KbPerf::_iOpacity\fC [private]\fP"

.PP
Definition at line 155 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), iOpacity(), lightIndicator(), load(), and operator=()\&.
.SS "\fBheight\fP KbPerf::_liftHeight\fC [private]\fP"

.PP
Definition at line 163 of file kbperf\&.h\&.
.PP
Referenced by liftHeight(), load(), operator=(), save(), and update()\&.
.SS "bool KbPerf::_needsSave\fC [private]\fP"

.PP
Definition at line 166 of file kbperf\&.h\&.
.PP
Referenced by _curDpi(), angleSnap(), baseDpiIdx(), dpi(), dpiColor(), dpiEnabled(), dpiIndicator(), iOpacity(), liftHeight(), load(), needsSave(), operator=(), popDpi(), save(), and setIndicator()\&.
.SS "bool KbPerf::_needsUpdate\fC [private]\fP"

.PP
Definition at line 166 of file kbperf\&.h\&.
.PP
Referenced by _curDpi(), angleSnap(), baseDpiIdx(), dpi(), dpiColor(), dpiEnabled(), liftHeight(), operator=(), popDpi(), setIndicator(), setNeedsUpdate(), and update()\&.
.SS "const int KbPerf::DPI_COUNT = 6\fC [static]\fP"

.PP
Definition at line 46 of file kbperf\&.h\&.
.PP
Referenced by dpi(), dpiCycleDown(), dpiCycleUp(), dpiUp(), KbPerf(), KeyAction::keyEvent(), load(), operator=(), Kb::readNotify(), save(), RebindWidget::setBind(), and update()\&.
.SS "const int KbPerf::DPI_MAX = 12000\fC [static]\fP"

.PP
Definition at line 47 of file kbperf\&.h\&.
.SS "const int KbPerf::DPI_MIN = 100\fC [static]\fP"

.PP
Definition at line 47 of file kbperf\&.h\&.
.PP
Referenced by dpiExp(), and dpiLog()\&.
.SS "int KbPerf::dpiBaseIdx\fC [private]\fP"

.PP
Definition at line 142 of file kbperf\&.h\&.
.PP
Referenced by baseDpiIdx(), dpi(), KbPerf(), load(), operator=(), popDpi(), save(), and update()\&.
.SS "QColor KbPerf::dpiClr[\fBDPI_COUNT\fP+1]\fC [private]\fP"

.PP
Definition at line 143 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), dpiColor(), KbPerf(), load(), operator=(), and save()\&.
.SS "int KbPerf::dpiCurX\fC [private]\fP"

.PP
Definition at line 138 of file kbperf\&.h\&.
.PP
Referenced by _curDpi(), KbPerf(), operator=(), and update()\&.
.SS "int KbPerf::dpiCurY\fC [private]\fP"

.PP
Definition at line 138 of file kbperf\&.h\&.
.PP
Referenced by _curDpi(), KbPerf(), operator=(), and update()\&.
.SS "bool KbPerf::dpiOn[\fBDPI_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 144 of file kbperf\&.h\&.
.PP
Referenced by dpiCycleDown(), dpiCycleUp(), dpiDown(), dpiEnabled(), dpiUp(), KbPerf(), load(), operator=(), save(), and update()\&.
.SS "int KbPerf::dpiX[\fBDPI_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 135 of file kbperf\&.h\&.
.PP
Referenced by dpi(), KbPerf(), load(), operator=(), save(), and update()\&.
.SS "int KbPerf::dpiY[\fBDPI_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 136 of file kbperf\&.h\&.
.PP
Referenced by dpi(), KbPerf(), load(), operator=(), save(), and update()\&.
.SS "const int KbPerf::HW_I_COUNT = (int)\fBHW_IMAX\fP + 1\fC [static]\fP"

.PP
Definition at line 107 of file kbperf\&.h\&.
.PP
Referenced by KbPerf(), and update()\&.
.SS "\fBi_hw\fP KbPerf::hwIType[\fBHW_I_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 159 of file kbperf\&.h\&.
.PP
Referenced by getIndicator(), KbPerf(), load(), operator=(), save(), setIndicator(), and update()\&.
.SS "const int KbPerf::I_COUNT = (int)\fBMUTE\fP + 1\fC [static]\fP"

.PP
Definition at line 107 of file kbperf\&.h\&.
.PP
Referenced by getIndicator(), KbPerf(), load(), operator=(), save(), and setIndicator()\&.
.SS "QColor KbPerf::iColor[\fBI_COUNT\fP][2]\fC [private]\fP"

.PP
Definition at line 156 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), getIndicator(), KbPerf(), load(), operator=(), save(), and setIndicator()\&.
.SS "bool KbPerf::iEnable[\fBI_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 158 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), getIndicator(), KbPerf(), load(), operator=(), save(), and setIndicator()\&.
.SS "QColor KbPerf::light100Color\fC [private]\fP"

.PP
Definition at line 157 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), getIndicator(), KbPerf(), load(), operator=(), save(), and setIndicator()\&.
.SS "QColor KbPerf::muteNAColor\fC [private]\fP"

.PP
Definition at line 157 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), getIndicator(), KbPerf(), load(), operator=(), save(), and setIndicator()\&.
.SS "const int KbPerf::OTHER = \fBDPI_COUNT\fP\fC [static]\fP"

.PP
Definition at line 84 of file kbperf\&.h\&.
.PP
Referenced by applyIndicators(), MPerfWidget::colorChanged(), load(), save(), and MPerfWidget::setPerf()\&.
.SS "QMap<quint64, QPoint> KbPerf::pushedDpis\fC [private]\fP"

.PP
Definition at line 148 of file kbperf\&.h\&.
.PP
Referenced by baseDpiIdx(), dpi(), load(), popDpi(), pushDpi(), and update()\&.
.SS "uint KbPerf::runningPushIdx\fC [private]\fP"

.PP
Definition at line 149 of file kbperf\&.h\&.
.PP
Referenced by load(), operator=(), and pushDpi()\&.
.SS "const int KbPerf::SNIPER = 0\fC [static]\fP"

.PP
Definition at line 46 of file kbperf\&.h\&.
.PP
Referenced by dpiCycleDown(), dpiCycleUp(), dpiDown(), and sniperDpi()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
