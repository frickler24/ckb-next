.TH "RebindWidget" 3 "Sat Jan 20 2018" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RebindWidget \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/rebindwidget\&.h>\fP
.PP
Inherits \fBQWidget\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRebindWidget\fP (\fBQWidget\fP *parent)"
.br
.ti -1c
.RI "\fB~RebindWidget\fP ()"
.br
.ti -1c
.RI "void \fBsetBind\fP (\fBKbBind\fP *newBind, \fBKbProfile\fP *newProfile)"
.br
.ti -1c
.RI "void \fBsetSelection\fP (const QStringList &newSelection, bool applyPrevious=false)"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBapplyChanges\fP (const QStringList &keys, bool doUnbind)"
.br
.ti -1c
.RI "void \fBon_applyButton_clicked\fP ()"
.br
.ti -1c
.RI "void \fBon_cancelButton_clicked\fP ()"
.br
.ti -1c
.RI "void \fBon_resetButton_clicked\fP ()"
.br
.ti -1c
.RI "void \fBon_unbindButton_clicked\fP ()"
.br
.ti -1c
.RI "void \fBon_typingBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_modBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_fnBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_numBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_mediaBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_mbBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_mb2Box_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_wheelBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_dpiBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_modeBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_lightBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_lockBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_programKpBox_textChanged\fP (const QString &arg1)"
.br
.ti -1c
.RI "void \fBon_programKrBox_textChanged\fP (const QString &arg1)"
.br
.ti -1c
.RI "void \fBon_animBox_currentIndexChanged\fP (int index)"
.br
.ti -1c
.RI "void \fBon_typingButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_modButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_fnButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_numButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_mediaButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_mbButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_mb2Button_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_wheelButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_dpiButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_modeButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_lightButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_lockButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_programKpButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_programKrButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_programKpSIBox_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_programKrSIBox_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_animButton_clicked\fP (bool checked)"
.br
.ti -1c
.RI "void \fBon_pteMacroBox_textChanged\fP ()"
.br
.ti -1c
.RI "void \fBon_btnStartMacro_clicked\fP ()"
.br
.RI "\fI\fBRebindWidget::on_btnStartMacro_clicked\fP starts macro recording\&. A new notification channel and \fBMacroReader\fP are created to do the job\&. \fP"
.ti -1c
.RI "void \fBon_btnStopMacro_clicked\fP ()"
.br
.RI "\fI\fBRebindWidget::on_btnStopMacro_clicked\fP ends the macro recording\&. Notify channel ist closed, the ReaderThread is deleted when the notification is really down\&. \fP"
.ti -1c
.RI "void \fBon_btnClearMacro_clicked\fP ()"
.br
.RI "\fI\fBRebindWidget::on_btnClearMacro_clicked\fP changes the help info an the panel\&. The job of clearing the input panels is triggerd with signal/slot via the \fBRebindWidget\&.ui\fP file\&. \fP"
.ti -1c
.RI "void \fBon_rb_delay_no_toggled\fP (bool checked)"
.br
.RI "\fI\fBRebindWidget::on_rb_delay_no_toggled\fP\&. \fP"
.ti -1c
.RI "void \fBon_rb_delay_asTyped_toggled\fP (bool checked)"
.br
.RI "\fI\fBRebindWidget::on_rb_delay_asTyped_toggled\fP\&. \fP"
.ti -1c
.RI "void \fBon_rb_delay_default_toggled\fP (bool checked)"
.br
.RI "\fI\fBRebindWidget::on_rb_delay_default_toggled\fP\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBsetBox\fP (\fBQWidget\fP *box)"
.br
.ti -1c
.RI "void \fBconvertMacroBox\fP ()"
.br
.RI "\fI\fBRebindWidget::convertMacroBox\fP converts the macroBox content\&. The KB sends each keypress as 'key [+|-]<keyname><newline>' This is followed by timing information (delays between keystrokes)\&. \fP"
.ti -1c
.RI "void \fBhelpStatus\fP (int status)"
.br
.RI "\fI\fBRebindWidget::helpStatus\fP shows a help line in the ui\&. \fP"
.ti -1c
.RI "void \fBsetCorrectRadioButton\fP (QString macdef)"
.br
.RI "\fI\fBRebindWidget::setCorrectRadioButton\fP\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBUi::RebindWidget\fP * \fBui\fP"
.br
.ti -1c
.RI "\fBKbBind\fP * \fBbind\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBprofile\fP"
.br
.ti -1c
.RI "QStringList \fBselection\fP"
.br
.ti -1c
.RI "QStringList \fBtypingKeys\fP"
.br
.ti -1c
.RI "QStringList \fBmodKeys\fP"
.br
.ti -1c
.RI "QStringList \fBfnKeys\fP"
.br
.ti -1c
.RI "QStringList \fBnumKeys\fP"
.br
.ti -1c
.RI "QStringList \fBmediaKeys\fP"
.br
.ti -1c
.RI "QStringList \fBmouseKeys\fP"
.br
.ti -1c
.RI "QStringList \fBmouseExtKeys\fP"
.br
.ti -1c
.RI "QStringList \fBwheelKeys\fP"
.br
.ti -1c
.RI "\fBMacroReader\fP * \fBmacReader\fP"
.br
.RI "\fImacReader holds the \fBMacroReader\fP when macro recording starts\&. \fP"
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const int \fBTAB_KB\fP = 0"
.br
.ti -1c
.RI "static const int \fBTAB_MOUSE\fP = 1"
.br
.ti -1c
.RI "static const int \fBTAB_ANIM\fP = 2"
.br
.ti -1c
.RI "static const int \fBTAB_SPECIAL\fP = 3"
.br
.ti -1c
.RI "static const int \fBTAB_PROGRAM\fP = 4"
.br
.ti -1c
.RI "static const int \fBTAB_MACRO\fP = 5"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 15 of file rebindwidget\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "RebindWidget::RebindWidget (\fBQWidget\fP *parent)\fC [explicit]\fP"

.PP
Definition at line 9 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::fnBox, fnKeys, KeyMap::friendlyName(), Ui_RebindWidget::lightWrapBox, Ui_RebindWidget::mediaBox, mediaKeys, Ui_RebindWidget::modBox, Ui_RebindWidget::modeWrapBox, modKeys, mouseExtKeys, mouseKeys, Ui_RebindWidget::numBox, numKeys, Ui_RebindWidget::programKpExtra, Ui_RebindWidget::programKrExtra, Ui_RebindWidget::progTipLabel, Ui_RebindWidget::setupUi(), ui, and wheelKeys\&.
.PP
.nf
9                                           :
10     QWidget(parent),
11     ui(new Ui::RebindWidget),
12     bind(0), profile(0), macReader(0)
13 {
14     ui->setupUi(this);
15     ui->lightWrapBox->hide();
16     ui->modeWrapBox->hide();
17     ui->programKpExtra->hide();
18     ui->programKrExtra->hide();
19 
20     // Populate key lists
21     modKeys << "caps" << "lshift" << "rshift" << "lctrl" << "rctrl" << "lwin" << "rwin" << "lalt" << "ralt" << "rmenu" << "fn";
22     fnKeys << "esc" << "f1" << "f2" << "f3" << "f4" << "f5" << "f6" << "f7" << "f8" << "f9" << "f10" << "f11" << "f12" << "prtscn" << "scroll" << "pause" << "f13" << "f14" << "f15" << "f16" << "f17" << "f18" << "f19" << "f20" << "ins" << "del" << "home" << "end" << "pgup" << "pgdn" << "power" << "lightup" << "lightdn" << "up" << "down" << "left" << "right";
23     numKeys << "numlock" << "num0" << "num1" << "num2" << "num3" << "num4" << "num5" << "num6" << "num7" << "num8" << "num9" << "numslash" << "numstar" << "numminus" << "numplus" << "numdot" << "numenter";
24     mediaKeys << "stop" << "prev" << "play" << "next" << "volup" << "voldn" << "mute" << "eject";
25     mouseKeys << "mouse1" << "mouse2" << "mouse3";
26     mouseExtKeys << "mouse4" << "mouse5" << "mouse6" << "mouse7" << "mouse8";
27     wheelKeys << "wheelup" << "wheeldn";
28     // Populate boxes
29     foreach(const QString& key, modKeys)
30         ui->modBox->addItem(KeyMap::friendlyName(key));
31     foreach(const QString& key, fnKeys)
32         ui->fnBox->addItem(KeyMap::friendlyName(key)\&.replace("\n", " / "));
33     foreach(const QString& key, numKeys)
34         ui->numBox->addItem(KeyMap::friendlyName(key)\&.remove("NumPad "));
35     foreach(const QString& key, mediaKeys)
36         ui->mediaBox->addItem(KeyMap::friendlyName(key));
37 #ifdef Q_OS_MACX
38     // Replace some OSX keys with their actual meanings
39     ui->modBox->setItemText(modKeys\&.indexOf("lwin") + 1, "Left Cmd");
40     ui->modBox->setItemText(modKeys\&.indexOf("rwin") + 1, "Right Cmd");
41     ui->modBox->setItemText(modKeys\&.indexOf("lalt") + 1, "Left Option");
42     ui->modBox->setItemText(modKeys\&.indexOf("ralt") + 1, "Right Option");
43     ui->fnBox->setItemText(fnKeys\&.indexOf("prtscn") + 1, "F13");
44     ui->fnBox->setItemText(fnKeys\&.indexOf("scroll") + 1, "F14");
45     ui->fnBox->setItemText(fnKeys\&.indexOf("pause") + 1, "F15");
46     ui->fnBox->setItemText(fnKeys\&.indexOf("f13") + 1, "F13 (Windows/Linux)");
47     ui->fnBox->setItemText(fnKeys\&.indexOf("f14") + 1, "F14 (Windows/Linux)");
48     ui->fnBox->setItemText(fnKeys\&.indexOf("f15") + 1, "F15 (Windows/Linux)");
49     ui->fnBox->setItemText(fnKeys\&.indexOf("ins") + 1, "Help");
50     ui->numBox->setItemText(numKeys\&.indexOf("numlock") + 1, "Clear");
51 
52     // Add tip label
53     ui->progTipLabel->setText("<p style=\"line-height:150%\">Tip: use the <font face=\"monospace\">open</font> command to launch a file, directory, or app\&. For instance, to start Safari:<br /><font face=\"monospace\">&nbsp;&nbsp;open /Applications/Safari\&.app</font></p>");
54 #else
55     ui->progTipLabel->setText("<p style=\"line-height:150%\">Tip: use <font face=\"monospace\">xdg-open</font> to launch a file or directory\&. For instance, to open your home folder:<br /><font face=\"monospace\">&nbsp;&nbsp;xdg-open " + QStandardPaths::writableLocation(QStandardPaths::HomeLocation) + "</font></p>");
56 #endif
57 }
.fi
.SS "RebindWidget::~RebindWidget ()"

.PP
Definition at line 59 of file rebindwidget\&.cpp\&.
.PP
References ui\&.
.PP
.nf
59                            {
60     delete ui;
61 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void RebindWidget::applyChanges (const QStringList &keys, booldoUnbind)\fC [private]\fP, \fC [slot]\fP"
G-key macro handling: Set the macro definiton for all keys selected (indeed, it may be multiple keys)\&. First, concat the Macro \fBKey\fP Definion and the Macro plain text after escaping possible colos in the parts for Macro Text and Macro Comment\&.
.PP
But first, there is a special condition to handle: You have recorded a macro with timing infos\&. Afterwards you changed manually the timing infos in the pteMacroBox and press Apply\&. In that case we must overwrite the txtBuffer to remember your changes\&.
.PP
\fBTodo\fP
.RS 4
There is still a bug in the state machine: If you record a macro in asTyped-mode, switch to another mode and change the vontent of the pteMacroBox manually, then the changes are not saved in the timing buffer\&. But anyhow, let's do more relevant things\&.\&.\&. 
.RE
.PP

.PP
Definition at line 334 of file rebindwidget\&.cpp\&.
.PP
References anim, KeyAction::animAction(), Ui_RebindWidget::animBox, Ui_RebindWidget::animKrBox, KbLight::animList(), Ui_RebindWidget::animOnceBox, bind, DPI_OFFSET, KeyAction::dpiAction(), Ui_RebindWidget::dpiBox, Ui_RebindWidget::dpiCustXBox, Ui_RebindWidget::dpiCustYBox, Ui_RebindWidget::fnBox, fnKeys, KbAnim::guid(), KbBind::light(), KeyAction::lightAction(), Ui_RebindWidget::lightBox, Ui_RebindWidget::lightWrapBox, KeyAction::lockAction(), Ui_RebindWidget::lockBox, KeyAction::macroAction(), Ui_RebindWidget::mb2Box, Ui_RebindWidget::mbBox, Ui_RebindWidget::mediaBox, mediaKeys, Ui_RebindWidget::modBox, KeyAction::modeAction(), Ui_RebindWidget::modeBox, Ui_RebindWidget::modeWrapBox, modKeys, mouseExtKeys, mouseKeys, KbBind::noAction(), Ui_RebindWidget::numBox, numKeys, KeyAction::PROGRAM_PR_MULTI, KeyAction::PROGRAM_RE_INDEF, KeyAction::PROGRAM_RE_KPSTOP, KeyAction::PROGRAM_RE_MULTI, KeyAction::programAction(), Ui_RebindWidget::programKpBox, Ui_RebindWidget::programKpModeBox, Ui_RebindWidget::programKpSIBox, Ui_RebindWidget::programKrBox, Ui_RebindWidget::programKrModeBox, Ui_RebindWidget::programKrSIBox, Ui_RebindWidget::pteMacroBox, Ui_RebindWidget::pteMacroComment, Ui_RebindWidget::pteMacroText, Ui_RebindWidget::rb_delay_asTyped, KbBind::setAction(), Ui_RebindWidget::txtBuffer, Ui_RebindWidget::typingBox, typingKeys, ui, Ui_RebindWidget::wheelBox, and wheelKeys\&.
.PP
Referenced by on_applyButton_clicked(), and setSelection()\&.
.PP
.nf
334                                                                      {
335     if(ui->typingBox->currentIndex() > 0)
336         bind->setAction(keys, typingKeys[ui->typingBox->currentIndex() - 1]);
337     else if(ui->modBox->currentIndex() > 0)
338         bind->setAction(keys, modKeys[ui->modBox->currentIndex() - 1]);
339     else if(ui->fnBox->currentIndex() > 0)
340         bind->setAction(keys, fnKeys[ui->fnBox->currentIndex() - 1]);
341     else if(ui->numBox->currentIndex() > 0)
342         bind->setAction(keys, numKeys[ui->numBox->currentIndex() - 1]);
343     else if(ui->mediaBox->currentIndex() > 0)
344         bind->setAction(keys, mediaKeys[ui->mediaBox->currentIndex() - 1]);
345     else if(ui->mbBox->currentIndex() > 0)
346         bind->setAction(keys, mouseKeys[ui->mbBox->currentIndex() - 1]);
347     else if(ui->mb2Box->currentIndex() > 0)
348         bind->setAction(keys, mouseExtKeys[ui->mb2Box->currentIndex() - 1]);
349     else if(ui->wheelBox->currentIndex() > 0)
350         bind->setAction(keys, wheelKeys[ui->wheelBox->currentIndex() - 1]);
351     else if(ui->dpiBox->currentIndex() > 0)
352         bind->setAction(keys, KeyAction::dpiAction(ui->dpiBox->currentIndex() - DPI_OFFSET, ui->dpiCustXBox->value(), ui->dpiCustYBox->value()));
353     else if(ui->modeBox->currentIndex() > 0)
354         bind->setAction(keys, KeyAction::modeAction(ui->modeBox->currentIndex() - 3 - (ui->modeWrapBox->isChecked() && ui->modeBox->currentIndex() < 3 ? 2 : 0)));
355     else if(ui->lightBox->currentIndex() > 0)
356         bind->setAction(keys, KeyAction::lightAction(ui->lightBox->currentIndex() - 1 + (ui->lightWrapBox->isChecked() ? 2 : 0)));
357     else if(ui->lockBox->currentIndex() > 0)
358         bind->setAction(keys, KeyAction::lockAction(ui->lockBox->currentIndex() - 1));
359     else if(ui->animBox->currentIndex() > 0){
360         KbAnim* anim = bind->light()->animList()\&.at(ui->animBox->currentIndex() - 1);
361         bind->setAction(keys, KeyAction::animAction(anim->guid(), !ui->animOnceBox->isChecked(), ui->animKrBox->isChecked()));
362     } else if(!ui->programKpBox->text()\&.isEmpty() || !ui->programKrBox->text()\&.isEmpty()){
363         int kpStop = 0, krStop = 0;
364         if(!ui->programKpBox->text()\&.isEmpty()){
365             if(!ui->programKpSIBox->isChecked())
366                 kpStop = KeyAction::PROGRAM_PR_MULTI;
367             else
368                 kpStop = ui->programKpModeBox->currentIndex();
369         }
370         if(!ui->programKrBox->text()\&.isEmpty()){
371             if(!ui->programKrSIBox->isChecked())
372                 krStop = KeyAction::PROGRAM_RE_MULTI;
373             else if(ui->programKrModeBox->currentIndex() == 0)
374                 krStop = KeyAction::PROGRAM_RE_INDEF;
375             else
376                 krStop = KeyAction::PROGRAM_RE_KPSTOP;
377         }
378         bind->setAction(keys, KeyAction::programAction(ui->programKpBox->text(), ui->programKrBox->text(), kpStop | krStop));
379     } else if (ui->pteMacroBox->toPlainText()\&.length() > 0) {
384 
389         if (ui->rb_delay_asTyped->isChecked()) ui->txtBuffer->setText(ui->pteMacroBox->toPlainText());
390 
396         QString mac;
397         mac = ui->txtBuffer->text();
398         mac = ui->pteMacroComment->toPlainText()\&.replace(":", "&das_IST_31N_col0n;") + ":" + mac;
399         mac = ui->pteMacroText->toPlainText()\&.replace(":", "&das_IST_31N_col0n;") + ":" + mac;
400         mac = ui->pteMacroBox->toPlainText() + ":" + mac;
401         bind->setAction(keys, KeyAction::macroAction(mac));
402     } else if(doUnbind)
403         bind->noAction(keys);
404 }
.fi
.SS "void RebindWidget::convertMacroBox ()\fC [private]\fP"
The ckb-daemon needs a shorter format, only ' [+|-]<keyname>=<delay>', multiple entries are separated by comma\&.
.PP
That function does the conversion\&. 
.PP
Definition at line 808 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::pteMacroBox, Ui_RebindWidget::rb_delay_default, Ui_RebindWidget::rb_delay_no, Ui_RebindWidget::txtBuffer, and ui\&.
.PP
Referenced by on_btnStopMacro_clicked(), on_rb_delay_asTyped_toggled(), on_rb_delay_default_toggled(), and on_rb_delay_no_toggled()\&.
.PP
.nf
808                                    {
809     QString in;
810 
811     // Remember the original input stream before it is converted\&.
812     // In case of new choice of delay mode we have to restore it\&.
813     if (ui->txtBuffer->text() == "") {
814         ui->txtBuffer->setText(ui->pteMacroBox->toPlainText());
815         in = ui->pteMacroBox->toPlainText();
816     } else in = ui->txtBuffer->text();
817 
818     in\&.replace (QRegExp("\n"), ",");    // first join all in one line
819     in\&.replace (QRegExp("key "), "");   // then delete keyword "key" followed by space
820     in\&.replace (QRegExp(",="), "=");    // at last join each keystroke with its delay parameter
821 
822     // How to deal with the delay params?
823     // Because the three radio buttons are mututally exclusive,
824     // we can run through the if-chain w/o conflicts\&.
825     // If rb_delay_asTyped is checked, do nothing, because that's the standard\&.
826 
827     if (ui->rb_delay_default->isChecked()) {
828         in\&.replace(QRegExp("=\\d+,"), ",");  // Delete the timing infos, use default value
829         in\&.replace(QRegExp("=\\d+$"), "");   // The last entry is without comma
830     }
831     if (ui->rb_delay_no->isChecked()) {
832         in\&.replace(QRegExp("=\\d+,"), "=0,");  // Set timing infos to zero for no delay
833         in\&.replace(QRegExp("=\\d+$"), "=0");   // Again the last entry w/o comma
834         in\&.replace(QRegExp("([\\+\\-]\\w+),"), "\\1=0,");  // If no delay is given, force it to zero
835         in\&.replace(QRegExp("([\\+\\-]\\w+)$"), "\\1=0");
836     }
837 
838     // Show the new format by replacing the older one\&.
839     ui->pteMacroBox->setPlainText(in);
840 }
.fi
.SS "void RebindWidget::helpStatus (intstatus)\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIstatus\fP determines what to display\&. 
.RE
.PP

.PP
Definition at line 782 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::lbl_macro, and ui\&.
.PP
Referenced by on_btnClearMacro_clicked(), on_btnStartMacro_clicked(), on_btnStopMacro_clicked(), and setBox()\&.
.PP
.nf
782                                         {
783     switch (status) {
784     case 1:
785         ui->lbl_macro->setText("Type in a macro name in the comment box and click start\&.");
786         break;
787     case 2:
788         ui->lbl_macro->setText("Type your macro and click stop when finished\&.");
789         break;
790     case 3:
791         ui->lbl_macro->setText("Click Apply or change values in Macro Key Actions in advance\&.");
792         break;
793     default:
794         ui->lbl_macro->setText(QString("Oops: Some magic in RebindWidget::helpStatus (%1)")\&.arg(status));
795     }
796 }
.fi
.SS "void RebindWidget::on_animBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 613 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::animBox, Ui_RebindWidget::animButton, setBox(), and ui\&.
.PP
.nf
613                                                           {
614     if(index == 0)
615         ui->animButton->setChecked(false);
616     else {
617         ui->animButton->setChecked(true);
618         setBox(ui->animBox);
619     }
620 }
.fi
.SS "void RebindWidget::on_animButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 710 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::animBox, and ui\&.
.PP
.nf
710                                                     {
711     if(checked && ui->animBox->currentIndex() == 0)
712         ui->animBox->setCurrentIndex(1);
713 }
.fi
.SS "void RebindWidget::on_applyButton_clicked ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 406 of file rebindwidget\&.cpp\&.
.PP
References applyChanges(), on_btnStopMacro_clicked(), and selection\&.
.PP
.nf
406                                          {
407     // Normally, this should be done via signalling\&.
408     // Because there is no serarate thread, we have to call it directly
409     // (otherwise we could do Key char conversion step by step,
410     // but so it is more easy to change the key definition):
411     on_btnStopMacro_clicked();
412     applyChanges(selection, true);
413 }
.fi
.SS "void RebindWidget::on_btnClearMacro_clicked ()\fC [private]\fP, \fC [slot]\fP"

.PP
\fBTodo\fP
.RS 4
I do not know what is the better solution with the delay-buttons in case of clicking clear: Reset the button to the default value or do not touch it? Not clear is ignored\&. 
.RE
.PP

.PP
Definition at line 774 of file rebindwidget\&.cpp\&.
.PP
References helpStatus()\&.
.PP
.nf
774                                             {
775     helpStatus(1);
776 }
.fi
.SS "void RebindWidget::on_btnStartMacro_clicked ()\fC [private]\fP, \fC [slot]\fP"
The UI is protected against false clicking (e\&.g\&. if you type start and than Apply, the channel is closed in wrong order)\&.
.PP
At this time, all neccessary params like macroNumber, macroPath, cmdFile etc\&. had been cached\&. 
.PP
Definition at line 724 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::applyButton, bind, Ui_RebindWidget::btnStartMacro, Ui_RebindWidget::btnStopMacro, KbBind::getMacroNumber(), KbBind::getMacroPath(), KbBind::handleNotificationChannel(), helpStatus(), macReader, Ui_RebindWidget::pteMacroBox, Ui_RebindWidget::pteMacroText, Ui_RebindWidget::rb_delay_asTyped, Ui_RebindWidget::rb_delay_default, Ui_RebindWidget::rb_delay_no, Ui_RebindWidget::resetButton, ui, and Ui_RebindWidget::unbindButton\&.
.PP
.nf
724                                             {
725     if (!macReader) {
726         bind->handleNotificationChannel(true);
727         macReader = new MacroReader(bind->getMacroNumber(), bind->getMacroPath(), ui->pteMacroBox, ui->pteMacroText);
728         // because of the second thread we need to disable three of the four bottom buttons\&.
729         // Clicking "Stop" will enable them again\&.
730         ui->applyButton->setEnabled(false);
731         ui->resetButton->setEnabled(false);
732         ui->unbindButton->setEnabled(false);
733         ui->btnStartMacro->setEnabled(false);
734         ui->btnStopMacro->setEnabled(true);
735         ui->rb_delay_asTyped->setEnabled(false);
736         ui->rb_delay_no->setEnabled(false);
737         ui->rb_delay_default->setEnabled(false);
738         helpStatus(2);
739     }
740 }
.fi
.SS "void RebindWidget::on_btnStopMacro_clicked ()\fC [private]\fP, \fC [slot]\fP"
Afterwards, the characters in the MacroBox are changed from KB-out format to cmd-in format\&. At last the UI changes to the new state\&. 
.PP
Definition at line 749 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::applyButton, bind, Ui_RebindWidget::btnStartMacro, Ui_RebindWidget::btnStopMacro, convertMacroBox(), KbBind::handleNotificationChannel(), helpStatus(), macReader, Ui_RebindWidget::rb_delay_asTyped, Ui_RebindWidget::rb_delay_default, Ui_RebindWidget::rb_delay_no, Ui_RebindWidget::resetButton, ui, and Ui_RebindWidget::unbindButton\&.
.PP
Referenced by on_applyButton_clicked()\&.
.PP
.nf
749                                            {
750     if (macReader) {
751         bind->handleNotificationChannel(false);
752         delete macReader;
753         macReader = 0;
754         convertMacroBox();
755         ui->applyButton->setEnabled(true);
756         ui->resetButton->setEnabled(true);
757         ui->unbindButton->setEnabled(true);
758         ui->btnStartMacro->setEnabled(true);
759         ui->btnStopMacro->setEnabled(false);
760         ui->rb_delay_asTyped->setEnabled(true);
761         ui->rb_delay_no->setEnabled(true);
762         ui->rb_delay_default->setEnabled(true);
763         helpStatus(3);
764     }
765 }
.fi
.SS "void RebindWidget::on_cancelButton_clicked ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 415 of file rebindwidget\&.cpp\&.
.PP
References selection, and setSelection()\&.
.PP
.nf
415                                           {
416     // Re-load selection
417     setSelection(selection);
418 }
.fi
.SS "void RebindWidget::on_dpiBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 539 of file rebindwidget\&.cpp\&.
.PP
References DPI_CUST_IDX, Ui_RebindWidget::dpiBox, Ui_RebindWidget::dpiButton, Ui_RebindWidget::dpiCustLabel, Ui_RebindWidget::dpiCustXBox, Ui_RebindWidget::dpiCustYBox, setBox(), and ui\&.
.PP
.nf
539                                                          {
540     if(index != DPI_CUST_IDX){
541         // Clear custom DPI
542         ui->dpiCustXBox->setEnabled(false);
543         ui->dpiCustYBox->setEnabled(false);
544         ui->dpiCustLabel->setEnabled(false);
545     } else {
546         ui->dpiCustXBox->setEnabled(true);
547         ui->dpiCustYBox->setEnabled(true);
548         ui->dpiCustLabel->setEnabled(true);
549     }
550     if(index == 0)
551         ui->dpiButton->setChecked(false);
552     else {
553         ui->dpiButton->setChecked(true);
554         setBox(ui->dpiBox);
555     }
556 }
.fi
.SS "void RebindWidget::on_dpiButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 695 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::dpiBox, and ui\&.
.PP
.nf
695                                                    {
696     if(checked && ui->dpiBox->currentIndex() == 0)
697         ui->dpiBox->setCurrentIndex(1);
698 }
.fi
.SS "void RebindWidget::on_fnBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 485 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::fnBox, Ui_RebindWidget::fnButton, setBox(), and ui\&.
.PP
.nf
485                                                         {
486     if(index == 0)
487         ui->fnButton->setChecked(false);
488     else {
489         ui->fnButton->setChecked(true);
490         setBox(ui->fnBox);
491     }
492 }
.fi
.SS "void RebindWidget::on_fnButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 632 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::fnBox, and ui\&.
.PP
.nf
632                                                   {
633     if(checked && ui->fnBox->currentIndex() == 0)
634         ui->fnBox->setCurrentIndex(1);
635 }
.fi
.SS "void RebindWidget::on_lightBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 571 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::lightBox, Ui_RebindWidget::lightButton, Ui_RebindWidget::lightWrapBox, setBox(), and ui\&.
.PP
.nf
571                                                            {
572     if(index == 0){
573         ui->lightButton->setChecked(false);
574         ui->lightWrapBox->hide();
575     } else {
576         ui->lightWrapBox->show();
577         ui->lightButton->setChecked(true);
578         setBox(ui->lightBox);
579     }
580 }
.fi
.SS "void RebindWidget::on_lightButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 652 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::lightBox, and ui\&.
.PP
.nf
652                                                      {
653     if(checked && ui->lightBox->currentIndex() == 0)
654         ui->lightBox->setCurrentIndex(1);
655 }
.fi
.SS "void RebindWidget::on_lockBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 582 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::lockBox, Ui_RebindWidget::lockButton, setBox(), and ui\&.
.PP
.nf
582                                                           {
583     if(index == 0)
584         ui->lockButton->setChecked(false);
585     else {
586         ui->lockButton->setChecked(true);
587         setBox(ui->lockBox);
588     }
589 }
.fi
.SS "void RebindWidget::on_lockButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 657 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::lockBox, and ui\&.
.PP
.nf
657                                                     {
658     if(checked && ui->lockBox->currentIndex() == 0)
659         ui->lockBox->setCurrentIndex(1);
660 }
.fi
.SS "void RebindWidget::on_mb2Box_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 521 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::mb2Box, Ui_RebindWidget::mb2Button, setBox(), and ui\&.
.PP
.nf
521                                                          {
522     if(index == 0)
523         ui->mb2Button->setChecked(false);
524     else {
525         ui->mb2Button->setChecked(true);
526         setBox(ui->mb2Box);
527     }
528 }
.fi
.SS "void RebindWidget::on_mb2Button_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 685 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::mb2Box, and ui\&.
.PP
.nf
685                                                    {
686     if(checked && ui->mb2Box->currentIndex() == 0)
687         ui->mb2Box->setCurrentIndex(1);
688 }
.fi
.SS "void RebindWidget::on_mbBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 512 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::mbBox, Ui_RebindWidget::mbButton, setBox(), and ui\&.
.PP
.nf
512                                                         {
513     if(index == 0)
514         ui->mbButton->setChecked(false);
515     else {
516         ui->mbButton->setChecked(true);
517         setBox(ui->mbBox);
518     }
519 }
.fi
.SS "void RebindWidget::on_mbButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 680 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::mbBox, and ui\&.
.PP
.nf
680                                                   {
681     if(checked && ui->mbBox->currentIndex() == 0)
682         ui->mbBox->setCurrentIndex(1);
683 }
.fi
.SS "void RebindWidget::on_mediaBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 503 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::mediaBox, Ui_RebindWidget::mediaButton, setBox(), and ui\&.
.PP
.nf
503                                                            {
504     if(index == 0)
505         ui->mediaButton->setChecked(false);
506     else {
507         ui->mediaButton->setChecked(true);
508         setBox(ui->mediaBox);
509     }
510 }
.fi
.SS "void RebindWidget::on_mediaButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 642 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::mediaBox, and ui\&.
.PP
.nf
642                                                      {
643     if(checked && ui->mediaBox->currentIndex() == 0)
644         ui->mediaBox->setCurrentIndex(1);
645 }
.fi
.SS "void RebindWidget::on_modBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 476 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::modBox, Ui_RebindWidget::modButton, setBox(), and ui\&.
.PP
.nf
476                                                          {
477     if(index == 0)
478         ui->modButton->setChecked(false);
479     else {
480         ui->modButton->setChecked(true);
481         setBox(ui->modBox);
482     }
483 }
.fi
.SS "void RebindWidget::on_modButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 627 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::modBox, and ui\&.
.PP
.nf
627                                                    {
628     if(checked && ui->modBox->currentIndex() == 0)
629         ui->modBox->setCurrentIndex(1);
630 }
.fi
.SS "void RebindWidget::on_modeBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 558 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::modeBox, Ui_RebindWidget::modeButton, Ui_RebindWidget::modeWrapBox, setBox(), and ui\&.
.PP
.nf
558                                                           {
559     if(index == 1 || index == 2)
560         ui->modeWrapBox->show();
561     else
562         ui->modeWrapBox->hide();
563     if(index == 0)
564         ui->modeButton->setChecked(false);
565     else {
566         ui->modeButton->setChecked(true);
567         setBox(ui->modeBox);
568     }
569 }
.fi
.SS "void RebindWidget::on_modeButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 647 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::modeBox, and ui\&.
.PP
.nf
647                                                     {
648     if(checked && ui->modeBox->currentIndex() == 0)
649         ui->modeBox->setCurrentIndex(1);
650 }
.fi
.SS "void RebindWidget::on_numBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 494 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::numBox, Ui_RebindWidget::numButton, setBox(), and ui\&.
.PP
.nf
494                                                          {
495     if(index == 0)
496         ui->numButton->setChecked(false);
497     else {
498         ui->numButton->setChecked(true);
499         setBox(ui->numBox);
500     }
501 }
.fi
.SS "void RebindWidget::on_numButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 637 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::numBox, and ui\&.
.PP
.nf
637                                                    {
638     if(checked && ui->numBox->currentIndex() == 0)
639         ui->numBox->setCurrentIndex(1);
640 }
.fi
.SS "void RebindWidget::on_programKpBox_textChanged (const QString &arg1)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 591 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::programKpBox, Ui_RebindWidget::programKpButton, Ui_RebindWidget::programKpExtra, setBox(), and ui\&.
.PP
.nf
591                                                                  {
592     if(arg1\&.isEmpty()){
593         ui->programKpButton->setChecked(false);
594         ui->programKpExtra->hide();
595     } else {
596         ui->programKpButton->setChecked(true);
597         setBox(ui->programKpBox);
598         ui->programKpExtra->show();
599     }
600 }
.fi
.SS "void RebindWidget::on_programKpButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 662 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::programKpBox, setBox(), and ui\&.
.PP
.nf
662                                                          {
663     if(!checked){
664         ui->programKpBox->setText("");
665     } else if(ui->programKpBox->text()\&.isEmpty()){
666         ui->programKpBox->setFocus();
667         setBox(ui->programKpBox);
668     }
669 }
.fi
.SS "void RebindWidget::on_programKpSIBox_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 700 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::programKpModeBox, and ui\&.
.PP
.nf
700                                                         {
701     ui->programKpModeBox->setCurrentIndex(0);
702     ui->programKpModeBox->setEnabled(checked);
703 }
.fi
.SS "void RebindWidget::on_programKrBox_textChanged (const QString &arg1)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 602 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::programKrBox, Ui_RebindWidget::programKrButton, Ui_RebindWidget::programKrExtra, setBox(), and ui\&.
.PP
.nf
602                                                                  {
603     if(arg1\&.isEmpty()){
604         ui->programKrButton->setChecked(false);
605         ui->programKrExtra->hide();
606     } else {
607         ui->programKrButton->setChecked(true);
608         setBox(ui->programKrBox);
609         ui->programKrExtra->show();
610     }
611 }
.fi
.SS "void RebindWidget::on_programKrButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 671 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::programKrBox, setBox(), and ui\&.
.PP
.nf
671                                                          {
672     if(!checked){
673         ui->programKrBox->setText("");
674     } else if(ui->programKrBox->text()\&.isEmpty()){
675         ui->programKrBox->setFocus();
676         setBox(ui->programKrBox);
677     }
678 }
.fi
.SS "void RebindWidget::on_programKrSIBox_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 705 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::programKrModeBox, and ui\&.
.PP
.nf
705                                                         {
706     ui->programKrModeBox->setCurrentIndex(0);
707     ui->programKrModeBox->setEnabled(checked);
708 }
.fi
.SS "void RebindWidget::on_pteMacroBox_textChanged ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 470 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::pteMacroBox, setBox(), and ui\&.
.PP
.nf
470                                               {
471     if (ui->pteMacroBox->toPlainText()\&.length() > 0) {
472         setBox(ui->pteMacroBox);
473     }
474 }
.fi
.SS "void RebindWidget::on_rb_delay_asTyped_toggled (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIchecked\fP This button ist clicked to use the delay times, as they are recorded\&. Returs a warning message, if we are not in the recording phase, because then we don't have the delay times any more\&. 
.RE
.PP

.PP
Definition at line 862 of file rebindwidget\&.cpp\&.
.PP
References convertMacroBox()\&.
.PP
.nf
863 {
864     convertMacroBox();
865 }
.fi
.SS "void RebindWidget::on_rb_delay_default_toggled (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIchecked\fP This is as easy as the no-delay-button, because this means take the default values\&. 
.RE
.PP

.PP
Definition at line 873 of file rebindwidget\&.cpp\&.
.PP
References convertMacroBox()\&.
.PP
.nf
874 {
875     convertMacroBox();
876 }
.fi
.SS "void RebindWidget::on_rb_delay_no_toggled (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIchecked\fP The following slots are triggerd by changing the mutual exclusive radio buttons when choosing the delay\&. They are called, if the button ist enabled\&. This first one should disable all delay\&. 
.RE
.PP

.PP
Definition at line 850 of file rebindwidget\&.cpp\&.
.PP
References convertMacroBox()\&.
.PP
.nf
851 {
852     convertMacroBox();
853 }
.fi
.SS "void RebindWidget::on_resetButton_clicked ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 420 of file rebindwidget\&.cpp\&.
.PP
References bind, KbBind::resetAction(), and selection\&.
.PP
.nf
420                                          {
421     bind->resetAction(selection);
422 }
.fi
.SS "void RebindWidget::on_typingBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 461 of file rebindwidget\&.cpp\&.
.PP
References setBox(), Ui_RebindWidget::typingBox, Ui_RebindWidget::typingButton, and ui\&.
.PP
.nf
461                                                             {
462     if(index == 0)
463         ui->typingButton->setChecked(false);
464     else {
465         ui->typingButton->setChecked(true);
466         setBox(ui->typingBox);
467     }
468 }
.fi
.SS "void RebindWidget::on_typingButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 622 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::typingBox, and ui\&.
.PP
.nf
622                                                       {
623     if(checked && ui->typingBox->currentIndex() == 0)
624         ui->typingBox->setCurrentIndex(1);
625 }
.fi
.SS "void RebindWidget::on_unbindButton_clicked ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 424 of file rebindwidget\&.cpp\&.
.PP
References bind, KbBind::noAction(), and selection\&.
.PP
.nf
424                                           {
425     bind->noAction(selection);
426 }
.fi
.SS "void RebindWidget::on_wheelBox_currentIndexChanged (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 530 of file rebindwidget\&.cpp\&.
.PP
References setBox(), ui, Ui_RebindWidget::wheelBox, and Ui_RebindWidget::wheelButton\&.
.PP
.nf
530                                                            {
531     if(index == 0)
532         ui->wheelButton->setChecked(false);
533     else {
534         ui->wheelButton->setChecked(true);
535         setBox(ui->wheelBox);
536     }
537 }
.fi
.SS "void RebindWidget::on_wheelButton_clicked (boolchecked)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 690 of file rebindwidget\&.cpp\&.
.PP
References ui, and Ui_RebindWidget::wheelBox\&.
.PP
.nf
690                                                      {
691     if(checked && ui->wheelBox->currentIndex() == 0)
692         ui->wheelBox->setCurrentIndex(1);
693 }
.fi
.SS "void RebindWidget::setBind (\fBKbBind\fP *newBind, \fBKbProfile\fP *newProfile)"

.PP
Definition at line 63 of file rebindwidget\&.cpp\&.
.PP
References bind, KeyMap::byPosition(), KbBind::defaultAction(), KbPerf::dpi(), KbPerf::DPI_COUNT, DPI_OFFSET, Ui_RebindWidget::dpiBox, Ui_RebindWidget::dpiButton, Ui_RebindWidget::dpiCustLabel, Ui_RebindWidget::dpiCustXBox, Ui_RebindWidget::dpiCustYBox, Ui_RebindWidget::dpiWarning, fnKeys, Key::friendlyName(), KeyMap::isISO(), KbBind::isMouse(), KeyMap::K95, KeyMap::layout(), KbBind::map(), mediaKeys, Ui_RebindWidget::modeBox, KbProfile::modes(), modKeys, KbMode::name(), numKeys, KbBind::perf(), profile, setSelection(), Ui_RebindWidget::typingBox, typingKeys, and ui\&.
.PP
Referenced by KbBindWidget::newLayout(), and KbBindWidget::setBind()\&.
.PP
.nf
63                                                                 {
64     bind = newBind;
65     profile = newProfile;
66     setSelection(QStringList());
67 
68     // Populate typing keys by position
69     ui->typingBox->clear();
70     ui->typingBox->addItem(" ");
71     typingKeys\&.clear();
72     // Use the K95 map as it has all keys
73     const KeyMap& map = KeyMap(KeyMap::K95, bind->map()\&.layout());
74     foreach(const QString& name, map\&.byPosition()){
75         KeyAction action(bind->defaultAction(name));
76         if(action\&.isNormal() && !modKeys\&.contains(name) && !fnKeys\&.contains(name) && !numKeys\&.contains(name) && !mediaKeys\&.contains(name) && name != "enter" && name != "tab" && name != "bspace"){
77             const Key& pos = map[name];
78             QString friendly = pos\&.friendlyName();
79             ui->typingBox->addItem(friendly);
80             typingKeys\&.append(name);
81         }
82     }
83     typingKeys << "enter" << "tab" << "bspace";
84     ui->typingBox->addItem("Enter");
85     ui->typingBox->addItem("Tab");
86     ui->typingBox->addItem("Backspace");
87     if(!map\&.isISO()){
88         // Add ISO backslash (aka KEY_102ND) to ANSI options
89         typingKeys << "bslash_iso";
90         ui->typingBox->addItem("Backslash (ISO layout)");
91     }
92 
93     // Populate mode list
94     ui->modeBox->clear();
95     ui->modeBox->addItem(" ");
96     ui->modeBox->addItem("(Previous)");
97     ui->modeBox->addItem("(Next)");
98     int idx = 1;
99     foreach(KbMode* mode, newProfile->modes())
100         ui->modeBox->addItem(QString("%1: %2")\&.arg(idx++)\&.arg(mode->name()));
101 
102     // Enable/disable DPI based on device
103     if(bind->isMouse()){
104         ui->dpiButton->setEnabled(true);
105         ui->dpiBox->setEnabled(true);
106         ui->dpiWarning->hide();
107         // Fill DPI slots
108         const KbPerf* perf = bind->perf();
109         for(int i = 0; i < KbPerf::DPI_COUNT; i++){
110             bool sniper = (i == 0);
111             int boxIdx = i + DPI_OFFSET;
112             QPoint dpi = perf->dpi(i);
113             QString text = tr(sniper ? "Sniper:\t%1 x %2" : "%3:\t%1 x %2")\&.arg(dpi\&.x())\&.arg(dpi\&.y());
114             if(!sniper) text = text\&.arg(i);
115             ui->dpiBox->setItemText(boxIdx, text);
116         }
117     } else {
118         ui->dpiButton->setEnabled(false);
119         ui->dpiBox->setEnabled(false);
120         ui->dpiWarning->show();
121     }
122     // Always disable custom DPI boxes until selected
123     ui->dpiCustXBox->setEnabled(false);
124     ui->dpiCustYBox->setEnabled(false);
125     ui->dpiCustLabel->setEnabled(false);
126 }
.fi
.SS "void RebindWidget::setBox (\fBQWidget\fP *box)\fC [private]\fP"

.PP
Definition at line 428 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::animBox, Ui_RebindWidget::dpiBox, Ui_RebindWidget::fnBox, helpStatus(), Ui_RebindWidget::lightBox, Ui_RebindWidget::lockBox, Ui_RebindWidget::mb2Box, Ui_RebindWidget::mbBox, Ui_RebindWidget::mediaBox, Ui_RebindWidget::modBox, Ui_RebindWidget::modeBox, Ui_RebindWidget::numBox, Ui_RebindWidget::programKpBox, Ui_RebindWidget::programKpButton, Ui_RebindWidget::programKrBox, Ui_RebindWidget::programKrButton, Ui_RebindWidget::pteMacroBox, Ui_RebindWidget::txtBuffer, Ui_RebindWidget::typingBox, ui, and Ui_RebindWidget::wheelBox\&.
.PP
Referenced by on_animBox_currentIndexChanged(), on_dpiBox_currentIndexChanged(), on_fnBox_currentIndexChanged(), on_lightBox_currentIndexChanged(), on_lockBox_currentIndexChanged(), on_mb2Box_currentIndexChanged(), on_mbBox_currentIndexChanged(), on_mediaBox_currentIndexChanged(), on_modBox_currentIndexChanged(), on_modeBox_currentIndexChanged(), on_numBox_currentIndexChanged(), on_programKpBox_textChanged(), on_programKpButton_clicked(), on_programKrBox_textChanged(), on_programKrButton_clicked(), on_pteMacroBox_textChanged(), on_typingBox_currentIndexChanged(), on_wheelBox_currentIndexChanged(), and setSelection()\&.
.PP
.nf
428                                      {
429     // Un-select every item except for the current one\&.
430     // on_*_currentIndexChanged will take care of deselecting the checkbox\&.
431     // Key
432     if(box != ui->typingBox) ui->typingBox->setCurrentIndex(0);
433     if(box != ui->modBox) ui->modBox->setCurrentIndex(0);
434     if(box != ui->fnBox) ui->fnBox->setCurrentIndex(0);
435     if(box != ui->numBox) ui->numBox->setCurrentIndex(0);
436     if(box != ui->mediaBox) ui->mediaBox->setCurrentIndex(0);
437     // Mouse
438     if(box != ui->mbBox) ui->mbBox->setCurrentIndex(0);
439     if(box != ui->mb2Box) ui->mb2Box->setCurrentIndex(0);
440     if(box != ui->wheelBox) ui->wheelBox->setCurrentIndex(0);
441     if(box != ui->dpiBox) ui->dpiBox->setCurrentIndex(0);
442     // Anim
443     if(box != ui->animBox) ui->animBox->setCurrentIndex(0);
444     // Special
445     if(box != ui->modeBox) ui->modeBox->setCurrentIndex(0);
446     if(box != ui->lightBox) ui->lightBox->setCurrentIndex(0);
447     if(box != ui->lockBox) ui->lockBox->setCurrentIndex(0);
448     // Program
449     if(box != ui->programKpBox && box != ui->programKrBox){
450         ui->programKpButton->setChecked(false);
451         ui->programKrButton->setChecked(false);
452     }
453     // Clear macro panel
454     if (box != ui->pteMacroBox) {
455         ui->pteMacroBox->setPlainText("");
456         ui->txtBuffer->setText("");
457         helpStatus(1);
458     }
459 }
.fi
.SS "void RebindWidget::setCorrectRadioButton (QStringmacdef)\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fImacdef\fP Set the radiobutton for timing paramters according to the context\&. If no '=' followed by a number and comma can be found, it is the default button\&. If '=' can be found and numbers with more than one digit (means: > 9), it is the 'asTyped' button Otherwise it is the 'no' button\&. 
.RE
.PP

.PP
Definition at line 887 of file rebindwidget\&.cpp\&.
.PP
References Ui_RebindWidget::rb_delay_asTyped, Ui_RebindWidget::rb_delay_default, Ui_RebindWidget::rb_delay_no, and ui\&.
.PP
Referenced by setSelection()\&.
.PP
.nf
887                                                         {
888     if (!macdef\&.contains(QRegExp("=\\d+,"))) {
889         ui->rb_delay_default->setChecked(true);
890         return;
891     }
892     if (macdef\&.contains(QRegExp("=\\d\\d+,"))) {
893         ui->rb_delay_asTyped->setChecked(true);
894         return;
895     }
896     ui->rb_delay_no->setChecked(true);
897 }
.fi
.SS "void RebindWidget::setSelection (const QStringList &newSelection, boolapplyPrevious = \fCfalse\fP)"

.PP
Definition at line 128 of file rebindwidget\&.cpp\&.
.PP
References KbBind::action(), anim, Ui_RebindWidget::animBox, KeyAction::animInfo(), Ui_RebindWidget::animKrBox, KbLight::animList(), Ui_RebindWidget::animOnceBox, applyChanges(), bind, KeyAction::DPI_CUSTOM, DPI_OFFSET, Ui_RebindWidget::dpiBox, Ui_RebindWidget::dpiCustXBox, Ui_RebindWidget::dpiCustYBox, KeyAction::dpiInfo(), KbLight::findAnimIdx(), Ui_RebindWidget::fnBox, fnKeys, KeyAction::isAnim(), KeyAction::isDPI(), KeyAction::isMouse(), KeyAction::isNormal(), KeyAction::isProgram(), KeyAction::isSpecial(), KeyAction::isValidMacro(), KbBind::light(), KeyAction::LIGHT_DOWN, KeyAction::LIGHT_DOWN_WRAP, KeyAction::LIGHT_UP, KeyAction::LIGHT_UP_WRAP, Ui_RebindWidget::lightBox, Ui_RebindWidget::lightWrapBox, Ui_RebindWidget::lockBox, KeyAction::macroContent(), KeyAction::macroDisplay(), KeyAction::macroLine(), KeyAction::macroTiming(), Ui_RebindWidget::mb2Box, Ui_RebindWidget::mbBox, Ui_RebindWidget::mediaBox, mediaKeys, Ui_RebindWidget::modBox, KeyAction::MODE_NEXT, KeyAction::MODE_NEXT_WRAP, KeyAction::MODE_PREV, KeyAction::MODE_PREV_WRAP, Ui_RebindWidget::modeBox, Ui_RebindWidget::modeWrapBox, modKeys, mouseExtKeys, mouseKeys, KbAnim::name(), Ui_RebindWidget::numBox, numKeys, KeyAction::PROGRAM_PR_MULTI, KeyAction::PROGRAM_RE_INDEF, KeyAction::PROGRAM_RE_KPSTOP, KeyAction::PROGRAM_RE_MULTI, KeyAction::programInfo(), Ui_RebindWidget::programKpBox, Ui_RebindWidget::programKpModeBox, Ui_RebindWidget::programKpSIBox, Ui_RebindWidget::programKrBox, Ui_RebindWidget::programKrModeBox, Ui_RebindWidget::programKrSIBox, Ui_RebindWidget::pteMacroBox, Ui_RebindWidget::pteMacroComment, Ui_RebindWidget::pteMacroText, selection, setBox(), setCorrectRadioButton(), KeyAction::specialInfo(), TAB_ANIM, TAB_KB, TAB_MACRO, TAB_MOUSE, TAB_PROGRAM, TAB_SPECIAL, Ui_RebindWidget::tabWidget, Ui_RebindWidget::txtBuffer, Ui_RebindWidget::typingBox, typingKeys, ui, Ui_RebindWidget::wheelBox, and wheelKeys\&.
.PP
Referenced by KbBindWidget::newSelection(), on_cancelButton_clicked(), setBind(), and KbBindWidget::updateBind()\&.
.PP
.nf
128                                                                                   {
129     if(bind){
130         // Populate animation list
131         // FIXME: There should be a trigger to update this whenever an animation is added/removed, even if the key selection hasn't changed
132         ui->animBox->clear();
133         ui->animBox->addItem(" ");
134         foreach(KbAnim* anim, bind->light()->animList())
135             ui->animBox->addItem(anim->name());
136     }
137 
138     // Apply changes to previous selection (if any)
139     if(!selection\&.isEmpty() && applyPrevious){
140         QStringList previous = selection;
141         selection = QStringList();
142         applyChanges(previous, false);
143     }
144 
145     selection = newSelection;
146     if(newSelection\&.isEmpty()){
147         hide();
148         return;
149     } else
150         show();
151 
152     bool hasAction = false;
153     QString action;
154     if(selection\&.count() == 1){
155         // Select action from the UI
156         action = bind->action(selection\&.first());
157         if(!action\&.isEmpty())
158             hasAction = true;
159     } else {
160         // Select an action from the UI if all keys are the same\&.
161         // Select nothing if any are unbound or different
162         foreach(const QString& key, selection){
163             QString keyAction = bind->action(key);
164             if(keyAction\&.isEmpty() || (hasAction && keyAction != action)){
165                 hasAction = false;
166                 break;
167             } else if(action\&.isEmpty()){
168                 action = keyAction;
169                 hasAction = true;
170             }
171         }
172     }
173 
174     if(!hasAction)
175         action = "";
176     KeyAction act(action);
177     // Clear everything
178     setBox(0);
179     ui->dpiCustXBox->setValue(400);
180     ui->dpiCustYBox->setValue(400);
181     ui->animOnceBox->setChecked(false);
182     ui->animKrBox->setChecked(false);
183     ui->programKpBox->setText("");
184     ui->programKrBox->setText("");
185     ui->programKpSIBox->setChecked(false);
186     ui->programKrSIBox->setChecked(false);
187     ui->programKpModeBox->setCurrentIndex(0);
188     ui->programKrModeBox->setCurrentIndex(0);
189     ui->programKpModeBox->setEnabled(false);
190     ui->programKrModeBox->setEnabled(false);
191     // Clear neu UI elements in MacroTab
192     ui->pteMacroBox->setPlainText("");
193     ui->pteMacroText->setPlainText("");
194     ui->pteMacroComment->setPlainText("");
195     ui->txtBuffer->setText("");
196     // Fill in field and select tab according to action type
197     bool mouse = act\&.isMouse();
198     if(mouse){
199         // Mouse buttons
200         ui->tabWidget->setCurrentIndex(TAB_MOUSE);
201         // Set mouse buttons (indexOf returns -1 if not found, index zero is blank)
202         ui->mbBox->setCurrentIndex(mouseKeys\&.indexOf(action) + 1);
203         ui->mb2Box->setCurrentIndex(mouseExtKeys\&.indexOf(action) + 1);
204         ui->wheelBox->setCurrentIndex(wheelKeys\&.indexOf(action) + 1);
205         if(act\&.isDPI()){
206             QPoint custom;
207             int value = act\&.dpiInfo(custom);
208             if(value <= -DPI_OFFSET || value > KeyAction::DPI_CUSTOM)
209                 return;
210             ui->dpiBox->setCurrentIndex(value + DPI_OFFSET);
211             if(value == KeyAction::DPI_CUSTOM){
212                 ui->dpiCustXBox->setValue(custom\&.x());
213                 ui->dpiCustYBox->setValue(custom\&.y());
214             }
215         }
216     } else if(act\&.isNormal()){
217         // Standard key
218         ui->tabWidget->setCurrentIndex(TAB_KB);
219         ui->typingBox->setCurrentIndex(typingKeys\&.indexOf(action) + 1);
220         ui->modBox->setCurrentIndex(modKeys\&.indexOf(action) + 1);
221         ui->fnBox->setCurrentIndex(fnKeys\&.indexOf(action) + 1);
222         ui->numBox->setCurrentIndex(numKeys\&.indexOf(action) + 1);
223         ui->mediaBox->setCurrentIndex(mediaKeys\&.indexOf(action) + 1);
224     } else if(act\&.isProgram()){
225         // Program key
226         ui->tabWidget->setCurrentIndex(TAB_PROGRAM);
227         QString onPress, onRelease;
228         int stop = act\&.programInfo(onPress, onRelease);
229         ui->programKpBox->setText(onPress);
230         ui->programKrBox->setText(onRelease);
231         switch(stop & 0x0F){
232         case KeyAction::PROGRAM_PR_MULTI:
233             ui->programKpSIBox->setChecked(false);
234             ui->programKpModeBox->setCurrentIndex(0);
235             ui->programKpModeBox->setEnabled(false);
236             break;
237         default:
238             ui->programKpSIBox->setChecked(true);
239             ui->programKpModeBox->setCurrentIndex(stop & 0x0F);
240             ui->programKpModeBox->setEnabled(true);
241             break;
242         }
243         switch(stop & 0xF0){
244         case KeyAction::PROGRAM_RE_MULTI:
245             ui->programKrSIBox->setChecked(false);
246             ui->programKrModeBox->setCurrentIndex(0);
247             ui->programKrModeBox->setEnabled(false);
248             break;
249         case KeyAction::PROGRAM_RE_INDEF:
250             ui->programKrSIBox->setChecked(true);
251             ui->programKrModeBox->setCurrentIndex(0);
252             ui->programKrModeBox->setEnabled(true);
253             break;
254         case KeyAction::PROGRAM_RE_KPSTOP:
255             ui->programKrSIBox->setChecked(true);
256             ui->programKrModeBox->setCurrentIndex(1);
257             ui->programKrModeBox->setEnabled(true);
258             break;
259         }
260     } else if(act\&.isAnim()){
261         // Animation key
262         ui->tabWidget->setCurrentIndex(TAB_ANIM);
263         bool onlyOnce = false, stopOnRelease = false;
264         QUuid id = act\&.animInfo(onlyOnce, stopOnRelease);
265         // Find this animation in the list\&. If not found, -1 will be returned, resulting in the blank space being selected
266         int index = bind->light()->findAnimIdx(id);
267         ui->animBox->setCurrentIndex(index + 1);
268         ui->animOnceBox->setChecked(!onlyOnce);
269         ui->animKrBox->setChecked(stopOnRelease);
270     } else if(act\&.isSpecial()){
271         // Other special keys
272         ui->tabWidget->setCurrentIndex(TAB_SPECIAL);
273         int param;
274         QString sAction = act\&.specialInfo(param);
275         // Mode selection\&. Check wrap-around flag
276         ui->modeWrapBox->setChecked(true);
277         if(sAction == "mode"){
278             ui->modeWrapBox->setChecked(true);
279             if(param == KeyAction::MODE_PREV_WRAP)
280                 param = KeyAction::MODE_PREV;
281             else if(param == KeyAction::MODE_NEXT_WRAP)
282                 param = KeyAction::MODE_NEXT;
283             else if(param < 0)
284                 ui->modeWrapBox->setChecked(false);
285             // Set mode box to current selection, or to mode 1 if invalid
286             param += 3;
287             if(param >= 0 && param < ui->modeBox->count())
288                 ui->modeBox->setCurrentIndex(param);
289             else
290                 // 0 -> "", 1 -> Prev, 2 -> Next, 3 -> Mode 1
291                 ui->modeBox->setCurrentIndex(3);
292         } else if (sAction == "macro") {
293             ui->tabWidget->setCurrentIndex(TAB_MACRO);
294             if (act\&.isValidMacro()) {
295                 ui->pteMacroBox->setPlainText(act\&.macroContent());
296                 ui->pteMacroText->setPlainText(act\&.macroLine()[1]\&.replace("&das_IST_31N_col0n;", ":"));
297                 ui->pteMacroComment->setPlainText(act\&.macroLine()[2]\&.replace("&das_IST_31N_col0n;", ":"));
298                 // Set the invisible Buffer to the original timing information\&.
299                 // For convenience / Migration from older versions:
300                 // If the timing information is only "x", then ignore it by setting it to an empty QString\&.
301                 ui->txtBuffer->setText("");
302                 if (act\&.macroTiming() != "x") ui->txtBuffer->setText(act\&.macroTiming());
303                 setCorrectRadioButton(act\&.macroContent());
304             } else {
305                 qDebug("RebindWidget::setSelection found invalid macro definition\&.");
306                 act\&.macroDisplay();
307             }
308         } else
309             ui->modeBox->setCurrentIndex(0);
310         // Brightness control\&. Also check wrap
311         if(sAction == "light"){
312             ui->lightWrapBox->setChecked(true);
313             if(param == KeyAction::LIGHT_DOWN_WRAP)
314                 param = KeyAction::LIGHT_DOWN;
315             else if(param == KeyAction::LIGHT_UP_WRAP)
316                 param = KeyAction::LIGHT_UP;
317             else
318                 ui->lightWrapBox->setChecked(false);
319             if(param < 0 || param > 1)
320                 param = -1;
321             ui->lightBox->setCurrentIndex(param + 1);
322         } else
323             ui->lightBox->setCurrentIndex(0);
324         // Win lock
325         if(sAction == "lock"){
326             if(param < 0 || param > 2)
327                 param = -1;
328             ui->lockBox->setCurrentIndex(param + 1);
329         } else
330             ui->lockBox->setCurrentIndex(0);
331     }
332 }
.fi
.SH "Field Documentation"
.PP 
.SS "\fBKbBind\fP* RebindWidget::bind\fC [private]\fP"

.PP
Definition at line 94 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), on_btnStartMacro_clicked(), on_btnStopMacro_clicked(), on_resetButton_clicked(), on_unbindButton_clicked(), setBind(), and setSelection()\&.
.SS "QStringList RebindWidget::fnKeys\fC [private]\fP"

.PP
Definition at line 100 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), setBind(), and setSelection()\&.
.SS "\fBMacroReader\fP* RebindWidget::macReader\fC [private]\fP"

.PP
Definition at line 106 of file rebindwidget\&.h\&.
.PP
Referenced by on_btnStartMacro_clicked(), and on_btnStopMacro_clicked()\&.
.SS "QStringList RebindWidget::mediaKeys\fC [private]\fP"

.PP
Definition at line 102 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), setBind(), and setSelection()\&.
.SS "QStringList RebindWidget::modKeys\fC [private]\fP"

.PP
Definition at line 99 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), setBind(), and setSelection()\&.
.SS "QStringList RebindWidget::mouseExtKeys\fC [private]\fP"

.PP
Definition at line 104 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), and setSelection()\&.
.SS "QStringList RebindWidget::mouseKeys\fC [private]\fP"

.PP
Definition at line 103 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), and setSelection()\&.
.SS "QStringList RebindWidget::numKeys\fC [private]\fP"

.PP
Definition at line 101 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), setBind(), and setSelection()\&.
.SS "\fBKbProfile\fP* RebindWidget::profile\fC [private]\fP"

.PP
Definition at line 95 of file rebindwidget\&.h\&.
.PP
Referenced by setBind()\&.
.SS "QStringList RebindWidget::selection\fC [private]\fP"

.PP
Definition at line 96 of file rebindwidget\&.h\&.
.PP
Referenced by on_applyButton_clicked(), on_cancelButton_clicked(), on_resetButton_clicked(), on_unbindButton_clicked(), and setSelection()\&.
.SS "const int RebindWidget::TAB_ANIM = 2\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 83 of file rebindwidget\&.h\&.
.PP
Referenced by setSelection()\&.
.SS "const int RebindWidget::TAB_KB = 0\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 83 of file rebindwidget\&.h\&.
.PP
Referenced by setSelection()\&.
.SS "const int RebindWidget::TAB_MACRO = 5\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 83 of file rebindwidget\&.h\&.
.PP
Referenced by setSelection()\&.
.SS "const int RebindWidget::TAB_MOUSE = 1\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 83 of file rebindwidget\&.h\&.
.PP
Referenced by setSelection()\&.
.SS "const int RebindWidget::TAB_PROGRAM = 4\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 83 of file rebindwidget\&.h\&.
.PP
Referenced by setSelection()\&.
.SS "const int RebindWidget::TAB_SPECIAL = 3\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 83 of file rebindwidget\&.h\&.
.PP
Referenced by setSelection()\&.
.SS "QStringList RebindWidget::typingKeys\fC [private]\fP"

.PP
Definition at line 98 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), setBind(), and setSelection()\&.
.SS "\fBUi::RebindWidget\fP* RebindWidget::ui\fC [private]\fP"

.PP
Definition at line 80 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), convertMacroBox(), helpStatus(), on_animBox_currentIndexChanged(), on_animButton_clicked(), on_btnStartMacro_clicked(), on_btnStopMacro_clicked(), on_dpiBox_currentIndexChanged(), on_dpiButton_clicked(), on_fnBox_currentIndexChanged(), on_fnButton_clicked(), on_lightBox_currentIndexChanged(), on_lightButton_clicked(), on_lockBox_currentIndexChanged(), on_lockButton_clicked(), on_mb2Box_currentIndexChanged(), on_mb2Button_clicked(), on_mbBox_currentIndexChanged(), on_mbButton_clicked(), on_mediaBox_currentIndexChanged(), on_mediaButton_clicked(), on_modBox_currentIndexChanged(), on_modButton_clicked(), on_modeBox_currentIndexChanged(), on_modeButton_clicked(), on_numBox_currentIndexChanged(), on_numButton_clicked(), on_programKpBox_textChanged(), on_programKpButton_clicked(), on_programKpSIBox_clicked(), on_programKrBox_textChanged(), on_programKrButton_clicked(), on_programKrSIBox_clicked(), on_pteMacroBox_textChanged(), on_typingBox_currentIndexChanged(), on_typingButton_clicked(), on_wheelBox_currentIndexChanged(), on_wheelButton_clicked(), RebindWidget(), setBind(), setBox(), setCorrectRadioButton(), setSelection(), and ~RebindWidget()\&.
.SS "QStringList RebindWidget::wheelKeys\fC [private]\fP"

.PP
Definition at line 105 of file rebindwidget\&.h\&.
.PP
Referenced by applyChanges(), RebindWidget(), and setSelection()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
