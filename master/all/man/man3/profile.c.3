.TH "src/ckb-daemon/profile.c" 3 "Thu Nov 2 2017" "Version v0.2.8 at branch master" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/profile.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'command\&.h'\fP
.br
\fC#include 'device\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'led\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBurldecode2\fP (char *dst, const char *src)"
.br
.ti -1c
.RI "void \fBurlencode2\fP (char *dst, const char *src)"
.br
.ti -1c
.RI "int \fBsetid\fP (\fBusbid\fP *id, const char *guid)"
.br
.ti -1c
.RI "char * \fBgetid\fP (\fBusbid\fP *id)"
.br
.ti -1c
.RI "void \fBu16enc\fP (char *in, \fBushort\fP *out, size_t *srclen, size_t *dstlen)"
.br
.ti -1c
.RI "void \fBu16dec\fP (\fBushort\fP *in, char *out, size_t *srclen, size_t *dstlen)"
.br
.ti -1c
.RI "void \fBcmd_name\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *name)"
.br
.ti -1c
.RI "void \fBcmd_profilename\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *name)"
.br
.ti -1c
.RI "char * \fBprintname\fP (\fBushort\fP *name, int length)"
.br
.ti -1c
.RI "char * \fBgetmodename\fP (\fBusbmode\fP *mode)"
.br
.ti -1c
.RI "char * \fBgetprofilename\fP (\fBusbprofile\fP *profile)"
.br
.ti -1c
.RI "char * \fBgethwmodename\fP (\fBhwprofile\fP *profile, int index)"
.br
.ti -1c
.RI "char * \fBgethwprofilename\fP (\fBhwprofile\fP *profile)"
.br
.ti -1c
.RI "void \fBcmd_id\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *id)"
.br
.ti -1c
.RI "void \fBcmd_profileid\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *id)"
.br
.ti -1c
.RI "static void \fBinitmode\fP (\fBusbmode\fP *mode)"
.br
.ti -1c
.RI "void \fBallocprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBloadprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "static void \fBfreemode\fP (\fBusbmode\fP *mode)"
.br
.ti -1c
.RI "void \fBcmd_erase\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy1, int dummy2, const char *dummy3)"
.br
.ti -1c
.RI "static void \fB_freeprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBcmd_eraseprofile\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "void \fBfreeprofile\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBhwtonative\fP (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, int modecount)"
.br
.ti -1c
.RI "void \fBnativetohw\fP (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, int modecount)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static iconv_t \fButf8to16\fP = 0"
.br
.ti -1c
.RI "static iconv_t \fButf16to8\fP = 0"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void _freeprofile (\fBusbdevice\fP *kb)\fC [static]\fP"

.PP
Definition at line 230 of file profile\&.c\&.
.PP
References freemode(), usbprofile::mode, MODE_COUNT, and usbdevice::profile\&.
.PP
Referenced by cmd_eraseprofile(), and freeprofile()\&.
.PP
.nf
230                                        {
231     usbprofile* profile = kb->profile;
232     if(!profile)
233         return;
234     // Clear all mode data
235     for(int i = 0; i < MODE_COUNT; i++)
236         freemode(profile->mode + i);
237     free(profile);
238     kb->profile = 0;
239 }
.fi
.SS "void allocprofile (\fBusbdevice\fP *kb)"

.PP
Definition at line 198 of file profile\&.c\&.
.PP
References usbprofile::currentmode, dpiset::forceupdate, lighting::forceupdate, initmode(), usbprofile::lastdpi, usbprofile::lastlight, usbprofile::mode, MODE_COUNT, and usbdevice::profile\&.
.PP
Referenced by cmd_eraseprofile()\&.
.PP
.nf
198                                 {
199     if(kb->profile)
200         return;
201     usbprofile* profile = kb->profile = calloc(1, sizeof(usbprofile));
202     for(int i = 0; i < MODE_COUNT; i++)
203         initmode(profile->mode + i);
204     profile->currentmode = profile->mode;
205     profile->lastlight\&.forceupdate = profile->lastdpi\&.forceupdate = 1;
206 }
.fi
.SS "void cmd_erase (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *dummy3)"

.PP
Definition at line 219 of file profile\&.c\&.
.PP
References freemode(), imutex, and initmode()\&.
.PP
.nf
219                                                                                         {
220     (void)dummy1;
221     (void)dummy2;
222     (void)dummy3;
223 
224     pthread_mutex_lock(imutex(kb));
225     freemode(mode);
226     initmode(mode);
227     pthread_mutex_unlock(imutex(kb));
228 }
.fi
.SS "void cmd_eraseprofile (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 241 of file profile\&.c\&.
.PP
References _freeprofile(), allocprofile(), and imutex\&.
.PP
.nf
241                                                                                                  {
242     (void)dummy1;
243     (void)dummy2;
244     (void)dummy3;
245     (void)dummy4;
246 
247     pthread_mutex_lock(imutex(kb));
248     _freeprofile(kb);
249     allocprofile(kb);
250     pthread_mutex_unlock(imutex(kb));
251 }
.fi
.SS "void cmd_id (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *id)"

.PP
Definition at line 168 of file profile\&.c\&.
.PP
References usbmode::id, usbid::modified, and setid()\&.
.PP
.nf
168                                                                                  {
169     (void)kb;
170     (void)dummy1;
171     (void)dummy2;
172 
173     // ID is either a GUID or an 8-digit hex number
174     int newmodified;
175     if(!setid(&mode->id, id) && sscanf(id, "%08x", &newmodified) == 1)
176         memcpy(mode->id\&.modified, &newmodified, sizeof(newmodified));
177 }
.fi
.SS "void cmd_name (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *name)"

.PP
Definition at line 117 of file profile\&.c\&.
.PP
References MD_NAME_LEN, usbmode::name, u16enc(), and urldecode2()\&.
.PP
.nf
117                                                                                      {
118     (void)kb;
119     (void)dummy1;
120     (void)dummy2;
121 
122     char decoded[strlen(name) + 1];
123     urldecode2(decoded, name);
124     size_t srclen = strlen(decoded), dstlen = MD_NAME_LEN;
125     u16enc(decoded, mode->name, &srclen, &dstlen);
126 }
.fi
.SS "void cmd_profileid (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy1, intdummy2, const char *id)"

.PP
Definition at line 179 of file profile\&.c\&.
.PP
References usbprofile::id, usbid::modified, usbdevice::profile, and setid()\&.
.PP
.nf
179                                                                                         {
180     (void)mode;
181     (void)dummy1;
182     (void)dummy2;
183 
184     usbprofile* profile = kb->profile;
185     int newmodified;
186     if(!setid(&profile->id, id) && sscanf(id, "%08x", &newmodified) == 1)
187         memcpy(profile->id\&.modified, &newmodified, sizeof(newmodified));
188 
189 }
.fi
.SS "void cmd_profilename (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *name)"

.PP
Definition at line 128 of file profile\&.c\&.
.PP
References usbprofile::name, PR_NAME_LEN, usbdevice::profile, u16enc(), and urldecode2()\&.
.PP
.nf
128                                                                                               {
129     (void)dummy1;
130     (void)dummy2;
131     (void)dummy3;
132 
133     usbprofile* profile = kb->profile;
134     char decoded[strlen(name) + 1];
135     urldecode2(decoded, name);
136     size_t srclen = strlen(decoded), dstlen = PR_NAME_LEN;
137     u16enc(decoded, profile->name, &srclen, &dstlen);
138 }
.fi
.SS "static void freemode (\fBusbmode\fP *mode)\fC [static]\fP"

.PP
Definition at line 214 of file profile\&.c\&.
.PP
References usbmode::bind, and freebind()\&.
.PP
Referenced by _freeprofile(), and cmd_erase()\&.
.PP
.nf
214                                    {
215     freebind(&mode->bind);
216     memset(mode, 0, sizeof(*mode));
217 }
.fi
.SS "void freeprofile (\fBusbdevice\fP *kb)"

.PP
Definition at line 253 of file profile\&.c\&.
.PP
References _freeprofile(), and usbdevice::hw\&.
.PP
.nf
253                                {
254     _freeprofile(kb);
255     // Also free HW profile
256     free(kb->hw);
257     kb->hw = 0;
258 }
.fi
.SS "char* gethwmodename (\fBhwprofile\fP *profile, intindex)"

.PP
Definition at line 160 of file profile\&.c\&.
.PP
References MD_NAME_LEN, hwprofile::name, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
160                                                   {
161     return printname(profile->name[index + 1], MD_NAME_LEN);
162 }
.fi
.SS "char* gethwprofilename (\fBhwprofile\fP *profile)"

.PP
Definition at line 164 of file profile\&.c\&.
.PP
References MD_NAME_LEN, hwprofile::name, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
164                                           {
165     return printname(profile->name[0], MD_NAME_LEN);
166 }
.fi
.SS "char* getid (\fBusbid\fP *id)"

.PP
Definition at line 79 of file profile\&.c\&.
.PP
References usbid::guid\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
79                       {
80     int32_t data1;
81     int16_t data2, data3, data4a;
82     char data4b[6];
83     memcpy(&data1, id->guid + 0x0, 4);
84     memcpy(&data2, id->guid + 0x4, 2);
85     memcpy(&data3, id->guid + 0x6, 2);
86     memcpy(&data4a, id->guid + 0x8, 2);
87     memcpy(data4b, id->guid + 0xA, 6);
88     char* guid = malloc(39);
89     snprintf(guid, 39, "{%08X-%04hX-%04hX-%04hX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
90              data1, data2, data3, data4a, data4b[0], data4b[1], data4b[2], data4b[3], data4b[4], data4b[5]);
91     return guid;
92 }
.fi
.SS "char* getmodename (\fBusbmode\fP *mode)"

.PP
Definition at line 152 of file profile\&.c\&.
.PP
References MD_NAME_LEN, usbmode::name, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
152                                 {
153     return printname(mode->name, MD_NAME_LEN);
154 }
.fi
.SS "char* getprofilename (\fBusbprofile\fP *profile)"

.PP
Definition at line 156 of file profile\&.c\&.
.PP
References usbprofile::name, PR_NAME_LEN, and printname()\&.
.PP
Referenced by _cmd_get()\&.
.PP
.nf
156                                          {
157     return printname(profile->name, PR_NAME_LEN);
158 }
.fi
.SS "void hwtonative (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, intmodecount)"

.PP
Definition at line 260 of file profile\&.c\&.
.PP
References usbmode::dpi, hwprofile::dpi, dpiset::forceupdate, lighting::forceupdate, usbmode::id, usbprofile::id, hwprofile::id, usbprofile::lastdpi, usbprofile::lastlight, usbmode::light, hwprofile::light, MD_NAME_LEN, usbprofile::mode, usbmode::name, usbprofile::name, hwprofile::name, and PR_NAME_LEN\&.
.PP
Referenced by cmd_hwload_kb(), and cmd_hwload_mouse()\&.
.PP
.nf
260                                                                   {
261     // Copy the profile name and ID
262     memcpy(profile->name, hw->name[0], PR_NAME_LEN * 2);
263     memcpy(&profile->id, hw->id, sizeof(usbid));
264     // Copy the mode settings
265     for(int i = 0; i < modecount; i++){
266         usbmode* mode = profile->mode + i;
267         memcpy(mode->name, hw->name[i + 1], MD_NAME_LEN * 2);
268         memcpy(&mode->id, hw->id + i + 1, sizeof(usbid));
269         memcpy(&mode->light, hw->light + i, sizeof(lighting));
270         memcpy(&mode->dpi, hw->dpi + i, sizeof(dpiset));
271         // Set a force update on the light/DPI since they've been overwritten
272         mode->light\&.forceupdate = mode->dpi\&.forceupdate = 1;
273     }
274     profile->lastlight\&.forceupdate = profile->lastdpi\&.forceupdate = 1;
275 }
.fi
.SS "static void initmode (\fBusbmode\fP *mode)\fC [static]\fP"

.PP
Definition at line 191 of file profile\&.c\&.
.PP
References usbmode::bind, usbmode::dpi, dpiset::forceupdate, lighting::forceupdate, initbind(), and usbmode::light\&.
.PP
Referenced by allocprofile(), and cmd_erase()\&.
.PP
.nf
191                                    {
192     memset(mode, 0, sizeof(*mode));
193     mode->light\&.forceupdate = 1;
194     mode->dpi\&.forceupdate = 1;
195     initbind(&mode->bind);
196 }
.fi
.SS "int loadprofile (\fBusbdevice\fP *kb)"

.PP
Definition at line 208 of file profile\&.c\&.
.PP
References hwloadprofile\&.
.PP
.nf
208                               {
209     if(hwloadprofile(kb, 1))
210         return -1;
211     return 0;
212 }
.fi
.SS "void nativetohw (\fBusbprofile\fP *profile, \fBhwprofile\fP *hw, intmodecount)"

.PP
Definition at line 277 of file profile\&.c\&.
.PP
References usbmode::dpi, hwprofile::dpi, usbmode::id, usbprofile::id, hwprofile::id, usbmode::light, hwprofile::light, MD_NAME_LEN, usbprofile::mode, usbmode::name, usbprofile::name, hwprofile::name, and PR_NAME_LEN\&.
.PP
Referenced by cmd_hwsave_kb(), and cmd_hwsave_mouse()\&.
.PP
.nf
277                                                                   {
278     // Copy name and ID
279     memcpy(hw->name[0], profile->name, PR_NAME_LEN * 2);
280     memcpy(hw->id, &profile->id, sizeof(usbid));
281     // Copy the mode settings
282     for(int i = 0; i < modecount; i++){
283         usbmode* mode = profile->mode + i;
284         memcpy(hw->name[i + 1], mode->name, MD_NAME_LEN * 2);
285         memcpy(hw->id + i + 1, &mode->id, sizeof(usbid));
286         memcpy(hw->light + i, &mode->light, sizeof(lighting));
287         memcpy(hw->dpi + i, &mode->dpi, sizeof(dpiset));
288     }
289 }
.fi
.SS "char* printname (\fBushort\fP *name, intlength)"

.PP
Definition at line 140 of file profile\&.c\&.
.PP
References u16dec(), and urlencode2()\&.
.PP
Referenced by gethwmodename(), gethwprofilename(), getmodename(), and getprofilename()\&.
.PP
.nf
140                                          {
141     // Convert the name to UTF-8
142     char* buffer = calloc(1, length * 4 - 3);
143     size_t srclen = length, dstlen = length * 4 - 4;
144     u16dec(name, buffer, &srclen, &dstlen);
145     // URL-encode it
146     char* buffer2 = malloc(strlen(buffer) * 3 + 1);
147     urlencode2(buffer2, buffer);
148     free(buffer);
149     return buffer2;
150 }
.fi
.SS "int setid (\fBusbid\fP *id, const char *guid)"

.PP
Definition at line 64 of file profile\&.c\&.
.PP
References usbid::guid\&.
.PP
Referenced by cmd_id(), and cmd_profileid()\&.
.PP
.nf
64                                       {
65     int32_t data1;
66     int16_t data2, data3, data4a;
67     char data4b[6];
68     if(sscanf(guid, "{%08X-%04hX-%04hX-%04hX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
69               &data1, &data2, &data3, &data4a, data4b, data4b + 1, data4b + 2, data4b + 3, data4b + 4, data4b + 5) != 10)
70         return 0;
71     memcpy(id->guid + 0x0, &data1, 4);
72     memcpy(id->guid + 0x4, &data2, 2);
73     memcpy(id->guid + 0x6, &data3, 2);
74     memcpy(id->guid + 0x8, &data4a, 2);
75     memcpy(id->guid + 0xA, data4b, 6);
76     return 1;
77 }
.fi
.SS "void u16dec (\fBushort\fP *in, char *out, size_t *srclen, size_t *dstlen)"

.PP
Definition at line 105 of file profile\&.c\&.
.PP
References utf16to8\&.
.PP
Referenced by printname()\&.
.PP
.nf
105                                                                   {
106     if(!utf16to8)
107         utf16to8 = iconv_open("UTF-8", "UTF-16LE");
108     size_t srclen2 = 0, srclenmax = *srclen;
109     for(; srclen2 < srclenmax; srclen2++){
110         if(!in[srclen2])
111             break;
112     }
113     *srclen = srclen2 * 2;
114     iconv(utf16to8, (char**)&in, srclen, &out, dstlen);
115 }
.fi
.SS "void u16enc (char *in, \fBushort\fP *out, size_t *srclen, size_t *dstlen)"

.PP
Definition at line 97 of file profile\&.c\&.
.PP
References utf8to16\&.
.PP
Referenced by cmd_name(), and cmd_profilename()\&.
.PP
.nf
97                                                                   {
98     if(!utf8to16)
99         utf8to16 = iconv_open("UTF-16LE", "UTF-8");
100     memset(out, 0, *dstlen * 2);
101     *dstlen = *dstlen * 2 - 2;
102     iconv(utf8to16, &in, srclen, (char**)&out, dstlen);
103 }
.fi
.SS "void urldecode2 (char *dst, const char *src)"

.PP
Definition at line 8 of file profile\&.c\&.
.PP
Referenced by cmd_name(), and cmd_profilename()\&.
.PP
.nf
8                                            {
9     char a, b;
10     char s;
11     while((s = *src)){
12         if((s == '%') &&
13                 ((a = src[1]) && (b = src[2])) &&
14                 (isxdigit(a) && isxdigit(b))){
15             if(a >= 'a')
16                 a -= 'a'-'A';
17             if(a >= 'A')
18                 a -= 'A' - 10;
19             else
20                 a -= '0';
21             if(b >= 'a')
22                 b -= 'a'-'A';
23             if(b >= 'A')
24                 b -= 'A' - 10;
25             else
26                 b -= '0';
27             *dst++ = 16 * a + b;
28             src += 3;
29         } else {
30             *dst++ = s;
31             src++;
32         }
33     }
34     *dst = '\0';
35 }
.fi
.SS "void urlencode2 (char *dst, const char *src)"

.PP
Definition at line 37 of file profile\&.c\&.
.PP
Referenced by printname()\&.
.PP
.nf
37                                            {
38     char s;
39     while((s = *src++)){
40         if(s <= ',' || s == '/' ||
41                 (s >= ':' && s <= '@') ||
42                 s == '[' || s == ']' ||
43                 s >= 0x7F){
44             char a = s >> 4, b = s & 0xF;
45             if(a >= 10)
46                 a += 'A' - 10;
47             else
48                 a += '0';
49             if(b >= 10)
50                 b += 'A' - 10;
51             else
52                 b += '0';
53             dst[0] = '%';
54             dst[1] = a;
55             dst[2] = b;
56             dst += 3;
57         } else
58             *dst++ = s;
59     }
60     *dst = '\0';
61 }
.fi
.SH "Variable Documentation"
.PP 
.SS "iconv_t utf16to8 = 0\fC [static]\fP"

.PP
Definition at line 95 of file profile\&.c\&.
.PP
Referenced by u16dec()\&.
.SS "iconv_t utf8to16 = 0\fC [static]\fP"

.PP
Definition at line 95 of file profile\&.c\&.
.PP
Referenced by u16enc()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
