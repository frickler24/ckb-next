.TH "src/ckb-daemon/usb_linux.c" 3 "Mon Jun 5 2017" "Version beta-v0.2.8+testing at branch macrotime.0.2.thread" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/usb_linux.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_model\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEBUG\fP"
.br
.RI "\fIall open usb devices have their system path names here in this array\&. \fP"
.ti -1c
.RI "#define \fBDEBUG\fP"
.br
.RI "\fIall open usb devices have their system path names here in this array\&. \fP"
.ti -1c
.RI "#define \fBTEST_RESET\fP(op)"
.br
.RI "\fITEST_RESET doesa 'try / catch' for resetting the usb interface\&. \fP"
.ti -1c
.RI "#define \fBN_MODELS\fP   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBos_usbsend\fP (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, int is_recv, const char *file, int line)"
.br
.RI "\fIos_usbsend sends a data packet (MSG_SIZE = 64) Bytes long \fP"
.ti -1c
.RI "int \fBos_usbrecv\fP (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, int line)"
.br
.RI "\fIos_usbrecv receives a max MSGSIZE long buffer from usb device \fP"
.ti -1c
.RI "int \fB_nk95cmd\fP (\fBusbdevice\fP *kb, \fBuchar\fP bRequest, \fBushort\fP wValue, const char *file, int line)"
.br
.RI "\fI_nk95cmd If we control a non RGB keyboard, set the keyboard via ioctl with usbdevfs_ctrltransfer \fP"
.ti -1c
.RI "void \fBos_sendindicators\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void * \fBos_inputmain\fP (void *context)"
.br
.RI "\fIos_inputmain This function is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&. \fP"
.ti -1c
.RI "static int \fBusbunclaim\fP (\fBusbdevice\fP *kb, int resetting)"
.br
.ti -1c
.RI "void \fBos_closeusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "static int \fBusbclaim\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBos_resetusb\fP (\fBusbdevice\fP *kb, const char *file, int line)"
.br
.ti -1c
.RI "void \fBstrtrim\fP (char *string)"
.br
.ti -1c
.RI "int \fBos_setupusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBusbadd\fP (struct udev_device *dev, short vendor, short product)"
.br
.ti -1c
.RI "static int \fBusb_add_device\fP (struct udev_device *dev)"
.br
.RI "\fIAdd a udev device\&. Returns 0 if device was recognized/added\&. \fP"
.ti -1c
.RI "static void \fBusb_rm_device\fP (struct udev_device *dev)"
.br
.RI "\fIusb_rm_device find the usb port to remove and close it via \fBcloseusb()\fP\&. \fP"
.ti -1c
.RI "static void \fBudev_enum\fP ()"
.br
.RI "\fIudev_enum use the udev_enumerate_add_match_subsystem() to get all you need but only that\&. \fP"
.ti -1c
.RI "int \fBusbmain\fP ()"
.br
.ti -1c
.RI "void \fBusbkill\fP ()"
.br
.RI "\fIStop the USB system\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static char \fBkbsyspath\fP [9][FILENAME_MAX]"
.br
.ti -1c
.RI "static struct udev * \fBudev\fP"
.br
.RI "\fIstruct udef is defined in /usr/include/libudev\&.h \fP"
.ti -1c
.RI "pthread_t \fBusbthread\fP"
.br
.ti -1c
.RI "pthread_t \fBudevthread\fP"
.br
.ti -1c
.RI "static \fB_model\fP \fBmodels\fP []"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct _model"
.PP 
Definition at line 650 of file usb_linux\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
const char * \fIname\fP 
.br
.PP
short \fInumber\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define DEBUG"

.PP
Definition at line 13 of file usb_linux\&.c\&.
.SS "#define DEBUG"

.PP
Definition at line 13 of file usb_linux\&.c\&.
.SS "#define N_MODELS   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"

.PP
Definition at line 687 of file usb_linux\&.c\&.
.PP
Referenced by usb_add_device()\&.
.SS "#define TEST_RESET(op)"
\fBValue:\fP
.PP
.nf
if(op){                                                                 \\
        ckb_err_fn("resetusb failed: %s\n", file, line, strerror(errno));   \
        if(errno == EINTR || errno == EAGAIN)                               \
            return -1;              /* try again if status code says so */  \
        return -2;                  /* else, remove device */               \
    }
.fi
.PP
Definition at line 483 of file usb_linux\&.c\&.
.PP
Referenced by os_resetusb()\&.
.SH "Function Documentation"
.PP 
.SS "int _nk95cmd (\fBusbdevice\fP *kb, \fBuchar\fPbRequest, \fBushort\fPwValue, const char *file, intline)"
To send control packets to a non RGB non color K95 Keyboard, use this function\&. Normally it is called via the \fBnk95cmd()\fP macro\&.
.PP
If it is the wrong device for which the function is called, 0 is returned and nothing done\&. Otherwise a usbdevfs_ctrltransfer structure is filled and an USBDEVFS_CONTROL ioctl() called\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x40 see table below to switch hardware-modus at Keyboard wValue device MSG_SIZE 5ms the message buffer pointer Host to Device, Type=Vendor, Recipient=Device bRequest parameter given wValue Parameter device 0 0 data to write 5000 null If a 0 or a negative error number is returned by the ioctl, an error message is shown depending on the errno or 'No data written' if retval was 0\&. In either case 1 is returned to indicate the error\&. If the ioctl returned a value > 0, 0 is returned to indicate no error\&.
.PP
Currently the following combinations for bRequest and wValue are used: Device what it might to do constant bRequest wValue  non RGB Keyboard set HW-modus on (leave the ckb driver) HWON 0x0002 0x0030 non RGB Keyboard set HW-modus off (initialize the ckb driver) HWOFF 0x0002 0x0001 non RGB Keyboard set light modus M1 in single-color keyboards NK95_M1 0x0014 0x0001 non RGB Keyboard set light modus M2 in single-color keyboards NK95_M2 0x0014 0x0002 non RGB Keyboard set light modus M3 in single-color keyboards NK95_M3 0x0014 0x0003 
.PP
\fBSee Also:\fP
.RS 4
\fBusb\&.h\fP 
.RE
.PP

.PP
Definition at line 192 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, usbdevice::handle, P_K95_NRGB, and usbdevice::product\&.
.PP
.nf
192                                                                                       {
193     if(kb->product != P_K95_NRGB)
194         return 0;
195     struct usbdevfs_ctrltransfer transfer = { 0x40, bRequest, wValue, 0, 0, 5000, 0 };
196     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
197     if(res <= 0){
198         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
199         return 1;
200     }
201     return 0;
202 }
.fi
.SS "void os_closeusb (\fBusbdevice\fP *kb)"
os_closeusb unclaim it, destroy the udev device and clear data structures at kb
.PP
os_closeusb is the linux specific implementation for closing an active usb port\&. 
.br
 If a valid handle is given in the kb structure, the usb port is unclaimed (\fBusbunclaim()\fP)\&. 
.br
 The device in unrefenced via library function udev_device_unref()\&. 
.br
 handle, udev and the first char of kbsyspath are cleared to 0 (empty string for kbsyspath)\&. 
.PP
Definition at line 439 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, INDEX_OF, kbsyspath, keyboard, usbdevice::udev, and usbunclaim()\&.
.PP
Referenced by closeusb()\&.
.PP
.nf
439                                {
440     if(kb->handle){
441         usbunclaim(kb, 0);
442         close(kb->handle - 1);
443     }
444     if(kb->udev)
445         udev_device_unref(kb->udev);
446     kb->handle = 0;
447     kb->udev = 0;
448     kbsyspath[INDEX_OF(kb, keyboard)][0] = 0;
449 }
.fi
.SS "void* os_inputmain (void *context)"
os_inputmain is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&.
.PP
\fBTodo\fP
.RS 4
This function is a collection of many tasks\&. It should be divided into several sub-functions for the sake of greater convenience:
.RE
.PP
.PP
.IP "1." 4
set up an URB (Userspace Ressource Buffer) to communicate with the USBDEVFS_* ioctl()s
.IP "2." 4
perform the ioctl()
.IP "3." 4
interpretate the information got into the URB buffer or handle error situations and retry operation or leave the endless loop
.IP "4." 4
inform the os about the data
.IP "5." 4
loop endless via 2\&.
.IP "6." 4
if endless loop has gone, deinitalize the interface, free buffers etc\&.
.IP "7." 4
return null 
.PP
Here the actions in detail:
.PP
Monitor input transfers on all endpoints for non-RGB devices For RGB, monitor all but the last, as it's used for input/output
.PP
Get an usbdevfs_urb data structure and clear it via memset()
.PP
Hopefully the buffer lengths are equal for all devices with congruent types\&. You can find out the correctness for your device with lsusb --v or similar on macOS\&. Currently the following combinations are known and implemented:
.PP
device detect with macro combination endpoint # buffer-length  each none 0 8 RGB Mouse IS_RGB && IS_MOUSE 1 10 RGB Keyboard IS_RGB && !IS_MOUSE 1 21 RGB Mouse or Keyboard IS_RGB 2 MSG_SIZE (64) non RGB Mouse or Keyboard !IS_RGB 1 4 non RGB Mouse or Keyboard !IS_RGB 2 15 
.PP
Now submit all the URBs via ioctl(USBDEVFS_SUBMITURB) with type USBDEVFS_URB_TYPE_INTERRUPT (the endpoints are defined as type interrupt)\&. Endpoint number is 0x80\&.\&.0x82 or 0x83, depending on the model\&.
.PP
The userSpaceFS knows the URBs now, so start monitoring input
.PP
if the ioctl returns something != 0, let's have a deeper look what happened\&. Broken devices or shutting down the entire system leads to closing the device and finishing this thread\&.
.PP
If just an EPIPE ocurred, give the device a CLEAR_HALT and resubmit the URB\&.
.PP
A correct REAPURB returns a Pointer to the URB which we now have a closer look into\&. Lock all following actions with imutex\&.
.PP
Process the input depending on type of device\&. Interprete the actual size of the URB buffer
.PP
device detect with macro combination seems to be endpoint # actual buffer-length function called  mouse (RGB and non RGB) IS_MOUSE nA 8, 10 or 11 \fBhid_mouse_translate()\fP mouse (RGB and non RGB) IS_MOUSE nA MSG_SIZE (64) \fBcorsair_mousecopy()\fP RGB Keyboard IS_RGB && !IS_MOUSE 1 8 (BIOS Mode) \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 2 5 or 21, KB inactive! \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 3? MSG_SIZE \fBcorsair_kbcopy()\fP non RGB Keyboard !IS_RGB && !IS_MOUSE nA nA \fBhid_kb_translate()\fP 
.PP
The input data is transformed and copied to the kb structure\&. Now give it to the OS and unlock the imutex afterwards\&.
.PP
Re-submit the URB for the next run\&.
.PP
If the endless loop is terminated, clean up by discarding the URBs via ioctl(USBDEVFS_DISCARDURB), free the URB buffers and return a null pointer as thread exit code\&. 
.PP
Definition at line 242 of file usb_linux\&.c\&.
.PP
References usbdevice::active, ckb_err, ckb_info, corsair_kbcopy(), corsair_mousecopy(), devpath, usbdevice::epcount, usbdevice::handle, hid_kb_translate(), hid_mouse_translate(), imutex, INDEX_OF, usbdevice::input, inputupdate(), IS_MOUSE, IS_RGB, keyboard, usbinput::keys, MSG_SIZE, usbdevice::product, usbinput::rel_x, usbinput::rel_y, and usbdevice::vendor\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
242                                  {
243     usbdevice* kb = context;
244     int fd = kb->handle - 1;
245     short vendor = kb->vendor, product = kb->product;
246     int index = INDEX_OF(kb, keyboard);
247     ckb_info("Starting input thread for %s%d\n", devpath, index);
248 
253     int urbcount = IS_RGB(vendor, product) ? (kb->epcount - 1) : kb->epcount;
254     if (urbcount == 0) {
255         ckb_err("urbcount = 0, so there is nothing to claim in os_inputmain()\n");
256         return 0;
257     }
258 
260     struct usbdevfs_urb urbs[urbcount + 1];
261     memset(urbs, 0, sizeof(urbs));
262 
276     urbs[0]\&.buffer_length = 8;
277     if(urbcount > 1 && IS_RGB(vendor, product)) {
278         if(IS_MOUSE(vendor, product))
279             urbs[1]\&.buffer_length = 10;
280         else
281             urbs[1]\&.buffer_length = 21;
282         urbs[2]\&.buffer_length = MSG_SIZE;
283         if(urbcount != 3)
284             urbs[urbcount - 1]\&.buffer_length = MSG_SIZE;
285     } else {
286         urbs[1]\&.buffer_length = 4;
287         urbs[2]\&.buffer_length = 15;
288     }
289 
292     for(int i = 0; i < urbcount; i++){
293         urbs[i]\&.type = USBDEVFS_URB_TYPE_INTERRUPT;
294         urbs[i]\&.endpoint = 0x80 | (i + 1);
295         urbs[i]\&.buffer = malloc(urbs[i]\&.buffer_length);
296         ioctl(fd, USBDEVFS_SUBMITURB, urbs + i);
297     }
298 
300     while (1) {
301         struct usbdevfs_urb* urb = 0;
302 
305         if (ioctl(fd, USBDEVFS_REAPURB, &urb)) {
306             if (errno == ENODEV || errno == ENOENT || errno == ESHUTDOWN)
307                 // Stop the thread if the handle closes
308                 break;
309             else if(errno == EPIPE && urb){
311                 ioctl(fd, USBDEVFS_CLEAR_HALT, &urb->endpoint);
312                 // Re-submit the URB
313                 if(urb)
314                     ioctl(fd, USBDEVFS_SUBMITURB, urb);
315                 urb = 0;
316             }
317             continue;
318         }
319 
323         if (urb) {
324 
336             pthread_mutex_lock(imutex(kb));
337             if(IS_MOUSE(vendor, product)){
338                 switch(urb->actual_length){
339                 case 8:
340                 case 10:
341                 case 11:
342                     // HID mouse input
343                     hid_mouse_translate(kb->input\&.keys, &kb->input\&.rel_x, &kb->input\&.rel_y, -(urb->endpoint & 0xF), urb->actual_length, urb->buffer);
344                     break;
345                 case MSG_SIZE:
346                     // Corsair mouse input
347                     corsair_mousecopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
348                     break;
349                 }
350             } else if(IS_RGB(vendor, product)){
351                 switch(urb->actual_length){
352                 case 8:
353                     // RGB EP 1: 6KRO (BIOS mode) input
354                     hid_kb_translate(kb->input\&.keys, -1, urb->actual_length, urb->buffer);
355                     break;
356                 case 21:
357                 case 5:
358                     // RGB EP 2: NKRO (non-BIOS) input\&. Accept only if keyboard is inactive
359                     if(!kb->active)
360                         hid_kb_translate(kb->input\&.keys, -2, urb->actual_length, urb->buffer);
361                     break;
362                 case MSG_SIZE:
363                     // RGB EP 3: Corsair input
364                     corsair_kbcopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
365                     break;
366                 }
367             } else {
368                 // Non-RGB input
369                 hid_kb_translate(kb->input\&.keys, urb->endpoint & 0xF, urb->actual_length, urb->buffer);
370             }
373             inputupdate(kb);
374             pthread_mutex_unlock(imutex(kb));
375 
377             ioctl(fd, USBDEVFS_SUBMITURB, urb);
378             urb = 0;
379         }
380     }
381 
385     ckb_info("Stopping input thread for %s%d\n", devpath, index);
386     for(int i = 0; i < urbcount; i++){
387         ioctl(fd, USBDEVFS_DISCARDURB, urbs + i);
388         free(urbs[i]\&.buffer);
389     }
390     return 0;
391 }
.fi
.SS "int os_resetusb (\fBusbdevice\fP *kb, const char *file, intline)"
os_resetusb is the os specific implementation for resetting usb
.PP
Try to reset an usb device in a linux user space driver\&.
.IP "1." 4
unclaim the device, but do not reconnect the system driver (second param resetting = true)
.IP "2." 4
reset the device via USBDEVFS_RESET command
.IP "3." 4
claim the device again\&. Returns 0 on success, -2 if device should be removed and -1 if reset should by tried again
.PP
.PP
\fBTodo\fP
.RS 4
it seems that no one wants to try the reset again\&. But I'v seen it somewhere\&.\&.\&. 
.RE
.PP

.PP
Definition at line 501 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, TEST_RESET, usbclaim(), and usbunclaim()\&.
.PP
Referenced by _resetusb()\&.
.PP
.nf
501                                                            {
502     TEST_RESET(usbunclaim(kb, 1));
503     TEST_RESET(ioctl(kb->handle - 1, USBDEVFS_RESET));
504     TEST_RESET(usbclaim(kb));
505     // Success!
506     return 0;
507 }
.fi
.SS "void os_sendindicators (\fBusbdevice\fP *kb)"
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
Read the data from kb->ileds ans send them via ioctl() to the keyboard\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 Interface 0 MSG_SIZE 1 Byte timeout 0,5ms the message buffer pointer Host to Device, Type=Class, Recipient=Interface (why not endpoint?) 9 = SEND? specific 0 1 500 struct* kb->ileds 
.br
 The ioctl command is USBDEVFS_CONTROL\&. 
.PP
Definition at line 217 of file usb_linux\&.c\&.
.PP
References ckb_err, usbdevice::handle, usbdevice::ileds, and usb_tryreset()\&.
.PP
Referenced by updateindicators_kb()\&.
.PP
.nf
217                                       {
218     static int countForReset = 0;
219     struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, 0x00, 1, 500, &kb->ileds };
220     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
221     if(res <= 0) {
222         ckb_err("%s\n", res ? strerror(errno) : "No data written");
223         if (usb_tryreset(kb) == 0 && countForReset++ < 3) {
224             os_sendindicators(kb);
225         }
226     }
227 }
.fi
.SS "int os_setupusb (\fBusbdevice\fP *kb)"
os_setupusb OS-specific setup for a specific usb device\&.
.PP
Perform the operating system-specific opening of the interface in \fBos_setupusb()\fP\&. As a result, some parameters should be set in kb (name, serial, fwversion, epcount = number of usb endpoints), and all endpoints should be claimed with \fBusbclaim()\fP\&. Claiming is the only point where \fBos_setupusb()\fP can produce an error (-1)\&. 
.IP "\(bu" 2
Copy device description and serial
.IP "\(bu" 2
Copy firmware version (needed to determine USB protocol)
.IP "\(bu" 2
Do some output about connecting interfaces
.IP "\(bu" 2
Claim the USB interfaces
.PP
.PP
\fBTodo\fP
.RS 4
in these modules a pullrequest is outstanding 
.RE
.PP
.PP
< Try to reset the device and recall the function
.PP
< Don't do this endless in recursion
.PP
< \fBos_setupusb()\fP has a return value (used as boolean) 
.PP
Definition at line 539 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, devpath, usbdevice::epcount, usbdevice::fwversion, INDEX_OF, KB_NAME_LEN, keyboard, usbdevice::name, usbdevice::serial, SERIAL_LEN, strtrim(), usbdevice::udev, usb_tryreset(), and usbclaim()\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
539                                {
542     struct udev_device* dev = kb->udev;
543     const char* name = udev_device_get_sysattr_value(dev, "product");
544     if(name)
545         strncpy(kb->name, name, KB_NAME_LEN);
546     strtrim(kb->name);
547     const char* serial = udev_device_get_sysattr_value(dev, "serial");
548     if(serial)
549         strncpy(kb->serial, serial, SERIAL_LEN);
550     strtrim(kb->serial);
553     const char* firmware = udev_device_get_sysattr_value(dev, "bcdDevice");
554     if(firmware)
555         sscanf(firmware, "%hx", &kb->fwversion);
556     else
557         kb->fwversion = 0;
558     int index = INDEX_OF(kb, keyboard);
561     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
562 
568     const char* ep_str = udev_device_get_sysattr_value(dev, "bNumInterfaces");
569 #ifdef DEBUG
570     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
571     ckb_info("claiming interfaces\&. name=%s, serial=%s, firmware=%s; Got >>%s<< as ep_str\n", name, serial, firmware, ep_str);
572 #endif //DEBUG
573     kb->epcount = 0;
574     if(ep_str)
575         sscanf(ep_str, "%d", &kb->epcount);
576     if(kb->epcount < 2){
577         // IF we have an RGB KB with 0 or 1 endpoints, it will be in BIOS mode\&.
578         ckb_err("Unable to read endpoint count from udev, assuming %d and reading >>%s<< or device is in BIOS mode\n", kb->epcount, ep_str);
579         if (usb_tryreset(kb) == 0) { 
580             static int retryCount = 0; 
581             if (retryCount++ < 5) {
582                 return os_setupusb(kb); 
583             }
584         }
585         return -1;
586         // ToDo are there special versions we have to detect? If there are, that was the old code to handle it:
587         // This shouldn't happen, but if it does, assume EP count based onckb_warn what the device is supposed to have
588         // kb->epcount = (HAS_FEATURES(kb, FEAT_RGB) ? 4 : 3);
589         // ckb_warn("Unable to read endpoint count from udev, assuming %d and reading >>%s<<\&.\&.\&.\n", kb->epcount, ep_str);
590     }
591     if(usbclaim(kb)){
592         ckb_err("Failed to claim interfaces: %s\n", strerror(errno));
593         return -1;
594     }
595     return 0;
596 }
.fi
.SS "int os_usbrecv (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, intline)"
os_usbrecv does what its name says:
.PP
The comment at the beginning of the procedure causes the suspicion that the firmware versionspecific distinction is missing for receiving from usb endpoint 3 or 4\&. The commented code contains only the reception from EP4, but this may be wrong for a software version 2\&.0 or higher (see the code for os-usbsend ())\&.
.PP

.br
 So all the receiving is done via an ioctl() like in os_usbsend\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0xA1 0x01 0x0200 endpoint to be addressed from epcount - 1 MSG_SIZE 5ms the message buffer pointer Device to Host, Type=Class, Recipient=Interface 1 = RECEIVE? specific Interface # 64 5000 in_msg The ioctl() returns the number of bytes received\&. Here is the usual check again:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbrecv()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes are received, 0 is returned as an identifier for a heavy error\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes received\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Read YY bytes (expected 64)']\&. 
.PP
Definition at line 132 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv()\&.
.PP
.nf
132                                                                         {
133     int res;
134     // This is what CUE does, but it doesn't seem to work on linux\&.
135     /*if(kb->fwversion >= 0x130){
136         struct usbdevfs_bulktransfer transfer;
137         memset(&transfer, 0, sizeof(transfer));
138         transfer\&.ep = 0x84;
139         transfer\&.len = MSG_SIZE;
140         transfer\&.timeout = 5000;
141         transfer\&.data = in_msg;
142         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
143     } else {*/
144         struct usbdevfs_ctrltransfer transfer = { 0xa1, 0x01, 0x0300, kb->epcount - 1, MSG_SIZE, 5000, in_msg };
145         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
146     //}
147     if(res <= 0){
148         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data read");
149         if(res == -1 && errno == ETIMEDOUT)
150             return -1;
151         else
152             return 0;
153     } else if(res != MSG_SIZE)
154         ckb_warn_fn("Read %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
155 #ifdef DEBUG_USB_RECV
156     char converted[MSG_SIZE*3 + 1];
157     for(int i=0;i<MSG_SIZE;i++)
158         sprintf(&converted[i*3], "%02x ", in_msg[i]);
159     ckb_warn_fn("Recv %s\n", file, line, converted);
160 #endif
161     return res;
162 }
.fi
.SS "int os_usbsend (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, intis_recv, const char *file, intline)"
os_usbsend has two functions:
.IP "\(bu" 2
if is_recv == false, it tries to send a given MSG_SIZE buffer via the usb interface given with kb\&.
.IP "\(bu" 2
otherwise a request is sent via the usb device to initiate the receiving of a message from the remote device\&.
.PP
.PP
The functionality for sending distinguishes two cases, depending on the version number of the firmware of the connected device: 
.br
 If the firmware is less or equal 1\&.2, the transmission is done via an ioctl()\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 endpoint / IF to be addressed from epcount-1 MSG_SIZE 5000 (=5ms) the message buffer pointer Host to Device, Type=Class, Recipient=Interface 9 = Send data? specific last or pre-last device # 64 5000 out_msg 
.br
 The ioctl command is USBDEVFS_CONTROL\&.
.PP
The same constellation is used if the device is requested to send its data (is_recv = true)\&.
.PP
For a more recent firmware and is_recv = false, the ioctl command USBDEVFS_CONTROL is not used (this tells the bus to enter the control mode), but the bulk method is used: USBDEVFS_BULK\&. This is astonishing, because all of the endpoints are type Interrupt, not bulk\&.
.PP
Anyhow, forthis purpose a different structure is used for the ioctl() (struct \fBusbdevfs_bulktransfer\fP) and this is also initialized differently: 
.br
 The length and timeout parameters are given the same values as above\&. The formal parameter out_msg is also passed as a buffer pointer\&. For the endpoints, the firmware version is differentiated again: 
.br
 For a firmware version between 1\&.3 and <2\&.0 endpoint 4 is used, otherwise (it can only be >=2\&.0) endpoint 3 is used\&.
.PP
\fBTodo\fP
.RS 4
Since the handling of endpoints has already led to problems elsewhere, this implementation is extremely hardware-dependent and critical! 
.br
 Eg\&. the new keyboard K95PLATINUMRGB has a version number significantly less than 2\&.0 - will it run with this implementation?
.RE
.PP
.PP
The ioctl() - no matter what type - returns the number of bytes sent\&. Now comes the usual check:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbsend()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes sent, 0 is returned as a heavy error identifier\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes sent\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Wrote YY bytes (expected 64)']\&.
.PP
If DEBUG_USB is set during compilation, the number of bytes sent and their representation are logged to the error channel\&. 
.PP
Definition at line 70 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::fwversion, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv(), and _usbsend()\&.
.PP
.nf
70                                                                                              {
71     int res;
72     if (kb->fwversion >= 0x120 && !is_recv) {
73         struct usbdevfs_bulktransfer transfer;
74         memset(&transfer, 0, sizeof(transfer));
75         transfer\&.ep = (kb->fwversion >= 0x130 && kb->fwversion < 0x200) ? 4 : 3;
76         transfer\&.len = MSG_SIZE;
77         transfer\&.timeout = 5000;
78         transfer\&.data = (void*)out_msg;
79         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
80     } else {
81         struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, kb->epcount - 1, MSG_SIZE, 5000, (void*)out_msg };
82         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
83     }
84 
85     if (res <= 0){
86         ckb_err_fn(" %s, res = 0x%x\n", file, line, res ? strerror(errno) : "No data written", res);
87         if(res == -1 && errno == ETIMEDOUT)
88             return -1;
89         else
90             return 0;
91     } else if (res != MSG_SIZE)
92         ckb_warn_fn("Wrote %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
93 #ifdef DEBUG_USB
94     char converted[MSG_SIZE*3 + 1];
95     for(int i=0;i<MSG_SIZE;i++)
96         sprintf(&converted[i*3], "%02x ", out_msg[i]);
97     ckb_warn_fn("Sent %s\n", file, line, converted);
98 #endif
99     return res;
100 }
.fi
.SS "void strtrim (char *string)"
strtrim trims a string by removing leading and trailing spaces\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP 
.RE
.PP

.PP
Definition at line 514 of file usb_linux\&.c\&.
.PP
Referenced by os_setupusb()\&.
.PP
.nf
514                           {
515     // Find last non-space
516     char* last = string;
517     for(char* c = string; *c != 0; c++){
518         if(!isspace(*c))
519             last = c;
520     }
521     last[1] = 0;
522     // Find first non-space
523     char* first = string;
524     for(; *first != 0; first++){
525         if(!isspace(*first))
526             break;
527     }
528     if(first != string)
529         memmove(string, first, last - first);
530 }
.fi
.SS "static void udev_enum ()\fC [static]\fP"
Reduce the hits of the enumeration by limiting to usb as technology and corsair as idVendor\&. Then filter with udev_enumerate_scan_devices () all hits\&.
.PP
The following call to udev_enumerate_get_list_entry() fetches the entire hitlist as udev_list_entry *\&. 
.br
 Use udev_list_entry_foreach() to iterate through the hit set\&. 
.br
 If both the device name exists (udev_list_entry_get_name) and the subsequent creation of a new udev_device (udev_device_new_from_syspath) is ok, the new device is added to the list with \fBusb_add_device()\fP\&.
.PP
If the latter does not work, the new device is released again (udev_device_unref ())\&. 
.br
 After the last iteration, the enumerator is released with udev_enumerate_unref ()\&. 
.PP
Definition at line 752 of file usb_linux\&.c\&.
.PP
References usb_add_device(), and V_CORSAIR_STR\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
752                        {
753     struct udev_enumerate* enumerator = udev_enumerate_new(udev);
754     udev_enumerate_add_match_subsystem(enumerator, "usb");
755     udev_enumerate_add_match_sysattr(enumerator, "idVendor", V_CORSAIR_STR);
756     udev_enumerate_scan_devices(enumerator);
757     struct udev_list_entry* devices, *dev_list_entry;
758     devices = udev_enumerate_get_list_entry(enumerator);
759 
760     udev_list_entry_foreach(dev_list_entry, devices){
761         const char* path = udev_list_entry_get_name(dev_list_entry);
762         if(!path)
763             continue;
764         struct udev_device* dev = udev_device_new_from_syspath(udev, path);
765         if(!dev)
766             continue;
767         // If the device matches a recognized device ID, open it
768         if(usb_add_device(dev))
769             // Release device if not
770             udev_device_unref(dev);
771     }
772     udev_enumerate_unref(enumerator);
773 }
.fi
.SS "static int usb_add_device (struct udev_device *dev)\fC [static]\fP"
If the device id can be found, call \fBusbadd()\fP with the appropriate parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the retval of \fBusbadd()\fP or 1 if either vendor is not corsair or product is not mentioned in model[]\&.
.RE
.PP
First get the idVendor via udev_device_get_sysattr_value()\&. If this is equal to the ID-string of corsair ('1b1c'), get the idProduct on the same way\&. 
.br
 If we can find the model name in the model array, call \fBusbadd()\fP with the model number\&. 
.PP
\fBTodo\fP
.RS 4
So why the hell not a transformation between the string and the short presentation? Lets check if the string representation is used elsewhere\&. 
.RE
.PP

.PP
Definition at line 700 of file usb_linux\&.c\&.
.PP
References N_MODELS, usbadd(), V_CORSAIR, and V_CORSAIR_STR\&.
.PP
Referenced by udev_enum(), and usbmain()\&.
.PP
.nf
700                                                   {
701     const char* vendor = udev_device_get_sysattr_value(dev, "idVendor");
702     if(vendor && !strcmp(vendor, V_CORSAIR_STR)){
703         const char* product = udev_device_get_sysattr_value(dev, "idProduct");
704         if(product){
705             for(_model* model = models; model < models + N_MODELS; model++){
706                 if(!strcmp(product, model->name)){
707                     return usbadd(dev, V_CORSAIR, model->number);
708                 }
709             }
710         }
711     }
712     return 1;
713 }
.fi
.SS "static void usb_rm_device (struct udev_device *dev)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&.
.RE
.PP
First try to find the system path of the device given in parameter dev\&. The index where the name is found is the same index we need to address the global keyboard array\&. That array holds all usbdevices\&. 
.br
 Searching for the correct name in kbsyspath-array and closing the usb via \fBcloseusb()\fP are protected by lock\&.\&.unlock of the corresponding devmutex arraymember\&. 
.PP
Definition at line 725 of file usb_linux\&.c\&.
.PP
References closeusb(), DEV_MAX, devmutex, kbsyspath, and keyboard\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
725                                                   {
726     // Device removed\&. Look for it in our list of keyboards
727     const char* syspath = udev_device_get_syspath(dev);
728     if(!syspath || syspath[0] == 0)
729         return;
730     for(int i = 1; i < DEV_MAX; i++){
731         pthread_mutex_lock(devmutex + i);
732         if(!strcmp(syspath, kbsyspath[i]))
733             closeusb(keyboard + i);
734         pthread_mutex_unlock(devmutex + i);
735     }
736 }
.fi
.SS "int usbadd (struct udev_device *dev, shortvendor, shortproduct)"

.PP
Definition at line 598 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, DEV_MAX, dmutex, usbdevice::handle, IS_CONNECTED, kbsyspath, keyboard, usbdevice::product, setupusb(), usbdevice::udev, and usbdevice::vendor\&.
.PP
Referenced by usb_add_device()\&.
.PP
.nf
598                                                                  {
599     const char* path = udev_device_get_devnode(dev);
600     const char* syspath = udev_device_get_syspath(dev);
601     if(!path || !syspath || path[0] == 0 || syspath[0] == 0){
602         ckb_err("Failed to get device path\n");
603         return -1;
604     }
605 #ifdef DEBUG
606     ckb_info(">>>vendor = 0x%x, product = 0x%x, path = %s, syspath = %s\n", vendor, product, path, syspath);
607 #endif // DEDBUG
608     // Find a free USB slot
609     for(int index = 1; index < DEV_MAX; index++){
610         usbdevice* kb = keyboard + index;
611         if(pthread_mutex_trylock(dmutex(kb))){
612             // If the mutex is locked then the device is obviously in use, so keep going
613             if(!strcmp(syspath, kbsyspath[index])){
614                 // Make sure this existing keyboard doesn't have the same syspath (this shouldn't happen)
615                 return 0;
616             }
617             continue;
618         }
619         if(!IS_CONNECTED(kb)){
620             // Open the sysfs device
621             kb->handle = open(path, O_RDWR) + 1;
622             if(kb->handle <= 0){
623                 ckb_err("Failed to open USB device: %s\n", strerror(errno));
624                 kb->handle = 0;
625                 pthread_mutex_unlock(dmutex(kb));
626                 return -1;
627             } else {
628                 // Set up device
629                 kb->udev = dev;
630                 kb->vendor = vendor;
631                 kb->product = product;
632                 strncpy(kbsyspath[index], syspath, FILENAME_MAX);
633                 // Mutex remains locked
634                 setupusb(kb);
635                 return 0;
636             }
637         }
638         pthread_mutex_unlock(dmutex(kb));
639     }
640     ckb_err("No free devices\n");
641     return -1;
642 }
.fi
.SS "static int usbclaim (\fBusbdevice\fP *kb)\fC [static]\fP"
usbclaim does claiming all EPs for the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 otherwise\&.
.RE
.PP
Claim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCONNECT) and ioctl(USBDEVFS_CLAIMINTERFACE)\&.
.PP
Error handling is done for the ioctl(USBDEVFS_CLAIMINTERFACE) only\&. If this fails, now an error message is thrown and -1 is returned\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 463 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, usbdevice::epcount, and usbdevice::handle\&.
.PP
Referenced by os_resetusb(), and os_setupusb()\&.
.PP
.nf
463                                   {
464     int count = kb->epcount;
465 #ifdef DEBUG
466     ckb_info("claiming %d endpoints\n", count);
467 #endif // DEBUG
468 
469     for (int i = 0; i < count; i++) {
470         struct usbdevfs_ioctl ctl = { i, USBDEVFS_DISCONNECT, 0 };
471         ioctl(kb->handle - 1, USBDEVFS_IOCTL, &ctl);
472         if(ioctl(kb->handle - 1, USBDEVFS_CLAIMINTERFACE, &i)) {
473             ckb_err("Failed to claim interface %d: %s\n", i, strerror(errno));
474             return -1;
475         }
476     }
477     return 0;
478 }
.fi
.SS "void usbkill ()"

.PP
Definition at line 840 of file usb_linux\&.c\&.
.PP
Referenced by quitWithLock()\&.
.PP
.nf
840               {
841     udev_unref(udev);
842     udev = 0;
843 }
.fi
.SS "int usbmain ()"
Start the USB main loop\&. Returns program exit code when finished\&.
.PP
usbmain is called by \fBmain()\fP after setting up all other stuff\&. 
.PP
\fBReturns:\fP
.RS 4
0 normally or -1 if fatal error occurs (up to now only if no new devices are available) 
.RE
.PP
First check whether the uinput module is loaded by the kernel\&. 
.PP
\fBTodo\fP
.RS 4
Why isn't missing of uinput a fatal error? 
.RE
.PP
.PP
Create the udev object with udev_new() (is a function from libudev\&.h) terminate -1 if error
.PP
Enumerate all currently connected devices
.PP
\fBTodo\fP
.RS 4
lae\&. here the work has to go on\&.\&.\&. 
.RE
.PP

.PP
Definition at line 780 of file usb_linux\&.c\&.
.PP
References ckb_fatal, ckb_warn, udev_enum(), usb_add_device(), and usb_rm_device()\&.
.PP
Referenced by main()\&.
.PP
.nf
780              {
785     // Load the uinput module (if it's not loaded already)
786     if(system("modprobe uinput") != 0)
787         ckb_warn("Failed to load uinput module\n");
788 
792     if(!(udev = udev_new())) {
793         ckb_fatal("Failed to initialize udev in usbmain(), usb_linux\&.c\n");
794         return -1;
795     }
796 
799     udev_enum();
800 
803     // Done scanning\&. Enter a loop to poll for device updates
804     struct udev_monitor* monitor = udev_monitor_new_from_netlink(udev, "udev");
805     udev_monitor_filter_add_match_subsystem_devtype(monitor, "usb", 0);
806     udev_monitor_enable_receiving(monitor);
807     // Get an fd for the monitor
808     int fd = udev_monitor_get_fd(monitor);
809     fd_set fds;
810     while(udev){
811         FD_ZERO(&fds);
812         FD_SET(fd, &fds);
813         // Block until an event is read
814         if(select(fd + 1, &fds, 0, 0, 0) > 0 && FD_ISSET(fd, &fds)){
815             struct udev_device* dev = udev_monitor_receive_device(monitor);
816             if(!dev)
817                 continue;
818             const char* action = udev_device_get_action(dev);
819             if(!action){
820                 udev_device_unref(dev);
821                 continue;
822             }
823             // Add/remove device
824             if(!strcmp(action, "add")){
825                 int res = usb_add_device(dev);
826                 if(res == 0)
827                     continue;
828                 // If the device matched but the handle wasn't opened correctly, re-enumerate (this sometimes solves the problem)
829                 if(res == -1)
830                     udev_enum();
831             } else if(!strcmp(action, "remove"))
832                 usb_rm_device(dev);
833             udev_device_unref(dev);
834         }
835     }
836     udev_monitor_unref(monitor);
837     return 0;
838 }
.fi
.SS "static int usbunclaim (\fBusbdevice\fP *kb, intresetting)\fC [static]\fP"
usbunclaim do an unclaiming of the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.br
\fIresetting\fP boolean flag: If resseting is true, the caller will perform a bus reset command after unclaiming the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
always 0\&.
.RE
.PP
Unclaim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCARDURB)\&.
.PP
Afterwards - if ressetting is false - do a USBDEVFS_CONNECT for EP 0 and 1\&. If it is a non RGB device, connect EP 2 also\&. The comment mentions RGB keyboards only, but as I understand the code, this is valid also for RGB mice\&.
.PP
There is no error handling yet\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 410 of file usb_linux\&.c\&.
.PP
References usbdevice::epcount, FEAT_RGB, usbdevice::handle, and HAS_FEATURES\&.
.PP
Referenced by os_closeusb(), and os_resetusb()\&.
.PP
.nf
410                                                     {
411     int handle = kb->handle - 1;
412     int count = kb->epcount;
413     for (int i = 0; i < count; i++) {
414         ioctl(handle, USBDEVFS_RELEASEINTERFACE, &i);
415     }
416     // For RGB keyboards, the kernel driver should only be reconnected to interfaces 0 and 1 (HID), and only if we're not about to do a USB reset\&.
417     // Reconnecting any of the others causes trouble\&.
418     if (!resetting) {
419         struct usbdevfs_ioctl ctl = { 0, USBDEVFS_CONNECT, 0 };
420         ioctl(handle, USBDEVFS_IOCTL, &ctl);
421         ctl\&.ifno = 1;
422         ioctl(handle, USBDEVFS_IOCTL, &ctl);
423         // Also reconnect iface #2 (HID) for non-RGB keyboards
424         if(!HAS_FEATURES(kb, FEAT_RGB)){
425             ctl\&.ifno = 2;
426             ioctl(handle, USBDEVFS_IOCTL, &ctl);
427         }
428     }
429     return 0;
430 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char kbsyspath[9][FILENAME_MAX]\fC [static]\fP"

.PP
Definition at line 15 of file usb_linux\&.c\&.
.PP
Referenced by os_closeusb(), usb_rm_device(), and usbadd()\&.
.SS "\fB_model\fP models[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    
    {  "1b17" ,  0x1b17  },
    {  "1b07" ,  0x1b07  },
    {  "1b37" ,  0x1b37  },
    {  "1b39" ,  0x1b39  },
    {  "1b13" ,  0x1b13  },
    {  "1b09" ,  0x1b09  },
    {  "1b33" ,  0x1b33  },
    {  "1b36" ,  0x1b36  },
    {  "1b38" ,  0x1b38  },
    {  "1b3a" ,  0x1b3a  },
    {  "1b11" ,  0x1b11  },
    {  "1b08" ,  0x1b08  },
    {  "1b2d" ,  0x1b2d  },
    {  "1b20" ,  0x1b20  },
    {  "1b15" ,  0x1b15  },
    
    {  "1b12" ,  0x1b12  },
    {  "1b2e" ,  0x1b2e  },
    {  "1b14" ,  0x1b14   },
    {  "1b19" ,  0x1b19   },
    {  "1b2f" ,  0x1b2f   },
    {  "1b1e" ,  0x1b1e  },
    {  "1b3e" ,  0x1b3e  },
    {  "1b32" ,  0x1b32   }
}
.fi

.PP
\fBAttention:\fP
.RS 4
when adding new hardware this file hat to be changed too\&.
.RE
.PP
In this structure array \fImodels\fP[] for each device the name (the device id as string in hex without leading 0x) and its usb device id as short must be entered in this array\&. 
.PP
Definition at line 660 of file usb_linux\&.c\&.
.SS "struct udev* udev\fC [static]\fP"

.PP
Definition at line 644 of file usb_linux\&.c\&.
.SS "pthread_t udevthread"

.PP
Definition at line 647 of file usb_linux\&.c\&.
.SS "pthread_t usbthread"

.PP
\fBTodo\fP
.RS 4
These two thread vasriables seem to be unused: usbtread, udevthread 
.RE
.PP

.PP
Definition at line 647 of file usb_linux\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
