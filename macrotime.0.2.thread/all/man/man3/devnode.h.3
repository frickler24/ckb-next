.TH "src/ckb-daemon/devnode.h" 3 "Mon Jun 5 2017" "Version beta-v0.2.8+testing at branch macrotime.0.2.thread" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/devnode.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBS_READDIR\fP   (S_IRWXU | S_IRGRP | S_IROTH | S_IXGRP | S_IXOTH)"
.br
.ti -1c
.RI "#define \fBS_READ\fP   (S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR)"
.br
.ti -1c
.RI "#define \fBS_READWRITE\fP   (S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP | S_IWOTH)"
.br
.ti -1c
.RI "#define \fBS_CUSTOM\fP   (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)"
.br
.ti -1c
.RI "#define \fBS_CUSTOM_R\fP   (S_IRUSR | S_IWUSR | S_IRGRP)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_readlines_ctx\fP * \fBreadlines_ctx\fP"
.br
.RI "\fICustom readline is needed for FIFOs\&. fopen()/getline() will die if the data is sent in too fast\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBupdateconnected\fP ()"
.br
.RI "\fIUpdate the list of connected devices\&. \fP"
.ti -1c
.RI "int \fBmkdevpath\fP (\fBusbdevice\fP *kb)"
.br
.RI "\fICreate a dev path for the keyboard at index\&. Returns 0 on success\&. \fP"
.ti -1c
.RI "int \fBrmdevpath\fP (\fBusbdevice\fP *kb)"
.br
.RI "\fIRemove the dev path for the keyboard at index\&. Returns 0 on success\&. \fP"
.ti -1c
.RI "int \fBmknotifynode\fP (\fBusbdevice\fP *kb, int notify)"
.br
.RI "\fICreates a notification node for the specified keyboard\&. \fP"
.ti -1c
.RI "int \fBrmnotifynode\fP (\fBusbdevice\fP *kb, int notify)"
.br
.RI "\fIRemoves a notification node for the specified keyboard\&. \fP"
.ti -1c
.RI "int \fBmkfwnode\fP (\fBusbdevice\fP *kb)"
.br
.RI "\fIWrites a keyboard's firmware version and poll rate to its device node\&. \fP"
.ti -1c
.RI "void \fBreadlines_ctx_init\fP (\fBreadlines_ctx\fP *ctx)"
.br
.ti -1c
.RI "void \fBreadlines_ctx_free\fP (\fBreadlines_ctx\fP ctx)"
.br
.ti -1c
.RI "unsigned \fBreadlines\fP (int fd, \fBreadlines_ctx\fP ctx, const char **input)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char *const \fBdevpath\fP"
.br
.RI "\fIDevice path base ('/dev/input/ckb' or '/var/run/ckb') \fP"
.ti -1c
.RI "long \fBgid\fP"
.br
.RI "\fIGroup ID for the control nodes\&. -1 to give read/write access to everybody\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define S_CUSTOM   (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)"

.PP
Definition at line 17 of file devnode\&.h\&.
.PP
Referenced by _mkdevpath()\&.
.SS "#define S_CUSTOM_R   (S_IRUSR | S_IWUSR | S_IRGRP)"

.PP
Definition at line 18 of file devnode\&.h\&.
.SS "#define S_READ   (S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR)"

.PP
Definition at line 15 of file devnode\&.h\&.
.PP
Referenced by _mkdevpath()\&.
.SS "#define S_READDIR   (S_IRWXU | S_IRGRP | S_IROTH | S_IXGRP | S_IXOTH)"

.PP
Definition at line 14 of file devnode\&.h\&.
.PP
Referenced by _mkdevpath()\&.
.SS "#define S_READWRITE   (S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP | S_IWOTH)"

.PP
Definition at line 16 of file devnode\&.h\&.
.PP
Referenced by _mkdevpath()\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_readlines_ctx\fP* \fBreadlines_ctx\fP"

.PP
Definition at line 39 of file devnode\&.h\&.
.SH "Function Documentation"
.PP 
.SS "int mkdevpath (\fBusbdevice\fP *kb)"

.PP
Definition at line 268 of file devnode\&.c\&.
.PP
References _mkdevpath(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by _setupusb(), and main()\&.
.PP
.nf
268                             {
269     euid_guard_start;
270     int res = _mkdevpath(kb);
271     euid_guard_stop;
272     return res;
273 }
.fi
.SS "int mkfwnode (\fBusbdevice\fP *kb)"

.PP
Definition at line 299 of file devnode\&.c\&.
.PP
References ckb_warn, devpath, usbdevice::fwversion, gid, INDEX_OF, keyboard, usbdevice::pollrate, usbdevice::product, S_GID_READ, and usbdevice::vendor\&.
.PP
Referenced by _mkdevpath(), and fwupdate()\&.
.PP
.nf
299                            {
300     int index = INDEX_OF(kb, keyboard);
301     char fwpath[strlen(devpath) + 12];
302     snprintf(fwpath, sizeof(fwpath), "%s%d/fwversion", devpath, index);
303     FILE* fwfile = fopen(fwpath, "w");
304     if(fwfile){
305         fprintf(fwfile, "%04x:0x%04x:0x%04x", kb->fwversion, kb->vendor, kb->product);
306         fputc('\n', fwfile);
307         fclose(fwfile);
308         chmod(fwpath, S_GID_READ);
309         if(gid >= 0)
310             chown(fwpath, 0, gid);
311     } else {
312         ckb_warn("Unable to create %s: %s\n", fwpath, strerror(errno));
313         remove(fwpath);
314         return -1;
315     }
316     char ppath[strlen(devpath) + 11];
317     snprintf(ppath, sizeof(ppath), "%s%d/pollrate", devpath, index);
318     FILE* pfile = fopen(ppath, "w");
319     if(pfile){
320         fprintf(pfile, "%d ms", kb->pollrate);
321         fputc('\n', pfile);
322         fclose(pfile);
323         chmod(ppath, S_GID_READ);
324         if(gid >= 0)
325             chown(ppath, 0, gid);
326     } else {
327         ckb_warn("Unable to create %s: %s\n", fwpath, strerror(errno));
328         remove(ppath);
329         return -2;
330     }
331     return 0;
332 }
.fi
.SS "int mknotifynode (\fBusbdevice\fP *kb, intnotify)"

.PP
Definition at line 108 of file devnode\&.c\&.
.PP
References _mknotifynode(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by readcmd()\&.
.PP
.nf
108                                            {
109     euid_guard_start;
110     int res = _mknotifynode(kb, notify);
111     euid_guard_stop;
112     return res;
113 }
.fi
.SS "unsigned readlines (intfd, \fBreadlines_ctx\fPctx, const char **input)"

.PP
Definition at line 353 of file devnode\&.c\&.
.PP
References _readlines_ctx::buffer, _readlines_ctx::buffersize, ckb_warn, _readlines_ctx::leftover, _readlines_ctx::leftoverlen, and MAX_BUFFER\&.
.PP
Referenced by devmain()\&.
.PP
.nf
353                                                                  {
354     // Move any data left over from a previous read to the start of the buffer
355     char* buffer = ctx->buffer;
356     int buffersize = ctx->buffersize;
357     int leftover = ctx->leftover, leftoverlen = ctx->leftoverlen;
358     memcpy(buffer, buffer + leftover, leftoverlen);
359     // Read data from the file
360     ssize_t length = read(fd, buffer + leftoverlen, buffersize - leftoverlen);
361     length = (length < 0 ? 0 : length) + leftoverlen;
362     leftover = ctx->leftover = leftoverlen = ctx->leftoverlen = 0;
363     if(length <= 0){
364         *input = 0;
365         return 0;
366     }
367     // Continue buffering until all available input is read or there's no room left
368     while(length == buffersize){
369         if(buffersize == MAX_BUFFER)
370             break;
371         int oldsize = buffersize;
372         buffersize += 4096;
373         ctx->buffersize = buffersize;
374         buffer = ctx->buffer = realloc(buffer, buffersize + 1);
375         ssize_t length2 = read(fd, buffer + oldsize, buffersize - oldsize);
376         if(length2 <= 0)
377             break;
378         length += length2;
379     }
380     buffer[length] = 0;
381     // Input should be issued one line at a time and should end with a newline\&.
382     char* lastline = memrchr(buffer, '\n', length);
383     if(lastline == buffer + length - 1){
384         // If the buffer ends in a newline, process the whole string
385         *input = buffer;
386         return length;
387     } else if(lastline){
388         // Otherwise, chop off the last line but process everything else
389         *lastline = 0;
390         leftover = ctx->leftover = lastline + 1 - buffer;
391         leftoverlen = ctx->leftoverlen = length - leftover;
392         *input = buffer;
393         return leftover - 1;
394     } else {
395         // If a newline wasn't found at all, process the whole buffer next time
396         *input = 0;
397         if(length == MAX_BUFFER){
398             // Unless the buffer is completely full, in which case discard it
399             ckb_warn("Too much input (1MB)\&. Dropping\&.\n");
400             return 0;
401         }
402         leftoverlen = ctx->leftoverlen = length;
403         return 0;
404     }
405 }
.fi
.SS "void readlines_ctx_free (\fBreadlines_ctx\fPctx)"

.PP
Definition at line 348 of file devnode\&.c\&.
.PP
References _readlines_ctx::buffer\&.
.PP
Referenced by devmain()\&.
.PP
.nf
348                                           {
349     free(ctx->buffer);
350     free(ctx);
351 }
.fi
.SS "void readlines_ctx_init (\fBreadlines_ctx\fP *ctx)"

.PP
Definition at line 341 of file devnode\&.c\&.
.PP
Referenced by devmain()\&.
.PP
.nf
341                                            {
342     // Allocate buffers to store data
343     *ctx = calloc(1, sizeof(struct _readlines_ctx));
344     int buffersize = (*ctx)->buffersize = 4095;
345     (*ctx)->buffer = malloc(buffersize + 1);
346 }
.fi
.SS "int rmdevpath (\fBusbdevice\fP *kb)"

.PP
Definition at line 275 of file devnode\&.c\&.
.PP
References _rmnotifynode(), ckb_info, ckb_warn, devpath, euid_guard_start, euid_guard_stop, INDEX_OF, usbdevice::infifo, keyboard, OUTFIFO_MAX, and rm_recursive()\&.
.PP
Referenced by closeusb(), and quitWithLock()\&.
.PP
.nf
275                             {
276     euid_guard_start;
277     int index = INDEX_OF(kb, keyboard);
278     if(kb->infifo != 0){
279 #ifdef OS_LINUX
280         write(kb->infifo - 1, "\n", 1); // hack to prevent the FIFO thread from perma-blocking
281 #endif
282         close(kb->infifo - 1);
283         kb->infifo = 0;
284     }
285     for(int i = 0; i < OUTFIFO_MAX; i++)
286         _rmnotifynode(kb, i);
287     char path[strlen(devpath) + 2];
288     snprintf(path, sizeof(path), "%s%d", devpath, index);
289     if(rm_recursive(path) != 0 && errno != ENOENT){
290         ckb_warn("Unable to delete %s: %s\n", path, strerror(errno));
291         euid_guard_stop;
292         return -1;
293     }
294     ckb_info("Removed device path %s\n", path);
295     euid_guard_stop;
296     return 0;
297 }
.fi
.SS "int rmnotifynode (\fBusbdevice\fP *kb, intnotify)"

.PP
Definition at line 129 of file devnode\&.c\&.
.PP
References _rmnotifynode(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by readcmd()\&.
.PP
.nf
129                                            {
130     euid_guard_start;
131     int res = _rmnotifynode(kb, notify);
132     euid_guard_stop;
133     return res;
134 }
.fi
.SS "void updateconnected ()"

.PP
Definition at line 81 of file devnode\&.c\&.
.PP
References _updateconnected(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by _setupusb(), and closeusb()\&.
.PP
.nf
81                       {
82     euid_guard_start;
83     _updateconnected();
84     euid_guard_stop;
85 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const char* const devpath"

.PP
Definition at line 8 of file devnode\&.h\&.
.SS "long gid"

.PP
Definition at line 16 of file devnode\&.c\&.
.PP
Referenced by _mkdevpath(), _mknotifynode(), _updateconnected(), main(), and mkfwnode()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
