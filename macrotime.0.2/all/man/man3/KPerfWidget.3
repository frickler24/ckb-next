.TH "KPerfWidget" 3 "Mon Jun 5 2017" "Version beta-v0.2.8+testing at branch macrotime.0.2" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KPerfWidget \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kperfwidget\&.h>\fP
.PP
Inherits \fBQWidget\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBIndicatorUi\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBKbPerf::indicator\fP \fBindicator\fP"
.br
.ti -1c
.RI "typedef \fBKbPerf::i_hw\fP \fBi_hw\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKPerfWidget\fP (\fBQWidget\fP *parent=0)"
.br
.RI "\fI\fBKPerfWidget::KPerfWidget\fP sets up the UI for Keyboard Performace panel\&. \fP"
.ti -1c
.RI "\fB~KPerfWidget\fP ()"
.br
.RI "\fI\fBKPerfWidget::~KPerfWidget\fP nothing unusual - just delete the ui object\&. \fP"
.ti -1c
.RI "void \fBsetPerf\fP (\fBKbPerf\fP *newPerf, \fBKbProfile\fP *newProfile)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBI_COUNT\fP = KbPerf::I_COUNT"
.br
.ti -1c
.RI "static const int \fBHW_I_COUNT\fP = KbPerf::HW_I_COUNT"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBHwMode\fP { \fBNORMAL\fP, \fBALWAYS_ON\fP, \fBALWAYS_OFF\fP, \fBRGB\fP, \fBBOTH\fP }"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBuiUpdated\fP (int index)"
.br
.ti -1c
.RI "void \fBon_intensityBox_valueChanged\fP (int arg1)"
.br
.ti -1c
.RI "void \fBon_copyButton_clicked\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBHwMode\fP \fBraw2Mode\fP (bool sw_enable, \fBi_hw\fP hw_enable)"
.br
.RI "\fI\fBKPerfWidget::raw2Mode\fP return hardware mode depending on setiings in \fIsw_enable\fP and \fIhw_enable\fP\&. \fP"
.ti -1c
.RI "void \fBmode2Raw\fP (\fBHwMode\fP mode, bool &sw_enable, \fBi_hw\fP &hw_enable)"
.br
.RI "\fI\fBKPerfWidget::mode2Raw\fP Set values of sw_enable and hw_enable to hte value corresponding to input var mode\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBUi::KPerfWidget\fP * \fBui\fP"
.br
.ti -1c
.RI "\fBKbPerf\fP * \fBperf\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBprofile\fP"
.br
.ti -1c
.RI "\fBIndicatorUi\fP \fBindicators\fP [\fBI_COUNT\fP]"
.br
.ti -1c
.RI "QList< \fBQWidget\fP * > \fBk95Widgets\fP"
.br
.ti -1c
.RI "QSignalMapper \fBupdateMapper\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 16 of file kperfwidget\&.h\&.
.SH "Data Structure Documentation"
.PP 
.SH "struct KPerfWidget::IndicatorUi"
.PP 
Definition at line 54 of file kperfwidget\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
\fBColorButton\fP * \fIcolor1\fP 
.br
.PP
\fBColorButton\fP * \fIcolor2\fP 
.br
.PP
\fBColorButton\fP * \fIcolor3\fP 
.br
.PP
QCheckBox * \fIenable\fP 
.br
.PP
QComboBox * \fIhwEnable\fP 
.br
.PP
.RE
.PP
.SH "Member Typedef Documentation"
.PP 
.SS "typedef \fBKbPerf::i_hw\fP \fBKPerfWidget::i_hw\fP"

.PP
Definition at line 29 of file kperfwidget\&.h\&.
.SS "typedef \fBKbPerf::indicator\fP \fBKPerfWidget::indicator\fP"

.PP
Definition at line 28 of file kperfwidget\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBKPerfWidget::HwMode\fP\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINORMAL \fP\fP
.TP
\fB\fIALWAYS_ON \fP\fP
.TP
\fB\fIALWAYS_OFF \fP\fP
.TP
\fB\fIRGB \fP\fP
.TP
\fB\fIBOTH \fP\fP
.PP
Definition at line 38 of file kperfwidget\&.h\&.
.PP
.nf
38                 {
39         NORMAL,
40         ALWAYS_ON,
41         ALWAYS_OFF,
42         RGB,
43         BOTH
44     };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KPerfWidget::KPerfWidget (\fBQWidget\fP *parent = \fC0\fP)\fC [explicit]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIparent\fP 
.RE
.PP

.PP
Definition at line 10 of file kperfwidget\&.cpp\&.
.PP
References ColorButton::allowAlpha(), ColorButton::bigIcons(), Ui_KPerfWidget::capsBox, Ui_KPerfWidget::capsColorOff, Ui_KPerfWidget::capsColorOn, KPerfWidget::IndicatorUi::color1, KPerfWidget::IndicatorUi::color2, KPerfWidget::IndicatorUi::color3, KPerfWidget::IndicatorUi::enable, KPerfWidget::IndicatorUi::hwEnable, I_COUNT, indicators, Ui_KPerfWidget::k95Label1, Ui_KPerfWidget::k95Label2, Ui_KPerfWidget::k95Label3, Ui_KPerfWidget::k95Label4, Ui_KPerfWidget::k95Label5, Ui_KPerfWidget::k95Label6, Ui_KPerfWidget::k95Line, Ui_KPerfWidget::k95Spacer, k95Widgets, Ui_KPerfWidget::lightBox, Ui_KPerfWidget::lightColor1, Ui_KPerfWidget::lightColor2, Ui_KPerfWidget::lightColor3, Ui_KPerfWidget::lockBox, Ui_KPerfWidget::lockColorOff, Ui_KPerfWidget::lockColorOn, Ui_KPerfWidget::macroBox, Ui_KPerfWidget::macroColorOff, Ui_KPerfWidget::macroColorOn, Ui_KPerfWidget::modeBox, Ui_KPerfWidget::modeColorOff, Ui_KPerfWidget::modeColorOn, Ui_KPerfWidget::muteBox, Ui_KPerfWidget::muteColorNA, Ui_KPerfWidget::muteColorOff, Ui_KPerfWidget::muteColorOn, Ui_KPerfWidget::numBox, Ui_KPerfWidget::numColorOff, Ui_KPerfWidget::numColorOn, Ui_KPerfWidget::scrollBox, Ui_KPerfWidget::scrollColorOff, Ui_KPerfWidget::scrollColorOn, ColorButton::setLabel(), Ui_KPerfWidget::setupUi(), ui, uiUpdated(), and updateMapper\&.
.PP
.nf
10                                         :
11     QWidget(parent),
12     ui(new Ui::KPerfWidget)
13 {
14     ui->setupUi(this);
15     // Set up indicators
16     indicators[0]\&.enable = 0; indicators[0]\&.hwEnable = ui->numBox; indicators[0]\&.color1 = ui->numColorOn; indicators[0]\&.color2 = ui->numColorOff; indicators[0]\&.color3 = 0;
17     indicators[1]\&.enable = 0; indicators[1]\&.hwEnable = ui->capsBox; indicators[1]\&.color1 = ui->capsColorOn; indicators[1]\&.color2 = ui->capsColorOff; indicators[1]\&.color3 = 0;
18     indicators[2]\&.enable = 0; indicators[2]\&.hwEnable = ui->scrollBox; indicators[2]\&.color1 = ui->scrollColorOn; indicators[2]\&.color2 = ui->scrollColorOff; indicators[2]\&.color3 = 0;
19     indicators[3]\&.enable = ui->modeBox; indicators[3]\&.hwEnable = 0; indicators[3]\&.color1 = ui->modeColorOn; indicators[3]\&.color2 = ui->modeColorOff; indicators[3]\&.color3 = 0;
20     indicators[4]\&.enable = ui->macroBox; indicators[4]\&.hwEnable = 0; indicators[4]\&.color1 = ui->macroColorOn; indicators[4]\&.color2 = ui->macroColorOff; indicators[4]\&.color3 = 0;
21     indicators[5]\&.enable = ui->lightBox; indicators[5]\&.hwEnable = 0; indicators[5]\&.color1 = ui->lightColor1; indicators[5]\&.color2 = ui->lightColor2; indicators[5]\&.color3 = ui->lightColor3;
22     indicators[6]\&.enable = ui->lockBox; indicators[6]\&.hwEnable = 0; indicators[6]\&.color1 = ui->lockColorOn; indicators[6]\&.color2 = ui->lockColorOff; indicators[6]\&.color3 = 0;
23     indicators[7]\&.enable = ui->muteBox; indicators[7]\&.hwEnable = 0; indicators[7]\&.color1 = ui->muteColorOn; indicators[7]\&.color2 = ui->muteColorOff; indicators[7]\&.color3 = ui->muteColorNA;
24     for(int i = 0; i < I_COUNT; i++){
25         indicators[i]\&.color1->setLabel(false);
26         indicators[i]\&.color1->bigIcons(true);
27         indicators[i]\&.color1->allowAlpha(true);
28         indicators[i]\&.color2->setLabel(false);
29         indicators[i]\&.color2->bigIcons(true);
30         indicators[i]\&.color2->allowAlpha(true);
31         if(indicators[i]\&.color3){
32             indicators[i]\&.color3->setLabel(false);
33             indicators[i]\&.color3->bigIcons(true);
34             indicators[i]\&.color3->allowAlpha(true);
35         }
36         // Map signals
37         if(indicators[i]\&.enable){
38             connect(indicators[i]\&.enable, SIGNAL(clicked(bool)), &updateMapper, SLOT(map()));
39             updateMapper\&.setMapping(indicators[i]\&.enable, i);
40         }
41         if(indicators[i]\&.hwEnable){
42             connect(indicators[i]\&.hwEnable, SIGNAL(activated(int)), &updateMapper, SLOT(map()));
43             updateMapper\&.setMapping(indicators[i]\&.hwEnable, i);
44         }
45         connect(indicators[i]\&.color1, SIGNAL(colorChanged(QColor)), &updateMapper, SLOT(map()));
46         updateMapper\&.setMapping(indicators[i]\&.color1, i);
47         connect(indicators[i]\&.color2, SIGNAL(colorChanged(QColor)), &updateMapper, SLOT(map()));
48         updateMapper\&.setMapping(indicators[i]\&.color2, i);
49         if(indicators[i]\&.color3){
50             connect(indicators[i]\&.color3, SIGNAL(colorChanged(QColor)), &updateMapper, SLOT(map()));
51             updateMapper\&.setMapping(indicators[i]\&.color3, i);
52         }
53     }
54     connect(&updateMapper, SIGNAL(mapped(int)), this, SLOT(uiUpdated(int)));
55     k95Widgets << ui->modeBox << ui->modeColorOn << ui->modeColorOff << ui->macroBox << ui->macroColorOn << ui->macroColorOff << ui->k95Label1 << ui->k95Label2 << ui->k95Label3 << ui->k95Label4 << ui->k95Label5 << ui->k95Label6 << ui->k95Line << ui->k95Spacer;
56 }
.fi
.SS "KPerfWidget::~KPerfWidget ()"

.PP
Definition at line 61 of file kperfwidget\&.cpp\&.
.PP
References ui\&.
.PP
.nf
61                          {
62     delete ui;
63 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void KPerfWidget::mode2Raw (\fBHwMode\fPmode, bool &sw_enable, \fBi_hw\fP &hw_enable)\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fI[IN]\fP mode 
.br
\fI[OUT]\fP sw_enable 
.br
\fI[OUT]\fP hw_enable
.br
\fI[IN]\fP mode 
.br
\fI[OUT]\fP sw_enable 
.br
\fI[OUT]\fP hw_enable mode determines how colors at a key and separate indicators should be handled: Mode | sw | hw _ | _ | _ NORMAL | No color change at the key | use the separate indicator depending on key state ALWAYS_ON | No color change at the key | switch on separate indicator ALWAYS_OFF | No color change at the key | switch off separate indicator RGB | use color change at the key depending on color sliders | switch off separate indicator BOTH | use color change at the key depending on color sliders | use the separate indicator depending on key state 
.RE
.PP

.PP
Definition at line 100 of file kperfwidget\&.cpp\&.
.PP
References ALWAYS_OFF, ALWAYS_ON, BOTH, NORMAL, KbPerf::NORMAL, KbPerf::OFF, KbPerf::ON, and RGB\&.
.PP
Referenced by uiUpdated()\&.
.PP
.nf
100                                                                        {
101     switch(mode){
102     case NORMAL:
103         sw_enable = false;
104         hw_enable = KbPerf::NORMAL;
105         break;
106     case ALWAYS_ON:
107         sw_enable = false;
108         hw_enable = KbPerf::ON;
109         break;
110     case ALWAYS_OFF:
111         sw_enable = false;
112         hw_enable = KbPerf::OFF;
113         break;
114     case RGB:
115         sw_enable = true;
116         hw_enable = KbPerf::OFF;
117         break;
118     case BOTH:
119         sw_enable = true;
120         hw_enable = KbPerf::NORMAL;
121         break;
122     }
123 }
.fi
.SS "void KPerfWidget::on_copyButton_clicked ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 221 of file kperfwidget\&.cpp\&.
.PP
References KbProfile::currentMode(), KbProfile::modes(), perf, KbMode::perf(), profile, and ModeSelectDialog::selection()\&.
.PP
.nf
221                                        {
222     ModeSelectDialog dialog(this, profile->currentMode(), profile->modes(), "Copy performance settings to:");
223     if(dialog\&.exec() != QDialog::Accepted)
224         return;
225     QList<KbMode*> selectedModes = dialog\&.selection();
226     foreach(KbMode* mode, selectedModes){
227         *mode->perf() = *perf;
228     }
229 }
.fi
.SS "void KPerfWidget::on_intensityBox_valueChanged (intarg1)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 215 of file kperfwidget\&.cpp\&.
.PP
References KbPerf::iOpacity(), and perf\&.
.PP
.nf
215                                                       {
216     if(!perf)
217         return;
218     perf->iOpacity(arg1 / 100\&.f);
219 }
.fi
.SS "\fBKPerfWidget::HwMode\fP KPerfWidget::raw2Mode (boolsw_enable, \fBi_hw\fPhw_enable)\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIsw_enable\fP 
.br
\fIhw_enable\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the mode of operation for key-coloring and separate indicators\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBKPerfWidget::mode2Raw\fP for details\&. 
.RE
.PP

.PP
Definition at line 72 of file kperfwidget\&.cpp\&.
.PP
References ALWAYS_OFF, ALWAYS_ON, BOTH, NORMAL, KbPerf::NORMAL, KbPerf::OFF, KbPerf::ON, and RGB\&.
.PP
Referenced by setPerf()\&.
.PP
.nf
72                                                                      {
73     if(sw_enable){
74         if(hw_enable == KbPerf::NORMAL)
75             return BOTH;
76         return RGB;
77     } else {
78         if(hw_enable == KbPerf::ON)
79             return ALWAYS_ON;
80         else if(hw_enable == KbPerf::OFF)
81             return ALWAYS_OFF;
82         return NORMAL;
83     }
84 }
.fi
.SS "void KPerfWidget::setPerf (\fBKbPerf\fP *newPerf, \fBKbProfile\fP *newProfile)"

.PP
Definition at line 125 of file kperfwidget\&.cpp\&.
.PP
References BOTH, ColorButton::color(), KPerfWidget::IndicatorUi::color1, KPerfWidget::IndicatorUi::color2, KPerfWidget::IndicatorUi::color3, KPerfWidget::IndicatorUi::enable, KbPerf::getIndicator(), HW_I_COUNT, KPerfWidget::IndicatorUi::hwEnable, I_COUNT, indicators, Ui_KPerfWidget::intensityBox, KbPerf::iOpacity(), KeyMap::K95, k95Widgets, KbProfile::keyMap(), Ui_KPerfWidget::label_12, Ui_KPerfWidget::label_14, Ui_KPerfWidget::label_17, KeyMap::model(), Ui_KPerfWidget::muteBox, Ui_KPerfWidget::muteColorNA, Ui_KPerfWidget::muteColorOff, Ui_KPerfWidget::muteColorOn, perf, profile, raw2Mode(), RGB, KeyMap::STRAFE, and ui\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
125                                                                {
126     perf = newPerf;
127     profile = newProfile;
128     // Set intensity
129     ui->intensityBox->setValue(round(perf->iOpacity() * 100\&.f));
130     // Set hardware indicator values
131     for(int i = 0; i < HW_I_COUNT; i++){
132         QColor c1, c2, c3;
133         bool software;
134         i_hw hardware;
135         perf->getIndicator((indicator)i, c1, c2, c3, software, hardware);
136         HwMode mode = raw2Mode(software, hardware);
137         indicators[i]\&.hwEnable->setCurrentIndex((int)mode);
138         indicators[i]\&.color1->color(c1);
139         indicators[i]\&.color2->color(c2);
140         if(mode == RGB || mode == BOTH){
141             indicators[i]\&.color1->setEnabled(true);
142             indicators[i]\&.color2->setEnabled(true);
143         } else {
144             indicators[i]\&.color1->setEnabled(false);
145             indicators[i]\&.color2->setEnabled(false);
146         }
147     }
148     // Set software indicators
149     for(int i = HW_I_COUNT; i < I_COUNT; i++){
150         QColor c1, c2, c3;
151         bool software;
152         i_hw hardware;
153         perf->getIndicator((indicator)i, c1, c2, c3, software, hardware);
154         indicators[i]\&.enable->setChecked(software);
155         indicators[i]\&.color1->color(c1);
156         indicators[i]\&.color2->color(c2);
157         if(indicators[i]\&.color3) indicators[i]\&.color3->color(c3);
158         if(software){
159             indicators[i]\&.color1->setEnabled(true);
160             indicators[i]\&.color2->setEnabled(true);
161             if(indicators[i]\&.color3) indicators[i]\&.color3->setEnabled(true);
162         } else {
163             indicators[i]\&.color1->setEnabled(false);
164             indicators[i]\&.color2->setEnabled(false);
165             if(indicators[i]\&.color3) indicators[i]\&.color3->setEnabled(false);
166         }
167     }
168     // Hide K95 indicators on non-K95s
169     if(profile->keyMap()\&.model() == KeyMap::K95){
170         foreach(QWidget* w, k95Widgets)
171             w->show();
172     } else {
173         foreach(QWidget* w, k95Widgets)
174             w->hide();
175         if(profile->keyMap()\&.model() == KeyMap::STRAFE) { // hide indicators unsupported by STRAFE
176             ui->muteBox->hide();
177             ui->muteColorOn->hide();
178             ui->muteColorOff->hide();
179             ui->muteColorNA->hide();
180             ui->label_12->hide();
181             ui->label_14->hide();
182             ui->label_17->hide();
183        }
184     }
185 }
.fi
.SS "void KPerfWidget::uiUpdated (intindex)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 187 of file kperfwidget\&.cpp\&.
.PP
References ColorButton::color(), KPerfWidget::IndicatorUi::color1, KPerfWidget::IndicatorUi::color2, KPerfWidget::IndicatorUi::color3, KPerfWidget::IndicatorUi::enable, indicators, mode2Raw(), KbPerf::NONE, perf, and KbPerf::setIndicator()\&.
.PP
Referenced by KPerfWidget()\&.
.PP
.nf
187                                     {
188     if(!perf)
189         return;
190     // Read HW/SW enable state
191     bool software;
192     i_hw hardware;
193     if(indicators[index]\&.enable){
194         software = indicators[index]\&.enable->isChecked();
195         hardware = KbPerf::NONE;
196     } else {
197         mode2Raw((HwMode)indicators[index]\&.hwEnable->currentIndex(), software, hardware);
198     }
199     // Enable/disable color buttons based on whether or not the indicator is turned on
200     if(software){
201         indicators[index]\&.color1->setEnabled(true);
202         indicators[index]\&.color2->setEnabled(true);
203         if(indicators[index]\&.color3) indicators[index]\&.color3->setEnabled(true);
204     } else {
205         indicators[index]\&.color1->setEnabled(false);
206         indicators[index]\&.color2->setEnabled(false);
207         if(indicators[index]\&.color3) indicators[index]\&.color3->setEnabled(false);
208     }
209     QColor c1 = indicators[index]\&.color1->color();
210     QColor c2 = indicators[index]\&.color2->color();
211     QColor c3 = indicators[index]\&.color3 ? indicators[index]\&.color3->color() : QColor();
212     perf->setIndicator((indicator)index, c1, c2, c3, software, hardware);
213 }
.fi
.SH "Field Documentation"
.PP 
.SS "const int KPerfWidget::HW_I_COUNT = KbPerf::HW_I_COUNT\fC [static]\fP"

.PP
Definition at line 27 of file kperfwidget\&.h\&.
.PP
Referenced by setPerf()\&.
.SS "const int KPerfWidget::I_COUNT = KbPerf::I_COUNT\fC [static]\fP"

.PP
Definition at line 26 of file kperfwidget\&.h\&.
.PP
Referenced by KPerfWidget(), and setPerf()\&.
.SS "\fBIndicatorUi\fP KPerfWidget::indicators[\fBI_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 59 of file kperfwidget\&.h\&.
.PP
Referenced by KPerfWidget(), setPerf(), and uiUpdated()\&.
.SS "QList<\fBQWidget\fP*> KPerfWidget::k95Widgets\fC [private]\fP"

.PP
Definition at line 60 of file kperfwidget\&.h\&.
.PP
Referenced by KPerfWidget(), and setPerf()\&.
.SS "\fBKbPerf\fP* KPerfWidget::perf\fC [private]\fP"

.PP
Definition at line 34 of file kperfwidget\&.h\&.
.PP
Referenced by on_copyButton_clicked(), on_intensityBox_valueChanged(), setPerf(), and uiUpdated()\&.
.SS "\fBKbProfile\fP* KPerfWidget::profile\fC [private]\fP"

.PP
Definition at line 35 of file kperfwidget\&.h\&.
.PP
Referenced by on_copyButton_clicked(), and setPerf()\&.
.SS "\fBUi::KPerfWidget\fP* KPerfWidget::ui\fC [private]\fP"

.PP
Definition at line 32 of file kperfwidget\&.h\&.
.PP
Referenced by KPerfWidget(), setPerf(), and ~KPerfWidget()\&.
.SS "QSignalMapper KPerfWidget::updateMapper\fC [private]\fP"

.PP
Definition at line 62 of file kperfwidget\&.h\&.
.PP
Referenced by KPerfWidget()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
