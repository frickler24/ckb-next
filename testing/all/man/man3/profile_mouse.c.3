.TH "src/ckb-daemon/profile_mouse.c" 3 "Tue May 16 2017" "Version beta-v0.2.7 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/profile_mouse.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'dpi\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br
\fC#include 'led\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBcmd_hwload_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int apply, const char *dummy3)"
.br
.ti -1c
.RI "int \fBcmd_hwsave_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int cmd_hwload_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intapply, const char *dummy3)"

.PP
Definition at line 6 of file profile_mouse\&.c\&.
.PP
References DELAY_LONG, hwprofile::dpi, usbdevice::hw, hwtonative(), hwprofile::id, hwprofile::light, loaddpi(), loadrgb_mouse(), MSG_SIZE, hwprofile::name, PR_NAME_LEN, usbdevice::profile, and usbrecv\&.
.PP
.nf
6                                                                                                {
7     DELAY_LONG(kb);
8     hwprofile* hw = calloc(1, sizeof(hwprofile));
9     // Ask for profile and mode IDs
10     uchar data_pkt[2][MSG_SIZE] = {
11         { 0x0e, 0x15, 0x01, 0 },
12         { 0x0e, 0x16, 0x01, 0 }
13     };
14     uchar in_pkt[MSG_SIZE];
15     for(int i = 0; i <= 1; i++){
16         data_pkt[0][3] = i;
17         if(!usbrecv(kb, data_pkt[0], in_pkt)){
18             free(hw);
19             return -1;
20         }
21         memcpy(hw->id + i, in_pkt + 4, sizeof(usbid));
22     }
23     // Ask for profile and mode names
24     for(int i = 0; i <= 1; i++){
25         data_pkt[1][3] = i;
26         if(!usbrecv(kb, data_pkt[1],in_pkt)){
27             free(hw);
28             return -1;
29         }
30         memcpy(hw->name[i], in_pkt + 4, PR_NAME_LEN * 2);
31     }
32 
33     // Load the RGB and DPI settings
34     if(loadrgb_mouse(kb, hw->light, 0)
35             || loaddpi(kb, hw->dpi, hw->light)){
36         free(hw);
37         return -1;
38     }
39 
40     // Make the profile active (if requested)
41     if(apply)
42         hwtonative(kb->profile, hw, 1);
43     // Free the existing profile (if any)
44     free(kb->hw);
45     kb->hw = hw;
46     DELAY_LONG(kb);
47     return 0;
48 }
.fi
.SS "int cmd_hwsave_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 50 of file profile_mouse\&.c\&.
.PP
References DELAY_LONG, hwprofile::dpi, usbdevice::hw, hwprofile::id, hwprofile::light, MD_NAME_LEN, MSG_SIZE, hwprofile::name, nativetohw(), usbdevice::profile, savedpi(), savergb_mouse(), and usbsend\&.
.PP
.nf
50                                                                                                 {
51     DELAY_LONG(kb);
52     hwprofile* hw = kb->hw;
53     if(!hw)
54         hw = kb->hw = calloc(1, sizeof(hwprofile));
55     nativetohw(kb->profile, hw, 1);
56     // Save the profile and mode names
57     uchar data_pkt[2][MSG_SIZE] = {
58         { 0x07, 0x16, 0x01, 0 },
59         { 0x07, 0x15, 0x01, 0 },
60     };
61     for(int i = 0; i <= 1; i++){
62         data_pkt[0][3] = i;
63         memcpy(data_pkt[0] + 4, hw->name[i], MD_NAME_LEN * 2);
64         if(!usbsend(kb, data_pkt[0], 1))
65             return -1;
66     }
67     // Save the IDs
68     for(int i = 0; i <= 1; i++){
69         data_pkt[1][3] = i;
70         memcpy(data_pkt[1] + 4, hw->id + i, sizeof(usbid));
71         if(!usbsend(kb, data_pkt[1], 1))
72             return -1;
73     }
74     // Save the RGB data for the non-DPI zones
75     if(savergb_mouse(kb, hw->light, 0))
76         return -1;
77     // Save the DPI data (also saves RGB for those states)
78     if(savedpi(kb, hw->dpi, hw->light))
79         return -1;
80     DELAY_LONG(kb);
81     return 0;
82 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
