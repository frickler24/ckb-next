.TH "KbManager" 3 "Sun Jun 18 2017" "Version beta-v0.2.8 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KbManager \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kbmanager\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBkbConnected\fP (\fBKb\fP *device)"
.br
.ti -1c
.RI "void \fBkbDisconnected\fP (\fBKb\fP *device)"
.br
.ti -1c
.RI "void \fBversionUpdated\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBinit\fP (QString guiVersion)"
.br
.ti -1c
.RI "static void \fBstop\fP ()"
.br
.ti -1c
.RI "static \fBKbManager\fP * \fBkbManager\fP ()"
.br
.ti -1c
.RI "static QString \fBckbGuiVersion\fP ()"
.br
.ti -1c
.RI "static QString \fBckbDaemonVersion\fP ()"
.br
.ti -1c
.RI "static float \fBparseVersionString\fP (QString version)"
.br
.ti -1c
.RI "static float \fBckbGuiVersionF\fP ()"
.br
.ti -1c
.RI "static float \fBckbDaemonVersionF\fP ()"
.br
.ti -1c
.RI "static const QSet< \fBKb\fP * > \fBdevices\fP ()"
.br
.ti -1c
.RI "static QTimer * \fBeventTimer\fP ()"
.br
.ti -1c
.RI "static void \fBfps\fP (int framerate)"
.br
.ti -1c
.RI "static QTimer * \fBscanTimer\fP ()"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBscanKeyboards\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKbManager\fP (\fBQObject\fP *parent=0)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QSet< \fBKb\fP * > \fB_devices\fP"
.br
.ti -1c
.RI "QTimer * \fB_eventTimer\fP"
.br
.ti -1c
.RI "QTimer * \fB_scanTimer\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBKbManager\fP * \fB_kbManager\fP = 0"
.br
.ti -1c
.RI "static QString \fB_guiVersion\fP"
.br
.ti -1c
.RI "static QString \fB_daemonVersion\fP = '<unavailable>'"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 14 of file kbmanager\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KbManager::KbManager (\fBQObject\fP *parent = \fC0\fP)\fC [explicit]\fP, \fC [private]\fP"

.PP
Definition at line 26 of file kbmanager\&.cpp\&.
.PP
References _eventTimer, _scanTimer, and scanKeyboards()\&.
.PP
Referenced by init()\&.
.PP
.nf
26                                     : QObject(parent){
27     // Set up the timers
28     _eventTimer = new QTimer(this);
29     _eventTimer->setTimerType(Qt::PreciseTimer);
30     _scanTimer = new QTimer(this);
31     _scanTimer->start(100);
32     connect(_scanTimer, SIGNAL(timeout()), this, SLOT(scanKeyboards()));
33 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "static QString KbManager::ckbDaemonVersion ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 27 of file kbmanager\&.h\&.
.PP
References _daemonVersion\&.
.PP
Referenced by MainWindow::updateVersion()\&.
.PP
.nf
27 { return _daemonVersion; }
.fi
.SS "static float KbManager::ckbDaemonVersionF ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 31 of file kbmanager\&.h\&.
.PP
References _daemonVersion, DAEMON_UNAVAILABLE_STR, and parseVersionString()\&.
.PP
Referenced by KbFirmware::_latestForBoard(), and MainWindow::updateVersion()\&.
.PP
.nf
31 { return _daemonVersion == DAEMON_UNAVAILABLE_STR ? INFINITY : parseVersionString(_daemonVersion); }
.fi
.SS "static QString KbManager::ckbGuiVersion ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 26 of file kbmanager\&.h\&.
.PP
References _guiVersion\&.
.PP
.nf
26 { return _guiVersion; }
.fi
.SS "static float KbManager::ckbGuiVersionF ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 30 of file kbmanager\&.h\&.
.PP
References _guiVersion, and parseVersionString()\&.
.PP
Referenced by KbFirmware::_latestForBoard(), and MainWindow::updateVersion()\&.
.PP
.nf
30 { return parseVersionString(_guiVersion); }
.fi
.SS "static const QSet<\fBKb\fP*> KbManager::devices ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 34 of file kbmanager\&.h\&.
.PP
References _devices, and _kbManager\&.
.PP
.nf
34 { return _kbManager ? _kbManager->_devices : QSet<Kb*>(); }
.fi
.SS "static QTimer* KbManager::eventTimer ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 38 of file kbmanager\&.h\&.
.PP
References _eventTimer, and _kbManager\&.
.PP
Referenced by fps()\&.
.PP
.nf
38 { return _kbManager ? _kbManager->_eventTimer : 0; }
.fi
.SS "void KbManager::fps (intframerate)\fC [static]\fP"

.PP
Definition at line 35 of file kbmanager\&.cpp\&.
.PP
References eventTimer()\&.
.PP
Referenced by Kb::frameRate()\&.
.PP
.nf
35                                 {
36     QTimer* timer = eventTimer();
37     if(!timer)
38         return;
39     if(timer->isActive())
40         timer->setInterval(1000 / framerate);
41     else
42         timer->start(1000 / framerate);
43 }
.fi
.SS "void KbManager::init (QStringguiVersion)\fC [static]\fP"

.PP
Definition at line 12 of file kbmanager\&.cpp\&.
.PP
References _guiVersion, _kbManager, and KbManager()\&.
.PP
Referenced by MainWindow::MainWindow()\&.
.PP
.nf
12                                       {
13     _guiVersion = guiVersion;
14     if(_kbManager)
15         return;
16     _kbManager = new KbManager();
17 }
.fi
.SS "void KbManager::kbConnected (\fBKb\fP *device)\fC [signal]\fP"

.PP
Definition at line 174 of file moc_kbmanager\&.cpp\&.
.PP
Referenced by scanKeyboards()\&.
.PP
.nf
175 {
176     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
177     QMetaObject::activate(this, &staticMetaObject, 0, _a);
178 }
.fi
.SS "void KbManager::kbDisconnected (\fBKb\fP *device)\fC [signal]\fP"

.PP
Definition at line 181 of file moc_kbmanager\&.cpp\&.
.PP
Referenced by scanKeyboards()\&.
.PP
.nf
182 {
183     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
184     QMetaObject::activate(this, &staticMetaObject, 1, _a);
185 }
.fi
.SS "static \fBKbManager\fP* KbManager::kbManager ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 23 of file kbmanager\&.h\&.
.PP
References _kbManager\&.
.PP
Referenced by MainWindow::MainWindow()\&.
.PP
.nf
23 { return _kbManager; }
.fi
.SS "float KbManager::parseVersionString (QStringversion)\fC [static]\fP"

.PP
Definition at line 45 of file kbmanager\&.cpp\&.
.PP
Referenced by ckbDaemonVersionF(), ckbGuiVersionF(), and KbFirmware::processDownload()\&.
.PP
.nf
45                                                   {
46     // Remove extraneous info (anything after a +, anything non-numeric)
47     QStringList dots = version\&.replace(QRegExp("\\+\&.+"), "")\&.replace(QRegExp("[^\\d\\\&.]"), "")\&.split("\&.");
48     float base = 1\&.f;
49     float res = 0\&.f;
50     // A number like "1\&.2\&.3" will result in 1\&.0203
51     // NB: will fail if a point version goes over 99 or if using more than two dots\&. floats can only reliably encode 7 decimal digits\&.
52     foreach(const QString& dot, dots){
53         res += dot\&.toFloat() * base;
54         base /= 100\&.f;
55     }
56     return res;
57 }
.fi
.SS "void KbManager::scanKeyboards ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 59 of file kbmanager\&.cpp\&.
.PP
References _daemonVersion, _devices, _eventTimer, _scanTimer, DAEMON_UNAVAILABLE_STR, devpath, Kb::isOpen(), kbConnected(), kbDisconnected(), Kb::load(), Kb::matches(), Kb::save(), and versionUpdated()\&.
.PP
Referenced by KbManager()\&.
.PP
.nf
59                              {
60     QString rootdev = devpath\&.arg(0);
61     QFile connected(rootdev + "/connected");
62     if(!connected\&.open(QIODevice::ReadOnly)){
63         // No root controller - remove all keyboards
64         foreach(Kb* kb, _devices){
65             emit kbDisconnected(kb);
66             kb->save();
67             delete kb;
68         }
69         _devices\&.clear();
70         if(_daemonVersion != DAEMON_UNAVAILABLE_STR){
71             _daemonVersion = DAEMON_UNAVAILABLE_STR;
72             emit versionUpdated();
73         }
74         return;
75     }
76     // Check daemon version
77     QFile version(rootdev + "/version");
78     QString vString;
79     if(version\&.open(QIODevice::ReadOnly)){
80         vString = QString::fromUtf8(version\&.readLine())\&.trimmed();
81         version\&.close();
82     } else
83         vString = DAEMON_UNAVAILABLE_STR;
84     if(_daemonVersion != vString){
85         _daemonVersion = vString;
86         emit versionUpdated();
87     }
88 
89     // Scan connected devices
90     QList<QStringList> lines;
91     while(1){
92         QString line = connected\&.readLine()\&.trimmed();
93         if(line\&.isEmpty())
94             break;
95         QStringList components = line\&.split(" ");
96         if(components\&.length() < 2)             // "<path> <serial> <name>" (we're only interested in the first two)
97             continue;
98         lines\&.append(components);
99     }
100     connected\&.close();
101 
102     // Remove any active devices not in the list
103     QMutableSetIterator<Kb*> i(_devices);
104     while(i\&.hasNext()){
105         Kb* kb = i\&.next();
106         bool matched = false;
107         foreach(const QStringList& line, lines){
108             if(kb->matches(line[0], line[1])){
109                 matched = true;
110                 break;
111             }
112         }
113         if(matched)
114             continue;
115         // Device not found, remove
116         i\&.remove();
117         emit kbDisconnected(kb);
118         kb->save();
119         delete kb;
120     }
121 
122     // Add any new devices found in the list
123     foreach(const QStringList& line, lines){
124         bool matched = false;
125         foreach(Kb* kb, _devices){
126             if(kb->matches(line[0], line[1])){
127                 matched = true;
128                 break;
129             }
130         }
131         if(matched)
132             continue;
133         // Device not found, create new
134         Kb* kb = new Kb(this, line[0]);
135         if(!kb->isOpen()){
136             delete kb;
137             continue;
138         }
139         _devices\&.insert(kb);
140         // Load preferences and send signal
141         emit kbConnected(kb);
142         kb->load();
143         connect(_eventTimer, SIGNAL(timeout()), kb, SLOT(frameUpdate()));
144         connect(_scanTimer, SIGNAL(timeout()), kb, SLOT(autoSave()));
145     }
146 }
.fi
.SS "static QTimer* KbManager::scanTimer ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 43 of file kbmanager\&.h\&.
.PP
References _kbManager, and _scanTimer\&.
.PP
Referenced by MainWindow::MainWindow()\&.
.PP
.nf
43 { return _kbManager ? _kbManager->_scanTimer : 0; }
.fi
.SS "void KbManager::stop ()\fC [static]\fP"

.PP
Definition at line 19 of file kbmanager\&.cpp\&.
.PP
References _kbManager\&.
.PP
Referenced by MainWindow::cleanup()\&.
.PP
.nf
19                     {
20     if(!_kbManager)
21         return;
22     delete _kbManager;
23     _kbManager = 0;
24 }
.fi
.SS "void KbManager::versionUpdated ()\fC [signal]\fP"

.PP
Definition at line 188 of file moc_kbmanager\&.cpp\&.
.PP
Referenced by scanKeyboards()\&.
.PP
.nf
189 {
190     QMetaObject::activate(this, &staticMetaObject, 2, Q_NULLPTR);
191 }
.fi
.SH "Field Documentation"
.PP 
.SS "QString KbManager::_daemonVersion = '<unavailable>'\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 59 of file kbmanager\&.h\&.
.PP
Referenced by ckbDaemonVersion(), ckbDaemonVersionF(), and scanKeyboards()\&.
.SS "QSet<\fBKb\fP*> KbManager::_devices\fC [private]\fP"

.PP
Definition at line 63 of file kbmanager\&.h\&.
.PP
Referenced by devices(), and scanKeyboards()\&.
.SS "QTimer* KbManager::_eventTimer\fC [private]\fP"

.PP
Definition at line 64 of file kbmanager\&.h\&.
.PP
Referenced by eventTimer(), KbManager(), and scanKeyboards()\&.
.SS "QString KbManager::_guiVersion\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 59 of file kbmanager\&.h\&.
.PP
Referenced by ckbGuiVersion(), ckbGuiVersionF(), and init()\&.
.SS "\fBKbManager\fP * KbManager::_kbManager = 0\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 58 of file kbmanager\&.h\&.
.PP
Referenced by devices(), eventTimer(), init(), kbManager(), scanTimer(), and stop()\&.
.SS "QTimer * KbManager::_scanTimer\fC [private]\fP"

.PP
Definition at line 64 of file kbmanager\&.h\&.
.PP
Referenced by KbManager(), scanKeyboards(), and scanTimer()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
