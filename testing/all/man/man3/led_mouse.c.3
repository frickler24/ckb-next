.TH "src/ckb-daemon/led_mouse.c" 3 "Sat Feb 3 2018" "Version beta-v0.2.8 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/led_mouse.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'led\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static int \fBrgbcmp\fP (const \fBlighting\fP *lhs, const \fBlighting\fP *rhs)"
.br
.ti -1c
.RI "static int \fBisblack\fP (const \fBusbdevice\fP *kb, const \fBlighting\fP *light)"
.br
.ti -1c
.RI "int \fBupdatergb_mouse\fP (\fBusbdevice\fP *kb, int force)"
.br
.ti -1c
.RI "int \fBsavergb_mouse\fP (\fBusbdevice\fP *kb, \fBlighting\fP *light, int mode)"
.br
.ti -1c
.RI "int \fBloadrgb_mouse\fP (\fBusbdevice\fP *kb, \fBlighting\fP *light, int mode)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static int isblack (const \fBusbdevice\fP *kb, const \fBlighting\fP *light)\fC [static]\fP"

.PP
Definition at line 13 of file led_mouse\&.c\&.
.PP
References lighting::b, lighting::g, IS_M65, LED_MOUSE, N_MOUSE_ZONES, and lighting::r\&.
.PP
Referenced by updatergb_mouse()\&.
.PP
.nf
13                                                               {
14     if(!IS_M65(kb))
15         return 0;
16     uchar black[N_MOUSE_ZONES] = { 0 };
17     return !memcmp(light->r + LED_MOUSE, black, sizeof(black)) && !memcmp(light->g + LED_MOUSE, black, sizeof(black)) && !memcmp(light->b + LED_MOUSE, black, sizeof(black));
18 }
.fi
.SS "int loadrgb_mouse (\fBusbdevice\fP *kb, \fBlighting\fP *light, intmode)"

.PP
Definition at line 81 of file led_mouse\&.c\&.
.PP
References lighting::b, ckb_err, lighting::g, IS_SABRE, IS_SCIMITAR, LED_DPI, LED_MOUSE, MSG_SIZE, lighting::r, and usbrecv\&.
.PP
Referenced by cmd_hwload_mouse()\&.
.PP
.nf
81                                                            {
82     uchar data_pkt[MSG_SIZE] = { 0x0e, 0x13, 0x10, 1, 0 };
83     uchar in_pkt[MSG_SIZE] = { 0 };
84     // Load each RGB zone
85     int zonecount = IS_SCIMITAR(kb) ? 4 : IS_SABRE(kb) ? 3 : 2;
86     for(int i = 0; i < zonecount; i++){
87         if(!usbrecv(kb, data_pkt, in_pkt))
88             return -1;
89         if(memcmp(in_pkt, data_pkt, 4)){
90             ckb_err("Bad input header\n");
91             return -2;
92         }
93         // Copy data
94         int led = LED_MOUSE + i;
95         if(led >= LED_DPI)
96             led++;          // Skip DPI light
97         light->r[led] = in_pkt[4];
98         light->g[led] = in_pkt[5];
99         light->b[led] = in_pkt[6];
100         // Set packet for next zone
101         data_pkt[2]++;
102     }
103     return 0;
104 }
.fi
.SS "static int rgbcmp (const \fBlighting\fP *lhs, const \fBlighting\fP *rhs)\fC [static]\fP"

.PP
Definition at line 7 of file led_mouse\&.c\&.
.PP
References lighting::b, lighting::g, LED_MOUSE, N_MOUSE_ZONES, and lighting::r\&.
.PP
Referenced by updatergb_mouse()\&.
.PP
.nf
7                                                            {
8     return memcmp(lhs->r + LED_MOUSE, rhs->r + LED_MOUSE, N_MOUSE_ZONES) || memcmp(lhs->g + LED_MOUSE, rhs->g + LED_MOUSE, N_MOUSE_ZONES) || memcmp(lhs->b + LED_MOUSE, rhs->b + LED_MOUSE, N_MOUSE_ZONES);
9 }
.fi
.SS "int savergb_mouse (\fBusbdevice\fP *kb, \fBlighting\fP *light, intmode)"

.PP
Definition at line 62 of file led_mouse\&.c\&.
.PP
References lighting::b, lighting::g, IS_SABRE, IS_SCIMITAR, LED_DPI, LED_MOUSE, MSG_SIZE, lighting::r, and usbsend\&.
.PP
Referenced by cmd_hwsave_mouse()\&.
.PP
.nf
62                                                            {
63     uchar data_pkt[MSG_SIZE] = { 0x07, 0x13, 0x10, 1, 0 };
64     // Save each RGB zone, minus the DPI light which is sent in the DPI packets
65     int zonecount = IS_SCIMITAR(kb) ? 4 : IS_SABRE(kb) ? 3 : 2;
66     for(int i = 0; i < zonecount; i++){
67         int led = LED_MOUSE + i;
68         if(led >= LED_DPI)
69             led++;          // Skip DPI light
70         data_pkt[4] = light->r[led];
71         data_pkt[5] = light->g[led];
72         data_pkt[6] = light->b[led];
73         if(!usbsend(kb, data_pkt, 1))
74             return -1;
75         // Set packet for next zone
76         data_pkt[2]++;
77     }
78     return 0;
79 }
.fi
.SS "int updatergb_mouse (\fBusbdevice\fP *kb, intforce)"

.PP
Definition at line 20 of file led_mouse\&.c\&.
.PP
References usbdevice::active, lighting::b, usbprofile::currentmode, lighting::forceupdate, lighting::g, isblack(), usbprofile::lastlight, LED_MOUSE, usbmode::light, MSG_SIZE, N_MOUSE_ZONES, usbdevice::profile, lighting::r, rgbcmp(), and usbsend\&.
.PP
.nf
20                                              {
21     if(!kb->active)
22         return 0;
23     lighting* lastlight = &kb->profile->lastlight;
24     lighting* newlight = &kb->profile->currentmode->light;
25     // Don't do anything if the lighting hasn't changed
26     if(!force && !lastlight->forceupdate && !newlight->forceupdate
27             && !rgbcmp(lastlight, newlight))
28         return 0;
29     lastlight->forceupdate = newlight->forceupdate = 0;
30 
31     // Send the RGB values for each zone to the mouse
32     uchar data_pkt[2][MSG_SIZE] = {
33         { 0x07, 0x22, N_MOUSE_ZONES, 0x01, 0 }, // RGB colors
34         { 0x07, 0x05, 0x02, 0 }                 // Lighting on/off
35     };
36     uchar* rgb_data = &data_pkt[0][4];
37     for(int i = 0; i < N_MOUSE_ZONES; i++){
38         *rgb_data++ = i + 1;
39         *rgb_data++ = newlight->r[LED_MOUSE + i];
40         *rgb_data++ = newlight->g[LED_MOUSE + i];
41         *rgb_data++ = newlight->b[LED_MOUSE + i];
42     }
43     // Send RGB data
44     if(!usbsend(kb, data_pkt[0], 1))
45         return -1;
46     int was_black = isblack(kb, lastlight), is_black = isblack(kb, newlight);
47     if(is_black){
48         // If the lighting is black, send the deactivation packet (M65 only)
49         if(!usbsend(kb, data_pkt[1], 1))
50             return -1;
51     } else if(was_black || force){
52         // If the lighting WAS black, or if we're on forced update, send the activation packet
53         data_pkt[1][4] = 1;
54         if(!usbsend(kb, data_pkt[1], 1))
55             return -1;
56     }
57 
58     memcpy(lastlight, newlight, sizeof(lighting));
59     return 0;
60 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
