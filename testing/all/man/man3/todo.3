.TH "todo" 3 "Sun Jun 18 2017" "Version beta-v0.2.8 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
todo \- Todo List 

.IP "\fBGlobal \fB_usbsend\fP (usbdevice *kb, const uchar *messages, int count, const char *file, int line)\fP" 1c
A lot of different conditions are combined in this code\&. Don't think, it is good in every combination\&.\&.\&.
.PP
Check whether this is the same in the macOS variant\&. It is not dramatic, but if errors occur, it can certainly irritate the devices completely if they receive incomplete data streams\&. Do we have errors with the messages 'Wrote YY bytes (expected 64)' in the system logs? If not, we do not need to look any further\&. 
.IP "\fBGlobal \fBcloseusb\fP (usbdevice *kb)\fP" 1c
What is not yet comprehensible is the call to \fBupdateconnected()\fP BEFORE \fBos_closeusb()\fP\&. Should that be in the other sequence? Or is \fBupdateconnected()\fP not displaying the connected usb devices, but the representation which uinput devices are loaded? Questions about questions \&.\&.\&. 
.IP "\fBGlobal \fBdevmain\fP (usbdevice *kb)\fP" 1c
Hope to find the need for dmutex usage later\&. 
.br
 Should this function be declared as pthread_t* function, because of the defintion of pthread-create? But void* works also\&.\&.\&. 
.PP
\fBreadcmd()\fP gets a \fBline\fP, not \fBlines\fP\&. Have a look on that later\&. 
.br
 Is the condition IS_CONNECTED valid? What functions change the condititon for the macro?  
.IP "\fBGlobal \fBget_vtable\fP (short vendor, short product)\fP" 1c
Is the last point really a good decision and always correct?  
.IP "\fBGlobal \fBinputupdate_keys\fP (usbdevice *kb)\fP" 1c
If we want to get all keys typed while a macro is played, add the code for it here\&.  
.IP "\fBGlobal \fBKb::Kb\fP (\fBQObject\fP *parent, const QString &path)\fP" 1c
Is adding notify2 to the notifypaths neccessary?  
.IP "\fBGlobal \fBKb::~Kb\fP ()\fP" 1c
I don't think, that notifypaths is used somewhere\&. So why do we have it? If we do not need it, searching for an ununsed notify channel can easy be refactored to a private member function\&.  
.IP "\fBGlobal \fBmacro_pt_enqueue\fP ()\fP" 1c
find a better exit strategy if no more mem available\&.  
.IP "\fBGlobal \fBos_inputmain\fP (void *context)\fP" 1c
This function is a collection of many tasks\&. It should be divided into several sub-functions for the sake of greater convenience: 
.IP "\fBGlobal \fBos_resetusb\fP (usbdevice *kb, const char *file, int line)\fP" 1c
it seems that no one wants to try the reset again\&. But I'v seen it somewhere\&.\&.\&.  
.IP "\fBGlobal \fBos_setupusb\fP (usbdevice *kb)\fP" 1c
in these modules a pullrequest is outstanding  
.IP "\fBGlobal \fBos_usbsend\fP (usbdevice *kb, const uchar *out_msg, int is_recv, const char *file, int line)\fP" 1c
Since the handling of endpoints has already led to problems elsewhere, this implementation is extremely hardware-dependent and critical! 
.br
 Eg\&. the new keyboard K95PLATINUMRGB has a version number significantly less than 2\&.0 - will it run with this implementation? 
.IP "\fBGlobal \fBproduct_str\fP (short product)\fP" 1c
There are macros defined in \fBusb\&.h\fP to detect all the combinations below\&. the only difference is the parameter: The macros need the \fIkb*\fP, \fBproduct_str()\fP needs the \fIproduct\fP \fIID\fP  
.IP "\fBGlobal \fBRebindWidget::applyChanges\fP (const QStringList &keys, bool doUnbind)\fP" 1c
There is still a bug in the state machine: If you record a macro in asTyped-mode, switch to another mode and change the vontent of the pteMacroBox manually, then the changes are not saved in the timing buffer\&. But anyhow, let's do more relevant things\&.\&.\&.  
.IP "\fBGlobal \fBRebindWidget::on_btnClearMacro_clicked\fP ()\fP" 1c
I do not know what is the better solution with the delay-buttons in case of clicking clear: Reset the button to the default value or do not touch it? Not clear is ignored\&.  
.IP "\fBGlobal \fBrevertusb\fP (usbdevice *kb)\fP" 1c
Why is this useful? Are there problems seen with deactivating a device with older fw-version??? Why isn't this an error indicating reason and we return success (0)?
.PP
The return value of \fBnk95cmd()\fP is ignored (but sending the ioctl may produce an error and _nk95_cmd will indicate this), instead \fBrevertusb()\fP returns success in any case\&. 
.IP "\fBGlobal \fBudevthread\fP \fP" 1c
These two thread vasriables seem to be unused: usbtread, udevthread  
.IP "\fBGlobal \fBudevthread\fP \fP" 1c
These two thread vasriables seem to be unused: usbtread, udevthread  
.IP "\fBGlobal \fBusb_add_device\fP (struct udev_device *dev)\fP" 1c
So why the hell not a transformation between the string and the short presentation? Lets check if the string representation is used elsewhere\&.  
.IP "\fBGlobal \fBusb_tryreset\fP (usbdevice *kb)\fP" 1c
Why does \fBusb_tryreset()\fP hide the information returned from \fBresetusb()\fP? Isn't it needed by the callers?  
.IP "\fBGlobal \fBusbmain\fP ()\fP" 1c
Why isn't missing of uinput a fatal error? 
.PP
lae\&. here the work has to go on\&.\&.\&.  
.IP "\fBGlobal \fBusbmutex\fP \fP" 1c
We should have a look why this mutex is never used\&. 
.PP

