.TH "src/ckb-daemon/input.c" 3 "Tue May 16 2017" "Version beta-v0.2.7 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/input.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBIS_WHEEL\fP(scan, kb)   (((scan) == KEY_VOLUMEUP || (scan) == KEY_VOLUMEDOWN || (scan) == \fBBTN_WHEELUP\fP || (scan) == \fBBTN_WHEELDOWN\fP) && !\fBIS_K65\fP(kb))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBmacromask\fP (const \fBuchar\fP *key1, const \fBuchar\fP *key2)"
.br
.ti -1c
.RI "static void \fBinputupdate_keys\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBinputupdate\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBupdateindicators_kb\fP (\fBusbdevice\fP *kb, int force)"
.br
.ti -1c
.RI "void \fBinitbind\fP (\fBbinding\fP *bind)"
.br
.ti -1c
.RI "void \fBfreebind\fP (\fBbinding\fP *bind)"
.br
.ti -1c
.RI "void \fBcmd_bind\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, int keyindex, const char *to)"
.br
.ti -1c
.RI "void \fBcmd_unbind\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, int keyindex, const char *to)"
.br
.ti -1c
.RI "void \fBcmd_rebind\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, int keyindex, const char *to)"
.br
.ti -1c
.RI "static void \fB_cmd_macro\fP (\fBusbmode\fP *mode, const char *keys, const char *assignment)"
.br
.ti -1c
.RI "void \fBcmd_macro\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, const int notifynumber, const char *keys, const char *assignment)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define IS_WHEEL(scan, kb)   (((scan) == KEY_VOLUMEUP || (scan) == KEY_VOLUMEDOWN || (scan) == \fBBTN_WHEELUP\fP || (scan) == \fBBTN_WHEELDOWN\fP) && !\fBIS_K65\fP(kb))"

.PP
Referenced by inputupdate_keys()\&.
.SH "Function Documentation"
.PP 
.SS "static void _cmd_macro (\fBusbmode\fP *mode, const char *keys, const char *assignment)\fC [static]\fP"

.PP
Definition at line 226 of file input\&.c\&.
.PP
References keymacro::actioncount, keymacro::actions, usbmode::bind, keymacro::combo, macroaction::down, keymap, left, MACRO_MAX, binding::macrocap, binding::macrocount, binding::macros, N_KEYBYTES_INPUT, N_KEYS_INPUT, right(), macroaction::scan, key::scan, and SET_KEYBIT\&.
.PP
Referenced by cmd_macro()\&.
.PP
.nf
226                                                                                {
227     binding* bind = &mode->bind;
228     if(!keys && !assignment){
229         // Null strings = "macro clear" -> erase the whole thing
230         for(int i = 0; i < bind->macrocount; i++)
231             free(bind->macros[i]\&.actions);
232         bind->macrocount = 0;
233         return;
234     }
235     if(bind->macrocount >= MACRO_MAX)
236         return;
237     // Create a key macro
238     keymacro macro;
239     memset(&macro, 0, sizeof(macro));
240     // Scan the left side for key names, separated by +
241     int empty = 1;
242     int left = strlen(keys), right = strlen(assignment);
243     int position = 0, field = 0;
244     char keyname[12];
245     while(position < left && sscanf(keys + position, "%10[^+]%n", keyname, &field) == 1){
246         int keycode;
247         if((sscanf(keyname, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)
248                   || (sscanf(keyname, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)){
249             // Set a key numerically
250             SET_KEYBIT(macro\&.combo, keycode);
251             empty = 0;
252         } else {
253             // Find this key in the keymap
254             for(unsigned i = 0; i < N_KEYS_INPUT; i++){
255                 if(keymap[i]\&.name && !strcmp(keyname, keymap[i]\&.name)){
256                     macro\&.combo[i / 8] |= 1 << (i % 8);
257                     empty = 0;
258                     break;
259                 }
260             }
261         }
262         if(keys[position += field] == '+')
263             position++;
264     }
265     if(empty)
266         return;
267     // Count the number of actions (comma separated)
268     int count = 1;
269     for(const char* c = assignment; *c != 0; c++){
270         if(*c == ',')
271             count++;
272     }
273     // Allocate a buffer for them
274     macro\&.actions = calloc(count, sizeof(macroaction));
275     macro\&.actioncount = 0;
276     // Scan the actions
277     position = 0;
278     field = 0;
279     while(position < right && sscanf(assignment + position, "%11[^,]%n", keyname, &field) == 1){
280         if(!strcmp(keyname, "clear"))
281             break;
282         int down = (keyname[0] == '+');
283         if(down || keyname[0] == '-'){
284             int keycode;
285             if((sscanf(keyname + 1, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)
286                       || (sscanf(keyname + 1, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)){
287                 // Set a key numerically
288                 macro\&.actions[macro\&.actioncount]\&.scan = keymap[keycode]\&.scan;
289                 macro\&.actions[macro\&.actioncount]\&.down = down;
290                 macro\&.actioncount++;
291             } else {
292                 // Find this key in the keymap
293                 for(unsigned i = 0; i < N_KEYS_INPUT; i++){
294                     if(keymap[i]\&.name && !strcmp(keyname + 1, keymap[i]\&.name)){
295                         macro\&.actions[macro\&.actioncount]\&.scan = keymap[i]\&.scan;
296                         macro\&.actions[macro\&.actioncount]\&.down = down;
297                         macro\&.actioncount++;
298                         break;
299                     }
300                 }
301             }
302         }
303         if(assignment[position += field] == ',')
304             position++;
305     }
306 
307     // See if there's already a macro with this trigger
308     keymacro* macros = bind->macros;
309     for(int i = 0; i < bind->macrocount; i++){
310         if(!memcmp(macros[i]\&.combo, macro\&.combo, N_KEYBYTES_INPUT)){
311             free(macros[i]\&.actions);
312             // If the new macro has no actions, erase the existing one
313             if(!macro\&.actioncount){
314                 for(int j = i + 1; j < bind->macrocount; j++)
315                     memcpy(macros + j - 1, macros + j, sizeof(keymacro));
316                 bind->macrocount--;
317             } else
318                 // If there are actions, replace the existing with the new
319                 memcpy(macros + i, &macro, sizeof(keymacro));
320             return;
321         }
322     }
323 
324     // Add the macro to the device settings if not empty
325     if(macro\&.actioncount < 1)
326         return;
327     memcpy(bind->macros + (bind->macrocount++), &macro, sizeof(keymacro));
328     if(bind->macrocount >= bind->macrocap)
329         bind->macros = realloc(bind->macros, (bind->macrocap += 16) * sizeof(keymacro));
330 }
.fi
.SS "void cmd_bind (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, intkeyindex, const char *to)"

.PP
Definition at line 188 of file input\&.c\&.
.PP
References binding::base, usbmode::bind, imutex, keymap, N_KEYS_INPUT, and key::scan\&.
.PP
.nf
188                                                                                     {
189     if(keyindex >= N_KEYS_INPUT)
190         return;
191     // Find the key to bind to
192     int tocode = 0;
193     if(sscanf(to, "#x%ux", &tocode) != 1 && sscanf(to, "#%u", &tocode) == 1 && tocode < N_KEYS_INPUT){
194         pthread_mutex_lock(imutex(kb));
195         mode->bind\&.base[keyindex] = tocode;
196         pthread_mutex_unlock(imutex(kb));
197         return;
198     }
199     // If not numeric, look it up
200     for(int i = 0; i < N_KEYS_INPUT; i++){
201         if(keymap[i]\&.name && !strcmp(to, keymap[i]\&.name)){
202             pthread_mutex_lock(imutex(kb));
203             mode->bind\&.base[keyindex] = keymap[i]\&.scan;
204             pthread_mutex_unlock(imutex(kb));
205             return;
206         }
207     }
208 }
.fi
.SS "void cmd_macro (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, const intnotifynumber, const char *keys, const char *assignment)"

.PP
Definition at line 332 of file input\&.c\&.
.PP
References _cmd_macro(), and imutex\&.
.PP
.nf
332                                                                                                               {
333     pthread_mutex_lock(imutex(kb));
334     _cmd_macro(mode, keys, assignment);
335     pthread_mutex_unlock(imutex(kb));
336 }
.fi
.SS "void cmd_rebind (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, intkeyindex, const char *to)"

.PP
Definition at line 218 of file input\&.c\&.
.PP
References binding::base, usbmode::bind, imutex, keymap, N_KEYS_INPUT, and key::scan\&.
.PP
.nf
218                                                                                       {
219     if(keyindex >= N_KEYS_INPUT)
220         return;
221     pthread_mutex_lock(imutex(kb));
222     mode->bind\&.base[keyindex] = keymap[keyindex]\&.scan;
223     pthread_mutex_unlock(imutex(kb));
224 }
.fi
.SS "void cmd_unbind (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, intkeyindex, const char *to)"

.PP
Definition at line 210 of file input\&.c\&.
.PP
References binding::base, usbmode::bind, imutex, KEY_UNBOUND, and N_KEYS_INPUT\&.
.PP
.nf
210                                                                                       {
211     if(keyindex >= N_KEYS_INPUT)
212         return;
213     pthread_mutex_lock(imutex(kb));
214     mode->bind\&.base[keyindex] = KEY_UNBOUND;
215     pthread_mutex_unlock(imutex(kb));
216 }
.fi
.SS "void freebind (\fBbinding\fP *bind)"

.PP
Definition at line 181 of file input\&.c\&.
.PP
References keymacro::actions, binding::macrocount, and binding::macros\&.
.PP
Referenced by freemode()\&.
.PP
.nf
181                             {
182     for(int i = 0; i < bind->macrocount; i++)
183         free(bind->macros[i]\&.actions);
184     free(bind->macros);
185     memset(bind, 0, sizeof(*bind));
186 }
.fi
.SS "void initbind (\fBbinding\fP *bind)"

.PP
Definition at line 173 of file input\&.c\&.
.PP
References binding::base, keymap, binding::macrocap, binding::macrocount, binding::macros, N_KEYS_INPUT, and key::scan\&.
.PP
Referenced by initmode()\&.
.PP
.nf
173                             {
174     for(int i = 0; i < N_KEYS_INPUT; i++)
175         bind->base[i] = keymap[i]\&.scan;
176     bind->macros = calloc(32, sizeof(keymacro));
177     bind->macrocap = 32;
178     bind->macrocount = 0;
179 }
.fi
.SS "void inputupdate (\fBusbdevice\fP *kb)"

.PP
Definition at line 122 of file input\&.c\&.
.PP
References usbdevice::input, inputupdate_keys(), os_mousemove(), usbdevice::profile, usbinput::rel_x, usbinput::rel_y, usbdevice::uinput_kb, and usbdevice::uinput_mouse\&.
.PP
Referenced by os_inputmain(), setactive_kb(), and setactive_mouse()\&.
.PP
.nf
122                                {
123 #ifdef OS_LINUX
124     if((!kb->uinput_kb || !kb->uinput_mouse)
125 #else
126     if(!kb->event
127 #endif
128             || !kb->profile)
129         return;
130     // Process key/button input
131     inputupdate_keys(kb);
132     // Process mouse movement
133     usbinput* input = &kb->input;
134     if(input->rel_x != 0 || input->rel_y != 0){
135         os_mousemove(kb, input->rel_x, input->rel_y);
136         input->rel_x = input->rel_y = 0;
137     }
138     // Finish up
139     memcpy(input->prevkeys, input->keys, N_KEYBYTES_INPUT);
140 }
.fi
.SS "static void inputupdate_keys (\fBusbdevice\fP *kb)\fC [static]\fP"

.PP
Definition at line 15 of file input\&.c\&.
.PP
References keymacro::actioncount, keymacro::actions, usbdevice::active, binding::base, usbmode::bind, keymacro::combo, usbprofile::currentmode, usbdevice::delay, macroaction::down, usbdevice::input, IS_MOD, IS_WHEEL, keymap, usbinput::keys, binding::macrocount, macromask(), binding::macros, N_KEYBYTES_INPUT, N_KEYS_INPUT, usbmode::notify, nprintkey(), os_keypress(), os_mousemove(), OUTFIFO_MAX, usbinput::prevkeys, usbdevice::profile, macroaction::rel_x, macroaction::rel_y, macroaction::scan, key::scan, SCAN_SILENT, and keymacro::triggered\&.
.PP
Referenced by inputupdate()\&.
.PP
.nf
15                                            {
16     usbmode* mode = kb->profile->currentmode;
17     binding* bind = &mode->bind;
18     usbinput* input = &kb->input;
19     // Don't do anything if the state hasn't changed
20     if(!memcmp(input->prevkeys, input->keys, N_KEYBYTES_INPUT))
21         return;
22     // Look for macros matching the current state
23     int macrotrigger = 0;
24     if(kb->active){
25         for(int i = 0; i < bind->macrocount; i++){
26             keymacro* macro = &bind->macros[i];
27             if(macromask(input->keys, macro->combo)){
28                 if(!macro->triggered){
29                     macrotrigger = 1;
30                     macro->triggered = 1;
31                     // Send events for each keypress in the macro
32                     for(int a = 0; a < macro->actioncount; a++){
33                         macroaction* action = macro->actions + a;
34                         if(action->rel_x != 0 || action->rel_y != 0)
35                             os_mousemove(kb, action->rel_x, action->rel_y);
36                         else {
37                             os_keypress(kb, action->scan, action->down);
38                             if (kb->delay) {
39                                 if (a > 200) usleep (100);
40                                 else if (a > 20) usleep(30);
41                             }
42                         }
43                     }
44                 }
45             } else {
46                 macro->triggered = 0;
47             }
48         }
49     }
50     // Make a list of keycodes to send\&. Rearrange them so that modifier keydowns always come first
51     // and modifier keyups always come last\&. This ensures that shortcut keys will register properly
52     // even if both keydown events happen at once\&.
53     // N_KEYS + 4 is used because the volume wheel generates keydowns and keyups at the same time
54     // (it's currently impossible to press all four at once, but safety first)
55     int events[N_KEYS_INPUT + 4];
56     int modcount = 0, keycount = 0, rmodcount = 0;
57     for(int byte = 0; byte < N_KEYBYTES_INPUT; byte++){
58         char oldb = input->prevkeys[byte], newb = input->keys[byte];
59         if(oldb == newb)
60             continue;
61         for(int bit = 0; bit < 8; bit++){
62             int keyindex = byte * 8 + bit;
63             if(keyindex >= N_KEYS_INPUT)
64                 break;
65             const key* map = keymap + keyindex;
66             int scancode = (kb->active) ? bind->base[keyindex] : map->scan;
67             char mask = 1 << bit;
68             char old = oldb & mask, new = newb & mask;
69             // If the key state changed, send it to the input device
70             if(old != new){
71                 // Don't echo a key press if a macro was triggered or if there's no scancode associated
72                 if(!macrotrigger && !(scancode & SCAN_SILENT)){
73                     if(IS_MOD(scancode)){
74                         if(new){
75                             // Modifier down: Add to the end of modifier keys
76                             for(int i = keycount + rmodcount; i > 0; i--)
77                                 events[modcount + i] = events[modcount + i - 1];
78                             // Add 1 to the scancode because A is zero on OSX
79                             // Positive code = keydown, negative code = keyup
80                             events[modcount++] = scancode + 1;
81                         } else {
82                             // Modifier up: Add to the end of everything
83                             events[modcount + keycount + rmodcount++] = -(scancode + 1);
84                         }
85                     } else {
86                         // Regular keypress: add to the end of regular keys
87                         for(int i = rmodcount; i > 0; i--)
88                             events[modcount + keycount + i] = events[modcount + keycount + i - 1];
89                         events[modcount + keycount++] = new ? (scancode + 1) : -(scancode + 1);
90                         // The volume wheel and the mouse wheel don't generate keyups, so create them automatically
91 #define IS_WHEEL(scan, kb)  (((scan) == KEY_VOLUMEUP || (scan) == KEY_VOLUMEDOWN || (scan) == BTN_WHEELUP || (scan) == BTN_WHEELDOWN) && !IS_K65(kb))
92                         if(new && IS_WHEEL(map->scan, kb)){
93                             for(int i = rmodcount; i > 0; i--)
94                                 events[modcount + keycount + i] = events[modcount + keycount + i - 1];
95                             events[modcount + keycount++] = -(scancode + 1);
96                             input->keys[byte] &= ~mask;
97                         }
98                     }
99                 }
100                 // Print notifications if desired
101                 if(kb->active){
102                     for(int notify = 0; notify < OUTFIFO_MAX; notify++){
103                         if(mode->notify[notify][byte] & mask){
104                             nprintkey(kb, notify, keyindex, new);
105                             // Wheels doesn't generate keyups
106                             if(new && IS_WHEEL(map->scan, kb))
107                                 nprintkey(kb, notify, keyindex, 0);
108                         }
109                     }
110                 }
111             }
112         }
113     }
114     // Process all queued keypresses
115     int totalkeys = modcount + keycount + rmodcount;
116     for(int i = 0; i < totalkeys; i++){
117         int scancode = events[i];
118         os_keypress(kb, (scancode < 0 ? -scancode : scancode) - 1, scancode > 0);
119     }
120 }
.fi
.SS "int macromask (const \fBuchar\fP *key1, const \fBuchar\fP *key2)"

.PP
Definition at line 5 of file input\&.c\&.
.PP
References N_KEYBYTES_INPUT\&.
.PP
Referenced by inputupdate_keys()\&.
.PP
.nf
5                                                    {
6     // Scan a macro against key input\&. Return 0 if any of them don't match
7     for(int i = 0; i < N_KEYBYTES_INPUT; i++){
8         // if((key1[i] & key2[i]) != key2[i])
9         if(key1[i] != key2[i])  // Changed to detect G-keys + modifiers
10             return 0;
11     }
12     return 1;
13 }
.fi
.SS "void updateindicators_kb (\fBusbdevice\fP *kb, intforce)"

.PP
Definition at line 142 of file input\&.c\&.
.PP
References usbdevice::active, usbprofile::currentmode, DELAY_SHORT, usbdevice::hw_ileds, usbdevice::hw_ileds_old, I_CAPS, I_NUM, I_SCROLL, usbdevice::ileds, usbmode::inotify, usbmode::ioff, usbmode::ion, nprintind(), os_sendindicators(), OUTFIFO_MAX, and usbdevice::profile\&.
.PP
.nf
142                                                   {
143     // Read current hardware indicator state (set externally)
144     uchar old = kb->ileds, hw_old = kb->hw_ileds_old;
145     uchar new = kb->hw_ileds, hw_new = new;
146     // Update them if needed
147     if(kb->active){
148         usbmode* mode = kb->profile->currentmode;
149         new = (new & ~mode->ioff) | mode->ion;
150     }
151     kb->ileds = new;
152     kb->hw_ileds_old = hw_new;
153     if(old != new || force){
154         DELAY_SHORT(kb);
155         os_sendindicators(kb);
156     }
157     // Print notifications if desired
158     if(!kb->active)
159         return;
160     usbmode* mode = kb->profile->currentmode;
161     uchar indicators[] = { I_NUM, I_CAPS, I_SCROLL };
162     for(unsigned i = 0; i < sizeof(indicators) / sizeof(uchar); i++){
163         uchar mask = indicators[i];
164         if((hw_old & mask) == (hw_new & mask))
165             continue;
166         for(int notify = 0; notify < OUTFIFO_MAX; notify++){
167             if(mode->inotify[notify] & mask)
168                 nprintind(kb, notify, mask, hw_new & mask);
169         }
170     }
171 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
