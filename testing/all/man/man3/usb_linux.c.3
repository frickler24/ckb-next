.TH "src/ckb-daemon/usb_linux.c" 3 "Sat Jun 17 2017" "Version beta-v0.2.8 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/usb_linux.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_model\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEBUG\fP"
.br
.RI "\fIall open usb devices have their system path names here in this array\&. \fP"
.ti -1c
.RI "#define \fBTEST_RESET\fP(op)"
.br
.RI "\fITEST_RESET doesa 'try / catch' for resetting the usb interface\&. \fP"
.ti -1c
.RI "#define \fBN_MODELS\fP   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBos_usbsend\fP (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, int is_recv, const char *file, int line)"
.br
.RI "\fIos_usbsend sends a data packet (MSG_SIZE = 64) Bytes long \fP"
.ti -1c
.RI "int \fBos_usbrecv\fP (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, int line)"
.br
.RI "\fIos_usbrecv receives a max MSGSIZE long buffer from usb device \fP"
.ti -1c
.RI "int \fB_nk95cmd\fP (\fBusbdevice\fP *kb, \fBuchar\fP bRequest, \fBushort\fP wValue, const char *file, int line)"
.br
.RI "\fI_nk95cmd If we control a non RGB keyboard, set the keyboard via ioctl with usbdevfs_ctrltransfer \fP"
.ti -1c
.RI "void \fBos_sendindicators\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void * \fBos_inputmain\fP (void *context)"
.br
.RI "\fIos_inputmain This function is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&. \fP"
.ti -1c
.RI "static int \fBusbunclaim\fP (\fBusbdevice\fP *kb, int resetting)"
.br
.ti -1c
.RI "void \fBos_closeusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "static int \fBusbclaim\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBos_resetusb\fP (\fBusbdevice\fP *kb, const char *file, int line)"
.br
.ti -1c
.RI "void \fBstrtrim\fP (char *string)"
.br
.ti -1c
.RI "int \fBos_setupusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBusbadd\fP (struct udev_device *dev, short vendor, short product)"
.br
.ti -1c
.RI "static int \fBusb_add_device\fP (struct udev_device *dev)"
.br
.RI "\fIAdd a udev device\&. Returns 0 if device was recognized/added\&. \fP"
.ti -1c
.RI "static void \fBusb_rm_device\fP (struct udev_device *dev)"
.br
.RI "\fIusb_rm_device find the usb port to remove and close it via \fBcloseusb()\fP\&. \fP"
.ti -1c
.RI "static void \fBudev_enum\fP ()"
.br
.RI "\fIudev_enum use the udev_enumerate_add_match_subsystem() to get all you need but only that\&. \fP"
.ti -1c
.RI "int \fBusbmain\fP ()"
.br
.ti -1c
.RI "void \fBusbkill\fP ()"
.br
.RI "\fIStop the USB system\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static char \fBkbsyspath\fP [9][FILENAME_MAX]"
.br
.ti -1c
.RI "static struct udev * \fBudev\fP"
.br
.RI "\fIstruct udef is defined in /usr/include/libudev\&.h \fP"
.ti -1c
.RI "pthread_t \fBusbthread\fP"
.br
.ti -1c
.RI "pthread_t \fBudevthread\fP"
.br
.ti -1c
.RI "static \fB_model\fP \fBmodels\fP []"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct _model"
.PP 
Definition at line 647 of file usb_linux\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
const char * \fIname\fP 
.br
.PP
short \fInumber\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define DEBUG"

.PP
Definition at line 11 of file usb_linux\&.c\&.
.SS "#define N_MODELS   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"

.PP
Definition at line 684 of file usb_linux\&.c\&.
.PP
Referenced by usb_add_device()\&.
.SS "#define TEST_RESET(op)"
\fBValue:\fP
.PP
.nf
if(op){                                                                 \\
        ckb_err_fn("resetusb failed: %s\n", file, line, strerror(errno));   \
        if(errno == EINTR || errno == EAGAIN)                               \
            return -1;              /* try again if status code says so */  \
        return -2;                  /* else, remove device */               \
    }
.fi
.PP
Definition at line 481 of file usb_linux\&.c\&.
.PP
Referenced by os_resetusb()\&.
.SH "Function Documentation"
.PP 
.SS "int _nk95cmd (\fBusbdevice\fP *kb, \fBuchar\fPbRequest, \fBushort\fPwValue, const char *file, intline)"
To send control packets to a non RGB non color K95 Keyboard, use this function\&. Normally it is called via the \fBnk95cmd()\fP macro\&.
.PP
If it is the wrong device for which the function is called, 0 is returned and nothing done\&. Otherwise a usbdevfs_ctrltransfer structure is filled and an USBDEVFS_CONTROL ioctl() called\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x40 see table below to switch hardware-modus at Keyboard wValue device MSG_SIZE 5ms the message buffer pointer Host to Device, Type=Vendor, Recipient=Device bRequest parameter given wValue Parameter device 0 0 data to write 5000 null If a 0 or a negative error number is returned by the ioctl, an error message is shown depending on the errno or 'No data written' if retval was 0\&. In either case 1 is returned to indicate the error\&. If the ioctl returned a value > 0, 0 is returned to indicate no error\&.
.PP
Currently the following combinations for bRequest and wValue are used: Device what it might to do constant bRequest wValue  non RGB Keyboard set HW-modus on (leave the ckb driver) HWON 0x0002 0x0030 non RGB Keyboard set HW-modus off (initialize the ckb driver) HWOFF 0x0002 0x0001 non RGB Keyboard set light modus M1 in single-color keyboards NK95_M1 0x0014 0x0001 non RGB Keyboard set light modus M2 in single-color keyboards NK95_M2 0x0014 0x0002 non RGB Keyboard set light modus M3 in single-color keyboards NK95_M3 0x0014 0x0003 
.PP
\fBSee Also:\fP
.RS 4
\fBusb\&.h\fP 
.RE
.PP

.PP
Definition at line 190 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, usbdevice::handle, P_K95_NRGB, and usbdevice::product\&.
.PP
.nf
190                                                                                       {
191     if(kb->product != P_K95_NRGB)
192         return 0;
193     struct usbdevfs_ctrltransfer transfer = { 0x40, bRequest, wValue, 0, 0, 5000, 0 };
194     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
195     if(res <= 0){
196         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
197         return 1;
198     }
199     return 0;
200 }
.fi
.SS "void os_closeusb (\fBusbdevice\fP *kb)"
os_closeusb unclaim it, destroy the udev device and clear data structures at kb
.PP
os_closeusb is the linux specific implementation for closing an active usb port\&. 
.br
 If a valid handle is given in the kb structure, the usb port is unclaimed (\fBusbunclaim()\fP)\&. 
.br
 The device in unrefenced via library function udev_device_unref()\&. 
.br
 handle, udev and the first char of kbsyspath are cleared to 0 (empty string for kbsyspath)\&. 
.PP
Definition at line 437 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, INDEX_OF, kbsyspath, keyboard, usbdevice::udev, and usbunclaim()\&.
.PP
Referenced by closeusb()\&.
.PP
.nf
437                                {
438     if(kb->handle){
439         usbunclaim(kb, 0);
440         close(kb->handle - 1);
441     }
442     if(kb->udev)
443         udev_device_unref(kb->udev);
444     kb->handle = 0;
445     kb->udev = 0;
446     kbsyspath[INDEX_OF(kb, keyboard)][0] = 0;
447 }
.fi
.SS "void* os_inputmain (void *context)"
os_inputmain is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&.
.PP
\fBTodo\fP
.RS 4
This function is a collection of many tasks\&. It should be divided into several sub-functions for the sake of greater convenience:
.RE
.PP
.PP
.IP "1." 4
set up an URB (Userspace Ressource Buffer) to communicate with the USBDEVFS_* ioctl()s
.IP "2." 4
perform the ioctl()
.IP "3." 4
interpretate the information got into the URB buffer or handle error situations and retry operation or leave the endless loop
.IP "4." 4
inform the os about the data
.IP "5." 4
loop endless via 2\&.
.IP "6." 4
if endless loop has gone, deinitalize the interface, free buffers etc\&.
.IP "7." 4
return null 
.PP
Here the actions in detail:
.PP
Monitor input transfers on all endpoints for non-RGB devices For RGB, monitor all but the last, as it's used for input/output
.PP
Get an usbdevfs_urb data structure and clear it via memset()
.PP
Hopefully the buffer lengths are equal for all devices with congruent types\&. You can find out the correctness for your device with lsusb --v or similar on macOS\&. Currently the following combinations are known and implemented:
.PP
device detect with macro combination endpoint # buffer-length  each none 0 8 RGB Mouse IS_RGB && IS_MOUSE 1 10 RGB Keyboard IS_RGB && !IS_MOUSE 1 21 RGB Mouse or Keyboard IS_RGB 2 MSG_SIZE (64) non RGB Mouse or Keyboard !IS_RGB 1 4 non RGB Mouse or Keyboard !IS_RGB 2 15 
.PP
Now submit all the URBs via ioctl(USBDEVFS_SUBMITURB) with type USBDEVFS_URB_TYPE_INTERRUPT (the endpoints are defined as type interrupt)\&. Endpoint number is 0x80\&.\&.0x82 or 0x83, depending on the model\&.
.PP
The userSpaceFS knows the URBs now, so start monitoring input
.PP
if the ioctl returns something != 0, let's have a deeper look what happened\&. Broken devices or shutting down the entire system leads to closing the device and finishing this thread\&.
.PP
If just an EPIPE ocurred, give the device a CLEAR_HALT and resubmit the URB\&.
.PP
A correct REAPURB returns a Pointer to the URB which we now have a closer look into\&. Lock all following actions with imutex\&.
.PP
Process the input depending on type of device\&. Interprete the actual size of the URB buffer
.PP
device detect with macro combination seems to be endpoint # actual buffer-length function called  mouse (RGB and non RGB) IS_MOUSE nA 8, 10 or 11 \fBhid_mouse_translate()\fP mouse (RGB and non RGB) IS_MOUSE nA MSG_SIZE (64) \fBcorsair_mousecopy()\fP RGB Keyboard IS_RGB && !IS_MOUSE 1 8 (BIOS Mode) \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 2 5 or 21, KB inactive! \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 3? MSG_SIZE \fBcorsair_kbcopy()\fP non RGB Keyboard !IS_RGB && !IS_MOUSE nA nA \fBhid_kb_translate()\fP 
.PP
The input data is transformed and copied to the kb structure\&. Now give it to the OS and unlock the imutex afterwards\&.
.PP
Re-submit the URB for the next run\&.
.PP
If the endless loop is terminated, clean up by discarding the URBs via ioctl(USBDEVFS_DISCARDURB), free the URB buffers and return a null pointer as thread exit code\&. 
.PP
Definition at line 240 of file usb_linux\&.c\&.
.PP
References usbdevice::active, ckb_err, ckb_info, corsair_kbcopy(), corsair_mousecopy(), devpath, usbdevice::epcount, usbdevice::handle, hid_kb_translate(), hid_mouse_translate(), imutex, INDEX_OF, usbdevice::input, inputupdate(), IS_MOUSE, IS_RGB, keyboard, usbinput::keys, MSG_SIZE, usbdevice::product, usbinput::rel_x, usbinput::rel_y, and usbdevice::vendor\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
240                                  {
241     usbdevice* kb = context;
242     int fd = kb->handle - 1;
243     short vendor = kb->vendor, product = kb->product;
244     int index = INDEX_OF(kb, keyboard);
245     ckb_info("Starting input thread for %s%d\n", devpath, index);
246 
251     int urbcount = IS_RGB(vendor, product) ? (kb->epcount - 1) : kb->epcount;
252     if (urbcount == 0) {
253         ckb_err("urbcount = 0, so there is nothing to claim in os_inputmain()\n");
254         return 0;
255     }
256 
258     struct usbdevfs_urb urbs[urbcount + 1];
259     memset(urbs, 0, sizeof(urbs));
260 
274     urbs[0]\&.buffer_length = 8;
275     if(urbcount > 1 && IS_RGB(vendor, product)) {
276         if(IS_MOUSE(vendor, product))
277             urbs[1]\&.buffer_length = 10;
278         else
279             urbs[1]\&.buffer_length = 21;
280         urbs[2]\&.buffer_length = MSG_SIZE;
281         if(urbcount != 3)
282             urbs[urbcount - 1]\&.buffer_length = MSG_SIZE;
283     } else {
284         urbs[1]\&.buffer_length = 4;
285         urbs[2]\&.buffer_length = 15;
286     }
287 
290     for(int i = 0; i < urbcount; i++){
291         urbs[i]\&.type = USBDEVFS_URB_TYPE_INTERRUPT;
292         urbs[i]\&.endpoint = 0x80 | (i + 1);
293         urbs[i]\&.buffer = malloc(urbs[i]\&.buffer_length);
294         ioctl(fd, USBDEVFS_SUBMITURB, urbs + i);
295     }
296 
298     while (1) {
299         struct usbdevfs_urb* urb = 0;
300 
303         if (ioctl(fd, USBDEVFS_REAPURB, &urb)) {
304             if (errno == ENODEV || errno == ENOENT || errno == ESHUTDOWN)
305                 // Stop the thread if the handle closes
306                 break;
307             else if(errno == EPIPE && urb){
309                 ioctl(fd, USBDEVFS_CLEAR_HALT, &urb->endpoint);
310                 // Re-submit the URB
311                 if(urb)
312                     ioctl(fd, USBDEVFS_SUBMITURB, urb);
313                 urb = 0;
314             }
315             continue;
316         }
317 
321         if (urb) {
322 
334             pthread_mutex_lock(imutex(kb));
335             if(IS_MOUSE(vendor, product)){
336                 switch(urb->actual_length){
337                 case 8:
338                 case 10:
339                 case 11:
340                     // HID mouse input
341                     hid_mouse_translate(kb->input\&.keys, &kb->input\&.rel_x, &kb->input\&.rel_y, -(urb->endpoint & 0xF), urb->actual_length, urb->buffer);
342                     break;
343                 case MSG_SIZE:
344                     // Corsair mouse input
345                     corsair_mousecopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
346                     break;
347                 }
348             } else if(IS_RGB(vendor, product)){
349                 switch(urb->actual_length){
350                 case 8:
351                     // RGB EP 1: 6KRO (BIOS mode) input
352                     hid_kb_translate(kb->input\&.keys, -1, urb->actual_length, urb->buffer);
353                     break;
354                 case 21:
355                 case 5:
356                     // RGB EP 2: NKRO (non-BIOS) input\&. Accept only if keyboard is inactive
357                     if(!kb->active)
358                         hid_kb_translate(kb->input\&.keys, -2, urb->actual_length, urb->buffer);
359                     break;
360                 case MSG_SIZE:
361                     // RGB EP 3: Corsair input
362                     corsair_kbcopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
363                     break;
364                 }
365             } else {
366                 // Non-RGB input
367                 hid_kb_translate(kb->input\&.keys, urb->endpoint & 0xF, urb->actual_length, urb->buffer);
368             }
371             inputupdate(kb);
372             pthread_mutex_unlock(imutex(kb));
373 
375             ioctl(fd, USBDEVFS_SUBMITURB, urb);
376             urb = 0;
377         }
378     }
379 
383     ckb_info("Stopping input thread for %s%d\n", devpath, index);
384     for(int i = 0; i < urbcount; i++){
385         ioctl(fd, USBDEVFS_DISCARDURB, urbs + i);
386         free(urbs[i]\&.buffer);
387     }
388     return 0;
389 }
.fi
.SS "int os_resetusb (\fBusbdevice\fP *kb, const char *file, intline)"
os_resetusb is the os specific implementation for resetting usb
.PP
Try to reset an usb device in a linux user space driver\&.
.IP "1." 4
unclaim the device, but do not reconnect the system driver (second param resetting = true)
.IP "2." 4
reset the device via USBDEVFS_RESET command
.IP "3." 4
claim the device again\&. Returns 0 on success, -2 if device should be removed and -1 if reset should by tried again
.PP
.PP
\fBTodo\fP
.RS 4
it seems that no one wants to try the reset again\&. But I'v seen it somewhere\&.\&.\&. 
.RE
.PP

.PP
Definition at line 499 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, TEST_RESET, usbclaim(), and usbunclaim()\&.
.PP
Referenced by _resetusb()\&.
.PP
.nf
499                                                            {
500     TEST_RESET(usbunclaim(kb, 1));
501     TEST_RESET(ioctl(kb->handle - 1, USBDEVFS_RESET));
502     TEST_RESET(usbclaim(kb));
503     // Success!
504     return 0;
505 }
.fi
.SS "void os_sendindicators (\fBusbdevice\fP *kb)"
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
Read the data from kb->ileds ans send them via ioctl() to the keyboard\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 Interface 0 MSG_SIZE 1 Byte timeout 0,5ms the message buffer pointer Host to Device, Type=Class, Recipient=Interface (why not endpoint?) 9 = SEND? specific 0 1 500 struct* kb->ileds 
.br
 The ioctl command is USBDEVFS_CONTROL\&. 
.PP
Definition at line 215 of file usb_linux\&.c\&.
.PP
References ckb_err, usbdevice::handle, usbdevice::ileds, and usb_tryreset()\&.
.PP
Referenced by updateindicators_kb()\&.
.PP
.nf
215                                       {
216     static int countForReset = 0;
217     struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, 0x00, 1, 500, &kb->ileds };
218     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
219     if(res <= 0) {
220         ckb_err("%s\n", res ? strerror(errno) : "No data written");
221         if (usb_tryreset(kb) == 0 && countForReset++ < 3) {
222             os_sendindicators(kb);
223         }
224     }
225 }
.fi
.SS "int os_setupusb (\fBusbdevice\fP *kb)"
os_setupusb OS-specific setup for a specific usb device\&.
.PP
Perform the operating system-specific opening of the interface in \fBos_setupusb()\fP\&. As a result, some parameters should be set in kb (name, serial, fwversion, epcount = number of usb endpoints), and all endpoints should be claimed with \fBusbclaim()\fP\&. Claiming is the only point where \fBos_setupusb()\fP can produce an error (-1)\&. 
.IP "\(bu" 2
Copy device description and serial
.IP "\(bu" 2
Copy firmware version (needed to determine USB protocol)
.IP "\(bu" 2
Do some output about connecting interfaces
.IP "\(bu" 2
Claim the USB interfaces
.PP
.PP
\fBTodo\fP
.RS 4
in these modules a pullrequest is outstanding 
.RE
.PP
.PP
< Try to reset the device and recall the function
.PP
< Don't do this endless in recursion
.PP
< \fBos_setupusb()\fP has a return value (used as boolean) 
.PP
Definition at line 537 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, devpath, usbdevice::epcount, usbdevice::fwversion, INDEX_OF, KB_NAME_LEN, keyboard, usbdevice::name, usbdevice::serial, SERIAL_LEN, strtrim(), usbdevice::udev, usb_tryreset(), and usbclaim()\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
537                                {
540     struct udev_device* dev = kb->udev;
541     const char* name = udev_device_get_sysattr_value(dev, "product");
542     if(name)
543         strncpy(kb->name, name, KB_NAME_LEN);
544     strtrim(kb->name);
545     const char* serial = udev_device_get_sysattr_value(dev, "serial");
546     if(serial)
547         strncpy(kb->serial, serial, SERIAL_LEN);
548     strtrim(kb->serial);
551     const char* firmware = udev_device_get_sysattr_value(dev, "bcdDevice");
552     if(firmware)
553         sscanf(firmware, "%hx", &kb->fwversion);
554     else
555         kb->fwversion = 0;
556     int index = INDEX_OF(kb, keyboard);
557 
559     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
560 
566     const char* ep_str = udev_device_get_sysattr_value(dev, "bNumInterfaces");
567 #ifdef DEBUG
568     ckb_info("claiming interfaces\&. name=%s, serial=%s, firmware=%s; Got >>%s<< as ep_str\n", name, serial, firmware, ep_str);
569 #endif //DEBUG
570     kb->epcount = 0;
571     if(ep_str)
572         sscanf(ep_str, "%d", &kb->epcount);
573     if(kb->epcount < 2){
574         // IF we have an RGB KB with 0 or 1 endpoints, it will be in BIOS mode\&.
575         ckb_err("Unable to read endpoint count from udev, assuming %d and reading >>%s<< or device is in BIOS mode\n", kb->epcount, ep_str);
576         if (usb_tryreset(kb) == 0) { 
577             static int retryCount = 0; 
578             if (retryCount++ < 5) {
579                 return os_setupusb(kb); 
580             }
581         }
582         return -1;
583         // ToDo are there special versions we have to detect? If there are, that was the old code to handle it:
584         // This shouldn't happen, but if it does, assume EP count based onckb_warn what the device is supposed to have
585         // kb->epcount = (HAS_FEATURES(kb, FEAT_RGB) ? 4 : 3);
586         // ckb_warn("Unable to read endpoint count from udev, assuming %d and reading >>%s<<\&.\&.\&.\n", kb->epcount, ep_str);
587     }
588     if(usbclaim(kb)){
589         ckb_err("Failed to claim interfaces: %s\n", strerror(errno));
590         return -1;
591     }
592     return 0;
593 }
.fi
.SS "int os_usbrecv (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, intline)"
os_usbrecv does what its name says:
.PP
The comment at the beginning of the procedure causes the suspicion that the firmware versionspecific distinction is missing for receiving from usb endpoint 3 or 4\&. The commented code contains only the reception from EP4, but this may be wrong for a software version 2\&.0 or higher (see the code for os-usbsend ())\&.
.PP

.br
 So all the receiving is done via an ioctl() like in os_usbsend\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0xA1 0x01 0x0200 endpoint to be addressed from epcount - 1 MSG_SIZE 5ms the message buffer pointer Device to Host, Type=Class, Recipient=Interface 1 = RECEIVE? specific Interface # 64 5000 in_msg The ioctl() returns the number of bytes received\&. Here is the usual check again:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbrecv()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes are received, 0 is returned as an identifier for a heavy error\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes received\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Read YY bytes (expected 64)']\&. 
.PP
Definition at line 130 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv()\&.
.PP
.nf
130                                                                         {
131     int res;
132     // This is what CUE does, but it doesn't seem to work on linux\&.
133     /*if(kb->fwversion >= 0x130){
134         struct usbdevfs_bulktransfer transfer;
135         memset(&transfer, 0, sizeof(transfer));
136         transfer\&.ep = 0x84;
137         transfer\&.len = MSG_SIZE;
138         transfer\&.timeout = 5000;
139         transfer\&.data = in_msg;
140         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
141     } else {*/
142         struct usbdevfs_ctrltransfer transfer = { 0xa1, 0x01, 0x0300, kb->epcount - 1, MSG_SIZE, 5000, in_msg };
143         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
144     //}
145     if(res <= 0){
146         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data read");
147         if(res == -1 && errno == ETIMEDOUT)
148             return -1;
149         else
150             return 0;
151     } else if(res != MSG_SIZE)
152         ckb_warn_fn("Read %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
153 #ifdef DEBUG_USB_RECV
154     char converted[MSG_SIZE*3 + 1];
155     for(int i=0;i<MSG_SIZE;i++)
156         sprintf(&converted[i*3], "%02x ", in_msg[i]);
157     ckb_warn_fn("Recv %s\n", file, line, converted);
158 #endif
159     return res;
160 }
.fi
.SS "int os_usbsend (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, intis_recv, const char *file, intline)"
os_usbsend has two functions:
.IP "\(bu" 2
if is_recv == false, it tries to send a given MSG_SIZE buffer via the usb interface given with kb\&.
.IP "\(bu" 2
otherwise a request is sent via the usb device to initiate the receiving of a message from the remote device\&.
.PP
.PP
The functionality for sending distinguishes two cases, depending on the version number of the firmware of the connected device: 
.br
 If the firmware is less or equal 1\&.2, the transmission is done via an ioctl()\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 endpoint / IF to be addressed from epcount-1 MSG_SIZE 5000 (=5ms) the message buffer pointer Host to Device, Type=Class, Recipient=Interface 9 = Send data? specific last or pre-last device # 64 5000 out_msg 
.br
 The ioctl command is USBDEVFS_CONTROL\&.
.PP
The same constellation is used if the device is requested to send its data (is_recv = true)\&.
.PP
For a more recent firmware and is_recv = false, the ioctl command USBDEVFS_CONTROL is not used (this tells the bus to enter the control mode), but the bulk method is used: USBDEVFS_BULK\&. This is astonishing, because all of the endpoints are type Interrupt, not bulk\&.
.PP
Anyhow, forthis purpose a different structure is used for the ioctl() (struct \fBusbdevfs_bulktransfer\fP) and this is also initialized differently: 
.br
 The length and timeout parameters are given the same values as above\&. The formal parameter out_msg is also passed as a buffer pointer\&. For the endpoints, the firmware version is differentiated again: 
.br
 For a firmware version between 1\&.3 and <2\&.0 endpoint 4 is used, otherwise (it can only be >=2\&.0) endpoint 3 is used\&.
.PP
\fBTodo\fP
.RS 4
Since the handling of endpoints has already led to problems elsewhere, this implementation is extremely hardware-dependent and critical! 
.br
 Eg\&. the new keyboard K95PLATINUMRGB has a version number significantly less than 2\&.0 - will it run with this implementation?
.RE
.PP
.PP
The ioctl() - no matter what type - returns the number of bytes sent\&. Now comes the usual check:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbsend()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes sent, 0 is returned as a heavy error identifier\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes sent\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Wrote YY bytes (expected 64)']\&.
.PP
If DEBUG_USB is set during compilation, the number of bytes sent and their representation are logged to the error channel\&. 
.PP
Definition at line 68 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::fwversion, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv(), and _usbsend()\&.
.PP
.nf
68                                                                                              {
69     int res;
70     if (kb->fwversion >= 0x120 && !is_recv) {
71         struct usbdevfs_bulktransfer transfer;
72         memset(&transfer, 0, sizeof(transfer));
73         transfer\&.ep = (kb->fwversion >= 0x130 && kb->fwversion < 0x200) ? 4 : 3;
74         transfer\&.len = MSG_SIZE;
75         transfer\&.timeout = 5000;
76         transfer\&.data = (void*)out_msg;
77         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
78     } else {
79         struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, kb->epcount - 1, MSG_SIZE, 5000, (void*)out_msg };
80         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
81     }
82 
83     if (res <= 0){
84         ckb_err_fn(" %s, res = 0x%x\n", file, line, res ? strerror(errno) : "No data written", res);
85         if(res == -1 && errno == ETIMEDOUT)
86             return -1;
87         else
88             return 0;
89     } else if (res != MSG_SIZE)
90         ckb_warn_fn("Wrote %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
91 #ifdef DEBUG_USB
92     char converted[MSG_SIZE*3 + 1];
93     for(int i=0;i<MSG_SIZE;i++)
94         sprintf(&converted[i*3], "%02x ", out_msg[i]);
95     ckb_warn_fn("Sent %s\n", file, line, converted);
96 #endif
97     return res;
98 }
.fi
.SS "void strtrim (char *string)"
strtrim trims a string by removing leading and trailing spaces\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP 
.RE
.PP

.PP
Definition at line 512 of file usb_linux\&.c\&.
.PP
Referenced by os_setupusb()\&.
.PP
.nf
512                           {
513     // Find last non-space
514     char* last = string;
515     for(char* c = string; *c != 0; c++){
516         if(!isspace(*c))
517             last = c;
518     }
519     last[1] = 0;
520     // Find first non-space
521     char* first = string;
522     for(; *first != 0; first++){
523         if(!isspace(*first))
524             break;
525     }
526     if(first != string)
527         memmove(string, first, last - first);
528 }
.fi
.SS "static void udev_enum ()\fC [static]\fP"
Reduce the hits of the enumeration by limiting to usb as technology and corsair as idVendor\&. Then filter with udev_enumerate_scan_devices () all hits\&.
.PP
The following call to udev_enumerate_get_list_entry() fetches the entire hitlist as udev_list_entry *\&. 
.br
 Use udev_list_entry_foreach() to iterate through the hit set\&. 
.br
 If both the device name exists (udev_list_entry_get_name) and the subsequent creation of a new udev_device (udev_device_new_from_syspath) is ok, the new device is added to the list with \fBusb_add_device()\fP\&.
.PP
If the latter does not work, the new device is released again (udev_device_unref ())\&. 
.br
 After the last iteration, the enumerator is released with udev_enumerate_unref ()\&. 
.PP
Definition at line 749 of file usb_linux\&.c\&.
.PP
References usb_add_device(), and V_CORSAIR_STR\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
749                        {
750     struct udev_enumerate* enumerator = udev_enumerate_new(udev);
751     udev_enumerate_add_match_subsystem(enumerator, "usb");
752     udev_enumerate_add_match_sysattr(enumerator, "idVendor", V_CORSAIR_STR);
753     udev_enumerate_scan_devices(enumerator);
754     struct udev_list_entry* devices, *dev_list_entry;
755     devices = udev_enumerate_get_list_entry(enumerator);
756 
757     udev_list_entry_foreach(dev_list_entry, devices){
758         const char* path = udev_list_entry_get_name(dev_list_entry);
759         if(!path)
760             continue;
761         struct udev_device* dev = udev_device_new_from_syspath(udev, path);
762         if(!dev)
763             continue;
764         // If the device matches a recognized device ID, open it
765         if(usb_add_device(dev))
766             // Release device if not
767             udev_device_unref(dev);
768     }
769     udev_enumerate_unref(enumerator);
770 }
.fi
.SS "static int usb_add_device (struct udev_device *dev)\fC [static]\fP"
If the device id can be found, call \fBusbadd()\fP with the appropriate parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the retval of \fBusbadd()\fP or 1 if either vendor is not corsair or product is not mentioned in model[]\&.
.RE
.PP
First get the idVendor via udev_device_get_sysattr_value()\&. If this is equal to the ID-string of corsair ('1b1c'), get the idProduct on the same way\&. 
.br
 If we can find the model name in the model array, call \fBusbadd()\fP with the model number\&. 
.PP
\fBTodo\fP
.RS 4
So why the hell not a transformation between the string and the short presentation? Lets check if the string representation is used elsewhere\&. 
.RE
.PP

.PP
Definition at line 697 of file usb_linux\&.c\&.
.PP
References N_MODELS, usbadd(), V_CORSAIR, and V_CORSAIR_STR\&.
.PP
Referenced by udev_enum(), and usbmain()\&.
.PP
.nf
697                                                   {
698     const char* vendor = udev_device_get_sysattr_value(dev, "idVendor");
699     if(vendor && !strcmp(vendor, V_CORSAIR_STR)){
700         const char* product = udev_device_get_sysattr_value(dev, "idProduct");
701         if(product){
702             for(_model* model = models; model < models + N_MODELS; model++){
703                 if(!strcmp(product, model->name)){
704                     return usbadd(dev, V_CORSAIR, model->number);
705                 }
706             }
707         }
708     }
709     return 1;
710 }
.fi
.SS "static void usb_rm_device (struct udev_device *dev)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&.
.RE
.PP
First try to find the system path of the device given in parameter dev\&. The index where the name is found is the same index we need to address the global keyboard array\&. That array holds all usbdevices\&. 
.br
 Searching for the correct name in kbsyspath-array and closing the usb via \fBcloseusb()\fP are protected by lock\&.\&.unlock of the corresponding devmutex arraymember\&. 
.PP
Definition at line 722 of file usb_linux\&.c\&.
.PP
References closeusb(), DEV_MAX, devmutex, kbsyspath, and keyboard\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
722                                                   {
723     // Device removed\&. Look for it in our list of keyboards
724     const char* syspath = udev_device_get_syspath(dev);
725     if(!syspath || syspath[0] == 0)
726         return;
727     for(int i = 1; i < DEV_MAX; i++){
728         pthread_mutex_lock(devmutex + i);
729         if(!strcmp(syspath, kbsyspath[i]))
730             closeusb(keyboard + i);
731         pthread_mutex_unlock(devmutex + i);
732     }
733 }
.fi
.SS "int usbadd (struct udev_device *dev, shortvendor, shortproduct)"

.PP
Definition at line 595 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, DEV_MAX, dmutex, usbdevice::handle, IS_CONNECTED, kbsyspath, keyboard, usbdevice::product, setupusb(), usbdevice::udev, and usbdevice::vendor\&.
.PP
Referenced by usb_add_device()\&.
.PP
.nf
595                                                                  {
596     const char* path = udev_device_get_devnode(dev);
597     const char* syspath = udev_device_get_syspath(dev);
598     if(!path || !syspath || path[0] == 0 || syspath[0] == 0){
599         ckb_err("Failed to get device path\n");
600         return -1;
601     }
602 #ifdef DEBUG
603     ckb_info(">>>vendor = 0x%x, product = 0x%x, path = %s, syspath = %s\n", vendor, product, path, syspath);
604 #endif // DEDBUG
605     // Find a free USB slot
606     for(int index = 1; index < DEV_MAX; index++){
607         usbdevice* kb = keyboard + index;
608         if(pthread_mutex_trylock(dmutex(kb))){
609             // If the mutex is locked then the device is obviously in use, so keep going
610             if(!strcmp(syspath, kbsyspath[index])){
611                 // Make sure this existing keyboard doesn't have the same syspath (this shouldn't happen)
612                 return 0;
613             }
614             continue;
615         }
616         if(!IS_CONNECTED(kb)){
617             // Open the sysfs device
618             kb->handle = open(path, O_RDWR) + 1;
619             if(kb->handle <= 0){
620                 ckb_err("Failed to open USB device: %s\n", strerror(errno));
621                 kb->handle = 0;
622                 pthread_mutex_unlock(dmutex(kb));
623                 return -1;
624             } else {
625                 // Set up device
626                 kb->udev = dev;
627                 kb->vendor = vendor;
628                 kb->product = product;
629                 strncpy(kbsyspath[index], syspath, FILENAME_MAX);
630                 // Mutex remains locked
631                 setupusb(kb);
632                 return 0;
633             }
634         }
635         pthread_mutex_unlock(dmutex(kb));
636     }
637     ckb_err("No free devices\n");
638     return -1;
639 }
.fi
.SS "static int usbclaim (\fBusbdevice\fP *kb)\fC [static]\fP"
usbclaim does claiming all EPs for the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 otherwise\&.
.RE
.PP
Claim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCONNECT) and ioctl(USBDEVFS_CLAIMINTERFACE)\&.
.PP
Error handling is done for the ioctl(USBDEVFS_CLAIMINTERFACE) only\&. If this fails, now an error message is thrown and -1 is returned\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 461 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, usbdevice::epcount, and usbdevice::handle\&.
.PP
Referenced by os_resetusb(), and os_setupusb()\&.
.PP
.nf
461                                   {
462     int count = kb->epcount;
463 #ifdef DEBUG
464     ckb_info("claiming %d endpoints\n", count);
465 #endif // DEBUG
466 
467     for(int i = 0; i < count; i++){
468         struct usbdevfs_ioctl ctl = { i, USBDEVFS_DISCONNECT, 0 };
469         ioctl(kb->handle - 1, USBDEVFS_IOCTL, &ctl);
470         if(ioctl(kb->handle - 1, USBDEVFS_CLAIMINTERFACE, &i)) {
471             ckb_err("Failed to claim interface %d: %s\n", i, strerror(errno));
472             return -1;
473         }
474     }
475     return 0;
476 }
.fi
.SS "void usbkill ()"

.PP
Definition at line 837 of file usb_linux\&.c\&.
.PP
Referenced by quitWithLock()\&.
.PP
.nf
837               {
838     udev_unref(udev);
839     udev = 0;
840 }
.fi
.SS "int usbmain ()"
Start the USB main loop\&. Returns program exit code when finished\&.
.PP
usbmain is called by \fBmain()\fP after setting up all other stuff\&. 
.PP
\fBReturns:\fP
.RS 4
0 normally or -1 if fatal error occurs (up to now only if no new devices are available) 
.RE
.PP
First check whether the uinput module is loaded by the kernel\&. 
.PP
\fBTodo\fP
.RS 4
Why isn't missing of uinput a fatal error? 
.RE
.PP
.PP
Create the udev object with udev_new() (is a function from libudev\&.h) terminate -1 if error
.PP
Enumerate all currently connected devices
.PP
\fBTodo\fP
.RS 4
lae\&. here the work has to go on\&.\&.\&. 
.RE
.PP

.PP
Definition at line 777 of file usb_linux\&.c\&.
.PP
References ckb_fatal, ckb_warn, udev_enum(), usb_add_device(), and usb_rm_device()\&.
.PP
Referenced by main()\&.
.PP
.nf
777              {
782     // Load the uinput module (if it's not loaded already)
783     if(system("modprobe uinput") != 0)
784         ckb_warn("Failed to load uinput module\n");
785 
789     if(!(udev = udev_new())) {
790         ckb_fatal("Failed to initialize udev in usbmain(), usb_linux\&.c\n");
791         return -1;
792     }
793 
796     udev_enum();
797 
800     // Done scanning\&. Enter a loop to poll for device updates
801     struct udev_monitor* monitor = udev_monitor_new_from_netlink(udev, "udev");
802     udev_monitor_filter_add_match_subsystem_devtype(monitor, "usb", 0);
803     udev_monitor_enable_receiving(monitor);
804     // Get an fd for the monitor
805     int fd = udev_monitor_get_fd(monitor);
806     fd_set fds;
807     while(udev){
808         FD_ZERO(&fds);
809         FD_SET(fd, &fds);
810         // Block until an event is read
811         if(select(fd + 1, &fds, 0, 0, 0) > 0 && FD_ISSET(fd, &fds)){
812             struct udev_device* dev = udev_monitor_receive_device(monitor);
813             if(!dev)
814                 continue;
815             const char* action = udev_device_get_action(dev);
816             if(!action){
817                 udev_device_unref(dev);
818                 continue;
819             }
820             // Add/remove device
821             if(!strcmp(action, "add")){
822                 int res = usb_add_device(dev);
823                 if(res == 0)
824                     continue;
825                 // If the device matched but the handle wasn't opened correctly, re-enumerate (this sometimes solves the problem)
826                 if(res == -1)
827                     udev_enum();
828             } else if(!strcmp(action, "remove"))
829                 usb_rm_device(dev);
830             udev_device_unref(dev);
831         }
832     }
833     udev_monitor_unref(monitor);
834     return 0;
835 }
.fi
.SS "static int usbunclaim (\fBusbdevice\fP *kb, intresetting)\fC [static]\fP"
usbunclaim do an unclaiming of the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.br
\fIresetting\fP boolean flag: If resseting is true, the caller will perform a bus reset command after unclaiming the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
always 0\&.
.RE
.PP
Unclaim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCARDURB)\&.
.PP
Afterwards - if ressetting is false - do a USBDEVFS_CONNECT for EP 0 and 1\&. If it is a non RGB device, connect EP 2 also\&. The comment mentions RGB keyboards only, but as I understand the code, this is valid also for RGB mice\&.
.PP
There is no error handling yet\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 408 of file usb_linux\&.c\&.
.PP
References usbdevice::epcount, FEAT_RGB, usbdevice::handle, and HAS_FEATURES\&.
.PP
Referenced by os_closeusb(), and os_resetusb()\&.
.PP
.nf
408                                                     {
409     int handle = kb->handle - 1;
410     int count = kb->epcount;
411     for (int i = 0; i < count; i++) {
412         ioctl(handle, USBDEVFS_RELEASEINTERFACE, &i);
413     }
414     // For RGB keyboards, the kernel driver should only be reconnected to interfaces 0 and 1 (HID), and only if we're not about to do a USB reset\&.
415     // Reconnecting any of the others causes trouble\&.
416     if (!resetting) {
417         struct usbdevfs_ioctl ctl = { 0, USBDEVFS_CONNECT, 0 };
418         ioctl(handle, USBDEVFS_IOCTL, &ctl);
419         ctl\&.ifno = 1;
420         ioctl(handle, USBDEVFS_IOCTL, &ctl);
421         // Also reconnect iface #2 (HID) for non-RGB keyboards
422         if(!HAS_FEATURES(kb, FEAT_RGB)){
423             ctl\&.ifno = 2;
424             ioctl(handle, USBDEVFS_IOCTL, &ctl);
425         }
426     }
427     return 0;
428 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char kbsyspath[9][FILENAME_MAX]\fC [static]\fP"

.PP
Definition at line 13 of file usb_linux\&.c\&.
.PP
Referenced by os_closeusb(), usb_rm_device(), and usbadd()\&.
.SS "\fB_model\fP models[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    
    {  "1b17" ,  0x1b17  },
    {  "1b07" ,  0x1b07  },
    {  "1b37" ,  0x1b37  },
    {  "1b39" ,  0x1b39  },
    {  "1b13" ,  0x1b13  },
    {  "1b09" ,  0x1b09  },
    {  "1b33" ,  0x1b33  },
    {  "1b36" ,  0x1b36  },
    {  "1b38" ,  0x1b38  },
    {  "1b3a" ,  0x1b3a  },
    {  "1b11" ,  0x1b11  },
    {  "1b08" ,  0x1b08  },
    {  "1b2d" ,  0x1b2d  },
    {  "1b20" ,  0x1b20  },
    {  "1b15" ,  0x1b15  },
    
    {  "1b12" ,  0x1b12  },
    {  "1b2e" ,  0x1b2e  },
    {  "1b14" ,  0x1b14   },
    {  "1b19" ,  0x1b19   },
    {  "1b2f" ,  0x1b2f   },
    {  "1b1e" ,  0x1b1e  },
    {  "1b3e" ,  0x1b3e  },
    {  "1b32" ,  0x1b32   }
}
.fi

.PP
\fBAttention:\fP
.RS 4
when adding new hardware this file hat to be changed too\&.
.RE
.PP
In this structure array \fImodels\fP[] for each device the name (the device id as string in hex without leading 0x) and its usb device id as short must be entered in this array\&. 
.PP
Definition at line 657 of file usb_linux\&.c\&.
.SS "struct udev* udev\fC [static]\fP"

.PP
Definition at line 641 of file usb_linux\&.c\&.
.SS "pthread_t udevthread"

.PP
Definition at line 644 of file usb_linux\&.c\&.
.SS "pthread_t usbthread"

.PP
\fBTodo\fP
.RS 4
These two thread vasriables seem to be unused: usbtread, udevthread 
.RE
.PP

.PP
Definition at line 644 of file usb_linux\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
