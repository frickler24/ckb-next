.TH "src/ckb-daemon/usb_linux.c" 3 "Tue May 16 2017" "Version beta-v0.2.7 at branch testing" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/usb_linux.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_model\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEBUG\fP"
.br
.RI "\fIall open usb devices have their system path names here in this array\&. \fP"
.ti -1c
.RI "#define \fBTEST_RESET\fP(op)"
.br
.RI "\fITEST_RESET doesa 'try / catch' for resetting the usb interface\&. \fP"
.ti -1c
.RI "#define \fBN_MODELS\fP   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBos_usbsend\fP (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, int is_recv, const char *file, int line)"
.br
.RI "\fIos_usbsend sends a data packet (MSG_SIZE = 64) Bytes long \fP"
.ti -1c
.RI "int \fBos_usbrecv\fP (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, int line)"
.br
.RI "\fIos_usbrecv receives a max MSGSIZE long buffer from usb device \fP"
.ti -1c
.RI "int \fB_nk95cmd\fP (\fBusbdevice\fP *kb, \fBuchar\fP bRequest, \fBushort\fP wValue, const char *file, int line)"
.br
.RI "\fI_nk95cmd If we control a non RGB keyboard, set the keyboard via ioctl with usbdevfs_ctrltransfer \fP"
.ti -1c
.RI "void \fBos_sendindicators\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void * \fBos_inputmain\fP (void *context)"
.br
.RI "\fIos_inputmain This function is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&. \fP"
.ti -1c
.RI "static int \fBusbunclaim\fP (\fBusbdevice\fP *kb, int resetting)"
.br
.ti -1c
.RI "void \fBos_closeusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "static int \fBusbclaim\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBos_resetusb\fP (\fBusbdevice\fP *kb, const char *file, int line)"
.br
.ti -1c
.RI "void \fBstrtrim\fP (char *string)"
.br
.ti -1c
.RI "int \fBos_setupusb\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBusbadd\fP (struct udev_device *dev, short vendor, short product)"
.br
.ti -1c
.RI "static int \fBusb_add_device\fP (struct udev_device *dev)"
.br
.RI "\fIAdd a udev device\&. Returns 0 if device was recognized/added\&. \fP"
.ti -1c
.RI "static void \fBusb_rm_device\fP (struct udev_device *dev)"
.br
.RI "\fIusb_rm_device find the usb port to remove and close it via \fBcloseusb()\fP\&. \fP"
.ti -1c
.RI "static void \fBudev_enum\fP ()"
.br
.RI "\fIudev_enum use the udev_enumerate_add_match_subsystem() to get all you need but only that\&. \fP"
.ti -1c
.RI "int \fBusbmain\fP ()"
.br
.ti -1c
.RI "void \fBusbkill\fP ()"
.br
.RI "\fIStop the USB system\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static char \fBkbsyspath\fP [9][FILENAME_MAX]"
.br
.ti -1c
.RI "static struct udev * \fBudev\fP"
.br
.RI "\fIstruct udef is defined in /usr/include/libudev\&.h \fP"
.ti -1c
.RI "pthread_t \fBusbthread\fP"
.br
.ti -1c
.RI "pthread_t \fBudevthread\fP"
.br
.ti -1c
.RI "static \fB_model\fP \fBmodels\fP []"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct _model"
.PP 
Definition at line 644 of file usb_linux\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
const char * \fIname\fP 
.br
.PP
short \fInumber\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define DEBUG"

.PP
Definition at line 11 of file usb_linux\&.c\&.
.SS "#define N_MODELS   (sizeof(\fBmodels\fP) / sizeof(\fB_model\fP))"

.PP
Definition at line 681 of file usb_linux\&.c\&.
.PP
Referenced by usb_add_device()\&.
.SS "#define TEST_RESET(op)"
\fBValue:\fP
.PP
.nf
if(op){                                                                 \\
        ckb_err_fn("resetusb failed: %s\n", file, line, strerror(errno));   \
        if(errno == EINTR || errno == EAGAIN)                               \
            return -1;              /* try again if status code says so */  \
        return -2;                  /* else, remove device */               \
    }
.fi
.PP
Definition at line 477 of file usb_linux\&.c\&.
.PP
Referenced by os_resetusb()\&.
.SH "Function Documentation"
.PP 
.SS "int _nk95cmd (\fBusbdevice\fP *kb, \fBuchar\fPbRequest, \fBushort\fPwValue, const char *file, intline)"
To send control packets to a non RGB non color K95 Keyboard, use this function\&. Normally it is called via the \fBnk95cmd()\fP macro\&.
.PP
If it is the wrong device for which the function is called, 0 is returned and nothing done\&. Otherwise a usbdevfs_ctrltransfer structure is filled and an USBDEVFS_CONTROL ioctl() called\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x40 see table below to switch hardware-modus at Keyboard wValue device MSG_SIZE 5ms the message buffer pointer Host to Device, Type=Vendor, Recipient=Device bRequest parameter given wValue Parameter device 0 0 data to write 5000 null If a 0 or a negative error number is returned by the ioctl, an error message is shown depending on the errno or 'No data written' if retval was 0\&. In either case 1 is returned to indicate the error\&. If the ioctl returned a value > 0, 0 is returned to indicate no error\&.
.PP
Currently the following combinations for bRequest and wValue are used: Device what it might to do constant bRequest wValue  non RGB Keyboard set HW-modus on (leave the ckb driver) HWON 0x0002 0x0030 non RGB Keyboard set HW-modus off (initialize the ckb driver) HWOFF 0x0002 0x0001 non RGB Keyboard set light modus M1 in single-color keyboards NK95_M1 0x0014 0x0001 non RGB Keyboard set light modus M2 in single-color keyboards NK95_M2 0x0014 0x0002 non RGB Keyboard set light modus M3 in single-color keyboards NK95_M3 0x0014 0x0003 
.PP
\fBSee Also:\fP
.RS 4
\fBusb\&.h\fP 
.RE
.PP

.PP
Definition at line 189 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, usbdevice::handle, P_K95_NRGB, and usbdevice::product\&.
.PP
.nf
189                                                                                       {
190     if(kb->product != P_K95_NRGB)
191         return 0;
192     struct usbdevfs_ctrltransfer transfer = { 0x40, bRequest, wValue, 0, 0, 5000, 0 };
193     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
194     if(res <= 0){
195         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
196         return 1;
197     }
198     return 0;
199 }
.fi
.SS "void os_closeusb (\fBusbdevice\fP *kb)"
os_closeusb unclaim it, destroy the udev device and clear data structures at kb
.PP
os_closeusb is the linux specific implementation for closing an active usb port\&. 
.br
 If a valid handle is given in the kb structure, the usb port is unclaimed (\fBusbunclaim()\fP)\&. 
.br
 The device in unrefenced via library function udev_device_unref()\&. 
.br
 handle, udev and the first char of kbsyspath are cleared to 0 (empty string for kbsyspath)\&. 
.PP
Definition at line 433 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, INDEX_OF, kbsyspath, keyboard, usbdevice::udev, and usbunclaim()\&.
.PP
Referenced by closeusb()\&.
.PP
.nf
433                                {
434     if(kb->handle){
435         usbunclaim(kb, 0);
436         close(kb->handle - 1);
437     }
438     if(kb->udev)
439         udev_device_unref(kb->udev);
440     kb->handle = 0;
441     kb->udev = 0;
442     kbsyspath[INDEX_OF(kb, keyboard)][0] = 0;
443 }
.fi
.SS "void* os_inputmain (void *context)"
os_inputmain is run in a separate thread and will be detached from the main thread, so it needs to clean up its own resources\&.
.PP
\fBTodo\fP
.RS 4
This function is a collection of many tasks\&. It should be divided into several sub-functions for the sake of greater convenience:
.RE
.PP
.PP
.IP "1." 4
set up an URB (Userspace Ressource Buffer) to communicate with the USBDEVFS_* ioctl()s
.IP "2." 4
perform the ioctl()
.IP "3." 4
interpretate the information got into the URB buffer or handle error situations and retry operation or leave the endless loop
.IP "4." 4
inform the os about the data
.IP "5." 4
loop endless via 2\&.
.IP "6." 4
if endless loop has gone, deinitalize the interface, free buffers etc\&.
.IP "7." 4
return null 
.PP
Here the actions in detail:
.PP
Monitor input transfers on all endpoints for non-RGB devices For RGB, monitor all but the last, as it's used for input/output
.PP
Get an usbdevfs_urb data structure and clear it via memset()
.PP
Hopefully the buffer lengths are equal for all devices with congruent types\&. You can find out the correctness for your device with lsusb --v or similar on macOS\&. Currently the following combinations are known and implemented:
.PP
device detect with macro combination endpoint # buffer-length  each none 0 8 RGB Mouse IS_RGB && IS_MOUSE 1 10 RGB Keyboard IS_RGB && !IS_MOUSE 1 21 RGB Mouse or Keyboard IS_RGB 2 MSG_SIZE (64) non RGB Mouse or Keyboard !IS_RGB 1 4 non RGB Mouse or Keyboard !IS_RGB 2 15 
.PP
Now submit all the URBs via ioctl(USBDEVFS_SUBMITURB) with type USBDEVFS_URB_TYPE_INTERRUPT (the endpoints are defined as type interrupt)\&. Endpoint number is 0x80\&.\&.0x82 or 0x83, depending on the model\&.
.PP
The userSpaceFS knows the URBs now, so start monitoring input
.PP
if the ioctl returns something != 0, let's have a deeper look what happened\&. Broken devices or shutting down the entire system leads to closing the device and finishing this thread\&.
.PP
If just an EPIPE ocurred, give the device a CLEAR_HALT and resubmit the URB\&.
.PP
A correct REAPURB returns a Pointer to the URB which we now have a closer look into\&. Lock all following actions with imutex\&.
.PP
Process the input depending on type of device\&. Interprete the actual size of the URB buffer
.PP
device detect with macro combination seems to be endpoint # actual buffer-length function called  mouse (RGB and non RGB) IS_MOUSE nA 8, 10 or 11 \fBhid_mouse_translate()\fP mouse (RGB and non RGB) IS_MOUSE nA MSG_SIZE (64) \fBcorsair_mousecopy()\fP RGB Keyboard IS_RGB && !IS_MOUSE 1 8 (BIOS Mode) \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 2 5 or 21, KB inactive! \fBhid_kb_translate()\fP RGB Keyboard IS_RGB && !IS_MOUSE 3? MSG_SIZE \fBcorsair_kbcopy()\fP non RGB Keyboard !IS_RGB && !IS_MOUSE nA nA \fBhid_kb_translate()\fP 
.PP
The input data is transformed and copied to the kb structure\&. Now give it to the OS and unlock the imutex afterwards\&.
.PP
Re-submit the URB for the next run\&.
.PP
If the endless loop is terminated, clean up by discarding the URBs via ioctl(USBDEVFS_DISCARDURB), free the URB buffers and return a null pointer as thread exit code\&. 
.PP
Definition at line 239 of file usb_linux\&.c\&.
.PP
References usbdevice::active, ckb_err, ckb_info, corsair_kbcopy(), corsair_mousecopy(), devpath, usbdevice::epcount, usbdevice::handle, hid_kb_translate(), hid_mouse_translate(), imutex, INDEX_OF, usbdevice::input, inputupdate(), IS_MOUSE, IS_RGB, keyboard, usbinput::keys, MSG_SIZE, usbdevice::product, usbinput::rel_x, usbinput::rel_y, and usbdevice::vendor\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
239                                  {
240     usbdevice* kb = context;
241     int fd = kb->handle - 1;
242     short vendor = kb->vendor, product = kb->product;
243     int index = INDEX_OF(kb, keyboard);
244     ckb_info("Starting input thread for %s%d\n", devpath, index);
245 
250     int urbcount = IS_RGB(vendor, product) ? (kb->epcount - 1) : kb->epcount;
251     if (urbcount == 0) {
252         ckb_err("urbcount = 0, so there is nothing to claim in os_inputmain()\n");
253         return 0;
254     }
255 
257     struct usbdevfs_urb urbs[urbcount];
258     memset(urbs, 0, sizeof(urbs));
259 
273     urbs[0]\&.buffer_length = 8;
274     if(urbcount > 1 && IS_RGB(vendor, product)) {
275         if(IS_MOUSE(vendor, product))
276             urbs[1]\&.buffer_length = 10;
277         else
278             urbs[1]\&.buffer_length = 21;
279         urbs[2]\&.buffer_length = MSG_SIZE;
280         if(urbcount != 3)
281             urbs[urbcount - 1]\&.buffer_length = MSG_SIZE;
282     } else {
283         urbs[1]\&.buffer_length = 4;
284         urbs[2]\&.buffer_length = 15;
285     }
286 
289     for(int i = 0; i < urbcount; i++){
290         urbs[i]\&.type = USBDEVFS_URB_TYPE_INTERRUPT;
291         urbs[i]\&.endpoint = 0x80 | (i + 1);
292         urbs[i]\&.buffer = malloc(urbs[i]\&.buffer_length);
293         ioctl(fd, USBDEVFS_SUBMITURB, urbs + i);
294     }
295 
297     while (1) {
298         struct usbdevfs_urb* urb = 0;
299 
302         if (ioctl(fd, USBDEVFS_REAPURB, &urb)){
303             if (errno == ENODEV || errno == ENOENT || errno == ESHUTDOWN)
304                 // Stop the thread if the handle closes
305                 break;
306             else if(errno == EPIPE && urb){
308                 ioctl(fd, USBDEVFS_CLEAR_HALT, &urb->endpoint);
309                 // Re-submit the URB
310                 if(urb)
311                     ioctl(fd, USBDEVFS_SUBMITURB, urb);
312                 urb = 0;
313             }
314         }
315 
319         if (urb) {
331             pthread_mutex_lock(imutex(kb));
332             if(IS_MOUSE(vendor, product)){
333                 switch(urb->actual_length){
334                 case 8:
335                 case 10:
336                 case 11:
337                     // HID mouse input
338                     hid_mouse_translate(kb->input\&.keys, &kb->input\&.rel_x, &kb->input\&.rel_y, -(urb->endpoint & 0xF), urb->actual_length, urb->buffer);
339                     break;
340                 case MSG_SIZE:
341                     // Corsair mouse input
342                     corsair_mousecopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
343                     break;
344                 }
345             } else if(IS_RGB(vendor, product)){
346                 switch(urb->actual_length){
347                 case 8:
348                     // RGB EP 1: 6KRO (BIOS mode) input
349                     hid_kb_translate(kb->input\&.keys, -1, urb->actual_length, urb->buffer);
350                     break;
351                 case 21:
352                 case 5:
353                     // RGB EP 2: NKRO (non-BIOS) input\&. Accept only if keyboard is inactive
354                     if(!kb->active)
355                         hid_kb_translate(kb->input\&.keys, -2, urb->actual_length, urb->buffer);
356                     break;
357                 case MSG_SIZE:
358                     // RGB EP 3: Corsair input
359                     corsair_kbcopy(kb->input\&.keys, -(urb->endpoint & 0xF), urb->buffer);
360                     break;
361                 }
362             } else {
363                 // Non-RGB input
364                 hid_kb_translate(kb->input\&.keys, urb->endpoint & 0xF, urb->actual_length, urb->buffer);
365             }
368             inputupdate(kb);
369             pthread_mutex_unlock(imutex(kb));
371             ioctl(fd, USBDEVFS_SUBMITURB, urb);
372             urb = 0;
373         }
374     }
375 
379     ckb_info("Stopping input thread for %s%d\n", devpath, index);
380     for(int i = 0; i < urbcount; i++){
381         ioctl(fd, USBDEVFS_DISCARDURB, urbs + i);
382         free(urbs[i]\&.buffer);
383     }
384     return 0;
385 }
.fi
.SS "int os_resetusb (\fBusbdevice\fP *kb, const char *file, intline)"
os_resetusb is the os specific implementation for resetting usb
.PP
Try to reset an usb device in a linux user space driver\&.
.IP "1." 4
unclaim the device, but do not reconnect the system driver (second param resetting = true)
.IP "2." 4
reset the device via USBDEVFS_RESET command
.IP "3." 4
claim the device again\&. Returns 0 on success, -2 if device should be removed and -1 if reset should by tried again
.PP
.PP
\fBTodo\fP
.RS 4
it seems that no one wants to try the reset again\&. But I'v seen it somewhere\&.\&.\&. 
.RE
.PP

.PP
Definition at line 495 of file usb_linux\&.c\&.
.PP
References usbdevice::handle, TEST_RESET, usbclaim(), and usbunclaim()\&.
.PP
Referenced by _resetusb()\&.
.PP
.nf
495                                                            {
496     TEST_RESET(usbunclaim(kb, 1));
497     TEST_RESET(ioctl(kb->handle - 1, USBDEVFS_RESET));
498     TEST_RESET(usbclaim(kb));
499     // Success!
500     return 0;
501 }
.fi
.SS "void os_sendindicators (\fBusbdevice\fP *kb)"
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
os_sendindicators update the indicators for the special keys (Numlock, Capslock and what else?)
.PP
Read the data from kb->ileds ans send them via ioctl() to the keyboard\&.
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 Interface 0 MSG_SIZE 1 Byte timeout 0,5ms the message buffer pointer Host to Device, Type=Class, Recipient=Interface (why not endpoint?) 9 = SEND? specific 0 1 500 struct* kb->ileds 
.br
 The ioctl command is USBDEVFS_CONTROL\&. 
.PP
Definition at line 214 of file usb_linux\&.c\&.
.PP
References ckb_err, usbdevice::handle, usbdevice::ileds, and usb_tryreset()\&.
.PP
Referenced by updateindicators_kb()\&.
.PP
.nf
214                                       {
215     static int countForReset = 0;
216     struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, 0x00, 1, 500, &kb->ileds };
217     int res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
218     if(res <= 0) {
219         ckb_err("%s\n", res ? strerror(errno) : "No data written");
220         if (usb_tryreset(kb) == 0 && countForReset++ < 3) {
221             os_sendindicators(kb);
222         }
223     }
224 }
.fi
.SS "int os_setupusb (\fBusbdevice\fP *kb)"
os_setupusb OS-specific setup for a specific usb device\&.
.PP
Perform the operating system-specific opening of the interface in \fBos_setupusb()\fP\&. As a result, some parameters should be set in kb (name, serial, fwversion, epcount = number of usb endpoints), and all endpoints should be claimed with \fBusbclaim()\fP\&. Claiming is the only point where \fBos_setupusb()\fP can produce an error (-1)\&. 
.IP "\(bu" 2
Copy device description and serial
.IP "\(bu" 2
Copy firmware version (needed to determine USB protocol)
.IP "\(bu" 2
Do some output abaout connecting interfaces
.IP "\(bu" 2
Claim the USB interfaces
.PP
.PP
\fBTodo\fP
.RS 4
in these modules a pullrequest is outstanding 
.RE
.PP
.PP
< Try to reset the device and recall the function
.PP
< Don't do this endless in recursion
.PP
< \fBos_setupusb()\fP has a return value (used as boolean) 
.PP
Definition at line 533 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, devpath, usbdevice::epcount, usbdevice::fwversion, INDEX_OF, KB_NAME_LEN, keyboard, usbdevice::name, usbdevice::serial, SERIAL_LEN, strtrim(), usbdevice::udev, usb_tryreset(), and usbclaim()\&.
.PP
Referenced by _setupusb()\&.
.PP
.nf
533                                {
536     struct udev_device* dev = kb->udev;
537     const char* name = udev_device_get_sysattr_value(dev, "product");
538     if(name)
539         strncpy(kb->name, name, KB_NAME_LEN);
540     strtrim(kb->name);
541     const char* serial = udev_device_get_sysattr_value(dev, "serial");
542     if(serial)
543         strncpy(kb->serial, serial, SERIAL_LEN);
544     strtrim(kb->serial);
547     const char* firmware = udev_device_get_sysattr_value(dev, "bcdDevice");
548     if(firmware)
549         sscanf(firmware, "%hx", &kb->fwversion);
550     else
551         kb->fwversion = 0;
552     int index = INDEX_OF(kb, keyboard);
555     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
556 
562     const char* ep_str = udev_device_get_sysattr_value(dev, "bNumInterfaces");
563 #ifdef DEBUG
564     ckb_info("Connecting %s at %s%d\n", kb->name, devpath, index);
565     ckb_info("claiming interfaces\&. name=%s, serial=%s, firmware=%s; Got >>%s<< as ep_str\n", name, serial, firmware, ep_str);
566 #endif //DEBUG
567     kb->epcount = 0;
568     if(ep_str)
569         sscanf(ep_str, "%d", &kb->epcount);
570     if(kb->epcount < 2){
571         // IF we have an RGB KB with 0 or 1 endpoints, it will be in BIOS mode\&.
572         ckb_err("Unable to read endpoint count from udev, assuming %d and reading >>%s<< or device is in BIOS mode\n", kb->epcount, ep_str);
573         if (usb_tryreset(kb) == 0) { 
574             static int retryCount = 0; 
575             if (retryCount++ < 5) {
576                 return os_setupusb(kb); 
577             }
578         }
579         return -1;
580         // ToDo are there special versions we have to detect? If there are, that was the old code to handle it:
581         // This shouldn't happen, but if it does, assume EP count based onckb_warn what the device is supposed to have
582         // kb->epcount = (HAS_FEATURES(kb, FEAT_RGB) ? 4 : 3);
583         // ckb_warn("Unable to read endpoint count from udev, assuming %d and reading >>%s<<\&.\&.\&.\n", kb->epcount, ep_str);
584     }
585     if(usbclaim(kb)){
586         ckb_err("Failed to claim interfaces: %s\n", strerror(errno));
587         return -1;
588     }
589     return 0;
590 }
.fi
.SS "int os_usbrecv (\fBusbdevice\fP *kb, \fBuchar\fP *in_msg, const char *file, intline)"
os_usbrecv does what its name says:
.PP
The comment at the beginning of the procedure causes the suspicion that the firmware versionspecific distinction is missing for receiving from usb endpoint 3 or 4\&. The commented code contains only the reception from EP4, but this may be wrong for a software version 2\&.0 or higher (see the code for os-usbsend ())\&.
.PP

.br
 So all the receiving is done via an ioctl() like in os_usbsend\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0xA1 0x01 0x0200 endpoint to be addressed from epcount - 1 MSG_SIZE 5ms the message buffer pointer Device to Host, Type=Class, Recipient=Interface 1 = RECEIVE? specific Interface # 64 5000 in_msg The ioctl() returns the number of bytes received\&. Here is the usual check again:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbrecv()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes are received, 0 is returned as an identifier for a heavy error\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes received\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Read YY bytes (expected 64)']\&. 
.PP
Definition at line 129 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv()\&.
.PP
.nf
129                                                                         {
130     int res;
131     // This is what CUE does, but it doesn't seem to work on linux\&.
132     /*if(kb->fwversion >= 0x130){
133         struct usbdevfs_bulktransfer transfer;
134         memset(&transfer, 0, sizeof(transfer));
135         transfer\&.ep = 0x84;
136         transfer\&.len = MSG_SIZE;
137         transfer\&.timeout = 5000;
138         transfer\&.data = in_msg;
139         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
140     } else {*/
141         struct usbdevfs_ctrltransfer transfer = { 0xa1, 0x01, 0x0300, kb->epcount - 1, MSG_SIZE, 5000, in_msg };
142         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
143     //}
144     if(res <= 0){
145         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data read");
146         if(res == -1 && errno == ETIMEDOUT)
147             return -1;
148         else
149             return 0;
150     } else if(res != MSG_SIZE)
151         ckb_warn_fn("Read %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
152 #ifdef DEBUG_USB_RECV
153     char converted[MSG_SIZE*3 + 1];
154     for(int i=0;i<MSG_SIZE;i++)
155         sprintf(&converted[i*3], "%02x ", in_msg[i]);
156     ckb_warn_fn("Recv %s\n", file, line, converted);
157 #endif
158     return res;
159 }
.fi
.SS "int os_usbsend (\fBusbdevice\fP *kb, const \fBuchar\fP *out_msg, intis_recv, const char *file, intline)"
os_usbsend has two functions:
.IP "\(bu" 2
if is_recv == false, it tries to send a given MSG_SIZE buffer via the usb interface given with kb\&.
.IP "\(bu" 2
otherwise a request is sent via the usb device to initiate the receiving of a message from the remote device\&.
.PP
.PP
The functionality for sending distinguishes two cases, depending on the version number of the firmware of the connected device: 
.br
 If the firmware is less or equal 1\&.2, the transmission is done via an ioctl()\&. The ioctl() is given a struct usbdevfs_ctrltransfer, in which the relevant parameters are entered:
.PP
bRequestType bRequest wValue EP size Timeout data  0x21 0x09 0x0200 endpoint / IF to be addressed from epcount-1 MSG_SIZE 5000 (=5ms) the message buffer pointer Host to Device, Type=Class, Recipient=Interface 9 = Send data? specific last or pre-last device # 64 5000 out_msg 
.br
 The ioctl command is USBDEVFS_CONTROL\&.
.PP
The same constellation is used if the device is requested to send its data (is_recv = true)\&.
.PP
For a more recent firmware and is_recv = false, the ioctl command USBDEVFS_CONTROL is not used (this tells the bus to enter the control mode), but the bulk method is used: USBDEVFS_BULK\&. This is astonishing, because all of the endpoints are type Interrupt, not bulk\&.
.PP
Anyhow, forthis purpose a different structure is used for the ioctl() (struct \fBusbdevfs_bulktransfer\fP) and this is also initialized differently: 
.br
 The length and timeout parameters are given the same values as above\&. The formal parameter out_msg is also passed as a buffer pointer\&. For the endpoints, the firmware version is differentiated again: 
.br
 For a firmware version between 1\&.3 and <2\&.0 endpoint 4 is used, otherwise (it can only be >=2\&.0) endpoint 3 is used\&.
.PP
\fBTodo\fP
.RS 4
Since the handling of endpoints has already led to problems elsewhere, this implementation is extremely hardware-dependent and critical! 
.br
 Eg\&. the new keyboard K95PLATINUMRGB has a version number significantly less than 2\&.0 - will it run with this implementation?
.RE
.PP
.PP
The ioctl() - no matter what type - returns the number of bytes sent\&. Now comes the usual check:
.IP "\(bu" 2
If the return value is -1 AND the error is a timeout (ETIMEOUT), \fBos_usbsend()\fP will return -1 to indicate that it is probably a recoverable problem and a retry is recommended\&.
.IP "\(bu" 2
For another negative value or other error identifier OR 0 bytes sent, 0 is returned as a heavy error identifier\&.
.IP "\(bu" 2
In all other cases, the function returns the number of bytes sent\&.
.PP
.PP
If this is not the entire blocksize (MSG_SIZE bytes), an error message is issued on the standard error channel [warning 'Wrote YY bytes (expected 64)']\&.
.PP
If DEBUG_USB is set during compilation, the number of bytes sent and their representation are logged to the error channel\&. 
.PP
Definition at line 68 of file usb_linux\&.c\&.
.PP
References ckb_err_fn, ckb_warn_fn, usbdevice::epcount, usbdevice::fwversion, usbdevice::handle, and MSG_SIZE\&.
.PP
Referenced by _usbrecv(), and _usbsend()\&.
.PP
.nf
68                                                                                             {
69     int res;
70     if(kb->fwversion >= 0x120 && !is_recv){
71         struct usbdevfs_bulktransfer transfer;
72         memset(&transfer, 0, sizeof(transfer));
73         transfer\&.ep = (kb->fwversion >= 0x130 && kb->fwversion < 0x200) ? 4 : 3;
74         transfer\&.len = MSG_SIZE;
75         transfer\&.timeout = 5000;
76         transfer\&.data = (void*)out_msg;
77         res = ioctl(kb->handle - 1, USBDEVFS_BULK, &transfer);
78     } else {
79         struct usbdevfs_ctrltransfer transfer = { 0x21, 0x09, 0x0200, kb->epcount - 1, MSG_SIZE, 5000, (void*)out_msg };
80         res = ioctl(kb->handle - 1, USBDEVFS_CONTROL, &transfer);
81     }
82     if(res <= 0){
83         ckb_err_fn("%s\n", file, line, res ? strerror(errno) : "No data written");
84         if(res == -1 && errno == ETIMEDOUT)
85             return -1;
86         else
87             return 0;
88     } else if(res != MSG_SIZE)
89         ckb_warn_fn("Wrote %d bytes (expected %d)\n", file, line, res, MSG_SIZE);
90 #ifdef DEBUG_USB
91     char converted[MSG_SIZE*3 + 1];
92     for(int i=0;i<MSG_SIZE;i++)
93         sprintf(&converted[i*3], "%02x ", out_msg[i]);
94     ckb_warn_fn("Sent %s\n", file, line, converted);
95 #endif
96     return res;
97 }
.fi
.SS "void strtrim (char *string)"
strtrim trims a string by removing leading and trailing spaces\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP 
.RE
.PP

.PP
Definition at line 508 of file usb_linux\&.c\&.
.PP
Referenced by os_setupusb()\&.
.PP
.nf
508                           {
509     // Find last non-space
510     char* last = string;
511     for(char* c = string; *c != 0; c++){
512         if(!isspace(*c))
513             last = c;
514     }
515     last[1] = 0;
516     // Find first non-space
517     char* first = string;
518     for(; *first != 0; first++){
519         if(!isspace(*first))
520             break;
521     }
522     if(first != string)
523         memmove(string, first, last - first);
524 }
.fi
.SS "static void udev_enum ()\fC [static]\fP"
Reduce the hits of the enumeration by limiting to usb as technology and corsair as idVendor\&. Then filter with udev_enumerate_scan_devices () all hits\&.
.PP
The following call to udev_enumerate_get_list_entry() fetches the entire hitlist as udev_list_entry *\&. 
.br
 Use udev_list_entry_foreach() to iterate through the hit set\&. 
.br
 If both the device name exists (udev_list_entry_get_name) and the subsequent creation of a new udev_device (udev_device_new_from_syspath) is ok, the new device is added to the list with \fBusb_add_device()\fP\&.
.PP
If the latter does not work, the new device is released again (udev_device_unref ())\&. 
.br
 After the last iteration, the enumerator is released with udev_enumerate_unref ()\&. 
.PP
Definition at line 746 of file usb_linux\&.c\&.
.PP
References usb_add_device(), and V_CORSAIR_STR\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
746                        {
747     struct udev_enumerate* enumerator = udev_enumerate_new(udev);
748     udev_enumerate_add_match_subsystem(enumerator, "usb");
749     udev_enumerate_add_match_sysattr(enumerator, "idVendor", V_CORSAIR_STR);
750     udev_enumerate_scan_devices(enumerator);
751     struct udev_list_entry* devices, *dev_list_entry;
752     devices = udev_enumerate_get_list_entry(enumerator);
753 
754     udev_list_entry_foreach(dev_list_entry, devices){
755         const char* path = udev_list_entry_get_name(dev_list_entry);
756         if(!path)
757             continue;
758         struct udev_device* dev = udev_device_new_from_syspath(udev, path);
759         if(!dev)
760             continue;
761         // If the device matches a recognized device ID, open it
762         if(usb_add_device(dev))
763             // Release device if not
764             udev_device_unref(dev);
765     }
766     udev_enumerate_unref(enumerator);
767 }
.fi
.SS "static int usb_add_device (struct udev_device *dev)\fC [static]\fP"
If the device id can be found, call \fBusbadd()\fP with the appropriate parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the retval of \fBusbadd()\fP or 1 if either vendor is not corsair or product is not mentioned in model[]\&.
.RE
.PP
First get the idVendor via udev_device_get_sysattr_value()\&. If this is equal to the ID-string of corsair ('1b1c'), get the idProduct on the same way\&. 
.br
 If we can find the model name in the model array, call \fBusbadd()\fP with the model number\&. 
.PP
\fBTodo\fP
.RS 4
So why the hell not a transformation between the string and the short presentation? Lets check if the string representation is used elsewhere\&. 
.RE
.PP

.PP
Definition at line 694 of file usb_linux\&.c\&.
.PP
References N_MODELS, usbadd(), V_CORSAIR, and V_CORSAIR_STR\&.
.PP
Referenced by udev_enum(), and usbmain()\&.
.PP
.nf
694                                                   {
695     const char* vendor = udev_device_get_sysattr_value(dev, "idVendor");
696     if(vendor && !strcmp(vendor, V_CORSAIR_STR)){
697         const char* product = udev_device_get_sysattr_value(dev, "idProduct");
698         if(product){
699             for(_model* model = models; model < models + N_MODELS; model++){
700                 if(!strcmp(product, model->name)){
701                     return usbadd(dev, V_CORSAIR, model->number);
702                 }
703             }
704         }
705     }
706     return 1;
707 }
.fi
.SS "static void usb_rm_device (struct udev_device *dev)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIdev\fP the functions usb_*_device get a struct udev* with the neccessary hardware-related information\&.
.RE
.PP
First try to find the system path of the device given in parameter dev\&. The index where the name is found is the same index we need to address the global keyboard array\&. That array holds all usbdevices\&. 
.br
 Searching for the correct name in kbsyspath-array and closing the usb via \fBcloseusb()\fP are protected by lock\&.\&.unlock of the corresponding devmutex arraymember\&. 
.PP
Definition at line 719 of file usb_linux\&.c\&.
.PP
References closeusb(), DEV_MAX, devmutex, kbsyspath, and keyboard\&.
.PP
Referenced by usbmain()\&.
.PP
.nf
719                                                   {
720     // Device removed\&. Look for it in our list of keyboards
721     const char* syspath = udev_device_get_syspath(dev);
722     if(!syspath || syspath[0] == 0)
723         return;
724     for(int i = 1; i < DEV_MAX; i++){
725         pthread_mutex_lock(devmutex + i);
726         if(!strcmp(syspath, kbsyspath[i]))
727             closeusb(keyboard + i);
728         pthread_mutex_unlock(devmutex + i);
729     }
730 }
.fi
.SS "int usbadd (struct udev_device *dev, shortvendor, shortproduct)"

.PP
Definition at line 592 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, DEV_MAX, dmutex, usbdevice::handle, IS_CONNECTED, kbsyspath, keyboard, usbdevice::product, setupusb(), usbdevice::udev, and usbdevice::vendor\&.
.PP
Referenced by usb_add_device()\&.
.PP
.nf
592                                                                  {
593     const char* path = udev_device_get_devnode(dev);
594     const char* syspath = udev_device_get_syspath(dev);
595     if(!path || !syspath || path[0] == 0 || syspath[0] == 0){
596         ckb_err("Failed to get device path\n");
597         return -1;
598     }
599 #ifdef DEBUG
600     ckb_info(">>>vendor = 0x%x, product = 0x%x, path = %s, syspath = %s\n", vendor, product, path, syspath);
601 #endif // DEDBUG
602     // Find a free USB slot
603     for(int index = 1; index < DEV_MAX; index++){
604         usbdevice* kb = keyboard + index;
605         if(pthread_mutex_trylock(dmutex(kb))){
606             // If the mutex is locked then the device is obviously in use, so keep going
607             if(!strcmp(syspath, kbsyspath[index])){
608                 // Make sure this existing keyboard doesn't have the same syspath (this shouldn't happen)
609                 return 0;
610             }
611             continue;
612         }
613         if(!IS_CONNECTED(kb)){
614             // Open the sysfs device
615             kb->handle = open(path, O_RDWR) + 1;
616             if(kb->handle <= 0){
617                 ckb_err("Failed to open USB device: %s\n", strerror(errno));
618                 kb->handle = 0;
619                 pthread_mutex_unlock(dmutex(kb));
620                 return -1;
621             } else {
622                 // Set up device
623                 kb->udev = dev;
624                 kb->vendor = vendor;
625                 kb->product = product;
626                 strncpy(kbsyspath[index], syspath, FILENAME_MAX);
627                 // Mutex remains locked
628                 setupusb(kb);
629                 return 0;
630             }
631         }
632         pthread_mutex_unlock(dmutex(kb));
633     }
634     ckb_err("No free devices\n");
635     return -1;
636 }
.fi
.SS "static int usbclaim (\fBusbdevice\fP *kb)\fC [static]\fP"
usbclaim does claiming all EPs for the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 otherwise\&.
.RE
.PP
Claim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCONNECT) and ioctl(USBDEVFS_CLAIMINTERFACE)\&.
.PP
Error handling is done for the ioctl(USBDEVFS_CLAIMINTERFACE) only\&. If this fails, now an error message is thrown and -1 is returned\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 457 of file usb_linux\&.c\&.
.PP
References ckb_err, ckb_info, usbdevice::epcount, and usbdevice::handle\&.
.PP
Referenced by os_resetusb(), and os_setupusb()\&.
.PP
.nf
457                                   {
458     int count = kb->epcount;
459 #ifdef DEBUG
460     ckb_info("claiming %d endpoints\n", count);
461 #endif // DEBUG
462 
463     for(int i = 0; i < count; i++){
464         struct usbdevfs_ioctl ctl = { i, USBDEVFS_DISCONNECT, 0 };
465         ioctl(kb->handle - 1, USBDEVFS_IOCTL, &ctl);
466         if(ioctl(kb->handle - 1, USBDEVFS_CLAIMINTERFACE, &i)) {
467             ckb_err("Failed to claim interface %d: %s\n", i, strerror(errno));
468             return -1;
469         }
470     }
471     return 0;
472 }
.fi
.SS "void usbkill ()"

.PP
Definition at line 834 of file usb_linux\&.c\&.
.PP
Referenced by quitWithLock()\&.
.PP
.nf
834               {
835     udev_unref(udev);
836     udev = 0;
837 }
.fi
.SS "int usbmain ()"
Start the USB main loop\&. Returns program exit code when finished\&.
.PP
usbmain is called by \fBmain()\fP after setting up all other stuff\&. 
.PP
\fBReturns:\fP
.RS 4
0 normally or -1 if fatal error occurs (up to now only if no new devices are available) 
.RE
.PP
First check whether the uinput module is loaded by the kernel\&. 
.PP
\fBTodo\fP
.RS 4
Why isn't missing of uinput a fatal error? 
.RE
.PP
.PP
Create the udev object with udev_new() (is a function from libudev\&.h) terminate -1 if error
.PP
Enumerate all currently connected devices
.PP
\fBTodo\fP
.RS 4
lae\&. here the work has to go on\&.\&.\&. 
.RE
.PP

.PP
Definition at line 774 of file usb_linux\&.c\&.
.PP
References ckb_fatal, ckb_warn, udev_enum(), usb_add_device(), and usb_rm_device()\&.
.PP
Referenced by main()\&.
.PP
.nf
774              {
779     // Load the uinput module (if it's not loaded already)
780     if(system("modprobe uinput") != 0)
781         ckb_warn("Failed to load uinput module\n");
782 
786     if(!(udev = udev_new())) {
787         ckb_fatal("Failed to initialize udev in usbmain(), usb_linux\&.c\n");
788         return -1;
789     }
790 
793     udev_enum();
794 
797     // Done scanning\&. Enter a loop to poll for device updates
798     struct udev_monitor* monitor = udev_monitor_new_from_netlink(udev, "udev");
799     udev_monitor_filter_add_match_subsystem_devtype(monitor, "usb", 0);
800     udev_monitor_enable_receiving(monitor);
801     // Get an fd for the monitor
802     int fd = udev_monitor_get_fd(monitor);
803     fd_set fds;
804     while(udev){
805         FD_ZERO(&fds);
806         FD_SET(fd, &fds);
807         // Block until an event is read
808         if(select(fd + 1, &fds, 0, 0, 0) > 0 && FD_ISSET(fd, &fds)){
809             struct udev_device* dev = udev_monitor_receive_device(monitor);
810             if(!dev)
811                 continue;
812             const char* action = udev_device_get_action(dev);
813             if(!action){
814                 udev_device_unref(dev);
815                 continue;
816             }
817             // Add/remove device
818             if(!strcmp(action, "add")){
819                 int res = usb_add_device(dev);
820                 if(res == 0)
821                     continue;
822                 // If the device matched but the handle wasn't opened correctly, re-enumerate (this sometimes solves the problem)
823                 if(res == -1)
824                     udev_enum();
825             } else if(!strcmp(action, "remove"))
826                 usb_rm_device(dev);
827             udev_device_unref(dev);
828         }
829     }
830     udev_monitor_unref(monitor);
831     return 0;
832 }
.fi
.SS "static int usbunclaim (\fBusbdevice\fP *kb, intresetting)\fC [static]\fP"
usbunclaim do an unclaiming of the usb device gicen by kb\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkb\fP THE usbdevice* 
.br
\fIresetting\fP boolean flag: If resseting is true, the caller will perform a bus reset command after unclaiming the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
always 0\&.
.RE
.PP
Unclaim all endpoints for a given device (remeber the decrementing of the file descriptor) via ioctl(USBDEVFS_DISCARDURB)\&.
.PP
Afterwards - if ressetting is false - do a USBDEVFS_CONNECT for EP 0 and 1\&. If it is a non RGB device, connect EP 2 also\&. The comment mentions RGB keyboards only, but as I understand the code, this is valid also for RGB mice\&.
.PP
There is no error handling yet\&. Function is called in \fBusb_linux\&.c\fP only, so it is declared as static now\&. 
.PP
Definition at line 404 of file usb_linux\&.c\&.
.PP
References usbdevice::epcount, FEAT_RGB, usbdevice::handle, and HAS_FEATURES\&.
.PP
Referenced by os_closeusb(), and os_resetusb()\&.
.PP
.nf
404                                                     {
405     int handle = kb->handle - 1;
406     int count = kb->epcount;
407     for (int i = 0; i < count; i++) {
408         ioctl(handle, USBDEVFS_RELEASEINTERFACE, &i);
409     }
410     // For RGB keyboards, the kernel driver should only be reconnected to interfaces 0 and 1 (HID), and only if we're not about to do a USB reset\&.
411     // Reconnecting any of the others causes trouble\&.
412     if (!resetting) {
413         struct usbdevfs_ioctl ctl = { 0, USBDEVFS_CONNECT, 0 };
414         ioctl(handle, USBDEVFS_IOCTL, &ctl);
415         ctl\&.ifno = 1;
416         ioctl(handle, USBDEVFS_IOCTL, &ctl);
417         // Also reconnect iface #2 (HID) for non-RGB keyboards
418         if(!HAS_FEATURES(kb, FEAT_RGB)){
419             ctl\&.ifno = 2;
420             ioctl(handle, USBDEVFS_IOCTL, &ctl);
421         }
422     }
423     return 0;
424 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char kbsyspath[9][FILENAME_MAX]\fC [static]\fP"

.PP
Definition at line 13 of file usb_linux\&.c\&.
.PP
Referenced by os_closeusb(), usb_rm_device(), and usbadd()\&.
.SS "\fB_model\fP models[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
    
    {  "1b17" ,  0x1b17  },
    {  "1b07" ,  0x1b07  },
    {  "1b37" ,  0x1b37  },
    {  "1b39" ,  0x1b39  },
    {  "1b13" ,  0x1b13  },
    {  "1b09" ,  0x1b09  },
    {  "1b33" ,  0x1b33  },
    {  "1b36" ,  0x1b36  },
    {  "1b38" ,  0x1b38  },
    {  "1b3a" ,  0x1b3a  },
    {  "1b11" ,  0x1b11  },
    {  "1b08" ,  0x1b08  },
    {  "1b2d" ,  0x1b2d  },
    {  "1b20" ,  0x1b20  },
    {  "1b15" ,  0x1b15  },
    
    {  "1b12" ,  0x1b12  },
    {  "1b2e" ,  0x1b2e  },
    {  "1b14" ,  0x1b14   },
    {  "1b19" ,  0x1b19   },
    {  "1b2f" ,  0x1b2f   },
    {  "1b1e" ,  0x1b1e  },
    {  "1b3e" ,  0x1b3e  },
    {  "1b32" ,  0x1b32   }
}
.fi

.PP
\fBAttention:\fP
.RS 4
when adding new hardware this file hat to be changed too\&.
.RE
.PP
In this structure array \fImodels\fP[] for each device the name (the device id as string in hex without leading 0x) and its usb device id as short must be entered in this array\&. 
.PP
Definition at line 654 of file usb_linux\&.c\&.
.SS "struct udev* udev\fC [static]\fP"

.PP
Definition at line 638 of file usb_linux\&.c\&.
.SS "pthread_t udevthread"

.PP
Definition at line 641 of file usb_linux\&.c\&.
.SS "pthread_t usbthread"

.PP
\fBTodo\fP
.RS 4
These two thread vasriables seem to be unused: usbtread, udevthread 
.RE
.PP

.PP
Definition at line 641 of file usb_linux\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
