.TH "src/ckb-daemon/device_keyboard.c" 3 "Sat Jun 3 2017" "Version beta-v0.2.8+testing at branch testing-documentation" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/device_keyboard.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'command\&.h'\fP
.br
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'firmware\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br
\fC#include 'usb\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBstart_kb_nrgb\fP (\fBusbdevice\fP *kb, int makeactive)"
.br
.ti -1c
.RI "int \fBsetactive_kb\fP (\fBusbdevice\fP *kb, int active)"
.br
.ti -1c
.RI "int \fBcmd_active_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_idle_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "void \fBsetmodeindex_nrgb\fP (\fBusbdevice\fP *kb, int index)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int cmd_active_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 112 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
112                                                                                              {
113     return setactive_kb(kb, 1);
114 }
.fi
.SS "int cmd_idle_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 116 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
116                                                                                            {
117     return setactive_kb(kb, 0);
118 }
.fi
.SS "int setactive_kb (\fBusbdevice\fP *kb, intactive)"

.PP
Definition at line 18 of file device_keyboard\&.c\&.
.PP
References ACT_LIGHT, ACT_LOCK, ACT_M1, ACT_M2, ACT_M3, ACT_MR_RING, usbdevice::active, DELAY_MEDIUM, lighting::forceupdate, imutex, IN_CORSAIR, IN_HID, usbdevice::input, inputupdate(), keymap, usbinput::keys, usbprofile::lastlight, MSG_SIZE, N_KEYS_HW, NEEDS_FW_UPDATE, usbdevice::profile, usbsend, and usbdevice::vtable\&.
.PP
Referenced by cmd_active_kb(), and cmd_idle_kb()\&.
.PP
.nf
18                                            {
19     if(NEEDS_FW_UPDATE(kb))
20         return 0;
21 
22     pthread_mutex_lock(imutex(kb));
23     kb->active = !!active;
24     kb->profile->lastlight\&.forceupdate = 1;
25     // Clear input
26     memset(&kb->input\&.keys, 0, sizeof(kb->input\&.keys));
27     inputupdate(kb);
28     pthread_mutex_unlock(imutex(kb));
29 
30     uchar msg[3][MSG_SIZE] = {
31         { 0x07, 0x04, 0 },                  // Disables or enables HW control for top row
32         { 0x07, 0x40, 0 },                  // Selects key input
33         { 0x07, 0x05, 2, 0, 0x03, 0x00 }    // Commits key input selection
34     };
35     if(active){
36         // Put the M-keys (K95) as well as the Brightness/Lock keys into software-controlled mode\&.
37         msg[0][2] = 2;
38         if(!usbsend(kb, msg[0], 1))
39             return -1;
40         DELAY_MEDIUM(kb);
41         // Set input mode on the keys\&. They must be grouped into packets of 60 bytes (+ 4 bytes header)
42         // Keys are referenced in byte pairs, with the first byte representing the key and the second byte representing the mode\&.
43         for(int key = 0; key < N_KEYS_HW; ){
44             int pair;
45             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
46                 // Select both standard and Corsair input\&. The standard input will be ignored except in BIOS mode\&.
47                 uchar action = IN_HID | IN_CORSAIR;
48                 // Additionally, make MR activate the MR ring (this is disabled for now, may be back later)
49                 //if(keymap[key]\&.name && !strcmp(keymap[key]\&.name, "mr"))
50                 //    action |= ACT_MR_RING;
51                 msg[1][4 + pair * 2] = key;
52                 msg[1][5 + pair * 2] = action;
53             }
54             // Byte 2 = pair count (usually 30, less on final message)
55             msg[1][2] = pair;
56             if(!usbsend(kb, msg[1], 1))
57                 return -1;
58         }
59         // Commit new input settings
60         if(!usbsend(kb, msg[2], 1))
61             return -1;
62         DELAY_MEDIUM(kb);
63     } else {
64         // Set the M-keys back into hardware mode, restore hardware RGB profile\&. It has to be sent twice for some reason\&.
65         msg[0][2] = 1;
66         if(!usbsend(kb, msg[0], 1))
67             return -1;
68         DELAY_MEDIUM(kb);
69         if(!usbsend(kb, msg[0], 1))
70             return -1;
71         DELAY_MEDIUM(kb);
72 #ifdef OS_LINUX
73         // On OSX the default key mappings are fine\&. On Linux, the G keys will freeze the keyboard\&. Set the keyboard entirely to HID input\&.
74         for(int key = 0; key < N_KEYS_HW; ){
75             int pair;
76             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
77                 uchar action = IN_HID;
78                 // Enable hardware actions
79                 if(keymap[key]\&.name){
80                     if(!strcmp(keymap[key]\&.name, "mr"))
81                         action = ACT_MR_RING;
82                     else if(!strcmp(keymap[key]\&.name, "m1"))
83                         action = ACT_M1;
84                     else if(!strcmp(keymap[key]\&.name, "m2"))
85                         action = ACT_M2;
86                     else if(!strcmp(keymap[key]\&.name, "m3"))
87                         action = ACT_M3;
88                     else if(!strcmp(keymap[key]\&.name, "light"))
89                         action = ACT_LIGHT;
90                     else if(!strcmp(keymap[key]\&.name, "lock"))
91                         action = ACT_LOCK;
92                 }
93                 msg[1][4 + pair * 2] = key;
94                 msg[1][5 + pair * 2] = action;
95             }
96             // Byte 2 = pair count (usually 30, less on final message)
97             msg[1][2] = pair;
98             if(!usbsend(kb, msg[1], 1))
99                 return -1;
100         }
101         // Commit new input settings
102         if(!usbsend(kb, msg[2], 1))
103             return -1;
104         DELAY_MEDIUM(kb);
105 #endif
106     }
107     // Update indicator LEDs if the profile contains settings for them
108     kb->vtable->updateindicators(kb, 0);
109     return 0;
110 }
.fi
.SS "void setmodeindex_nrgb (\fBusbdevice\fP *kb, intindex)"

.PP
Definition at line 120 of file device_keyboard\&.c\&.
.PP
References NK95_M1, NK95_M2, NK95_M3, and nk95cmd\&.
.PP
.nf
120                                                 {
121     switch(index % 3){
122     case 0:
123         nk95cmd(kb, NK95_M1);
124         break;
125     case 1:
126         nk95cmd(kb, NK95_M2);
127         break;
128     case 2:
129         nk95cmd(kb, NK95_M3);
130         break;
131     }
132 }
.fi
.SS "int start_kb_nrgb (\fBusbdevice\fP *kb, intmakeactive)"

.PP
Definition at line 9 of file device_keyboard\&.c\&.
.PP
References usbdevice::active, NK95_HWOFF, nk95cmd, and usbdevice::pollrate\&.
.PP
.nf
9                                                 {
10     // Put the non-RGB K95 into software mode\&. Nothing else needs to be done hardware wise
11     nk95cmd(kb, NK95_HWOFF);
12     // Fill out RGB features for consistency, even though the keyboard doesn't have them
13     kb->active = 1;
14     kb->pollrate = -1;
15     return 0;
16 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
