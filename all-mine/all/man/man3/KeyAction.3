.TH "KeyAction" 3 "Tue May 16 2017" "Version beta-v0.2.7 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KeyAction \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/keyaction\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBType\fP { \fBUNBOUND\fP, \fBNORMAL\fP, \fBSPECIAL\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyAction\fP (const QString &action, \fBQObject\fP *parent=0)"
.br
.ti -1c
.RI "QString \fBvalue\fP () const "
.br
.ti -1c
.RI "\fBoperator QString\fP () const "
.br
.ti -1c
.RI "\fBKeyAction\fP (\fBQObject\fP *parent=0)"
.br
.ti -1c
.RI "QString \fBfriendlyName\fP (const \fBKeyMap\fP &map) const "
.br
.ti -1c
.RI "QString \fBdriverName\fP () const "
.br
.ti -1c
.RI "QString \fBmacroFullLine\fP () const "
.br
.RI "\fImacroFullLine If a macro command and a macro definition exists for the given key, returns the complete string except the leading '$' (the $ may confuse some caller)\&. \fP"
.ti -1c
.RI "bool \fBisValidMacro\fP () const "
.br
.RI "\fIisValidMacro checks whether a keyAction contains a valid macro\&. This is done easily: If the macro action starts with $macro: and has five elements, delimited by ':', we may assume, that is a structural correct macro action\&. If it has 4 entries only, it is an older definition and ok also\&. \fP"
.ti -1c
.RI "QStringList \fBmacroLine\fP () const "
.br
.RI "\fImacroLine returns all interresting content for a macro definition\&. \fP"
.ti -1c
.RI "QString \fBmacroContent\fP () const "
.br
.RI "\fImacroContent returns the macro key definition only (the second part of the macro action)\&. \fP"
.ti -1c
.RI "QString \fBmacroTiming\fP () const "
.br
.RI "\fImacroTiming returns the macro key definition with original timing infos (the fifth and up to now last part of the macro action)\&. If the implementation does not know anything about delays and has no 5th part, return first part\&. \fP"
.ti -1c
.RI "void \fBmacroDisplay\fP ()"
.br
.RI "\fIDebug output for invalid macro Definitions\&. \fP"
.ti -1c
.RI "\fBType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "bool \fBisUnbound\fP () const "
.br
.ti -1c
.RI "bool \fBisNormal\fP () const "
.br
.ti -1c
.RI "bool \fBisSpecial\fP () const "
.br
.ti -1c
.RI "bool \fBisMedia\fP () const "
.br
.ti -1c
.RI "bool \fBisProgram\fP () const "
.br
.ti -1c
.RI "bool \fBisAnim\fP () const "
.br
.ti -1c
.RI "bool \fBisMacro\fP () const "
.br
.ti -1c
.RI "bool \fBisDPI\fP () const "
.br
.ti -1c
.RI "bool \fBisMouse\fP () const "
.br
.ti -1c
.RI "QString \fBspecialInfo\fP (int &parameter) const "
.br
.ti -1c
.RI "int \fBprogramInfo\fP (QString &onPress, QString &onRelease) const "
.br
.ti -1c
.RI "int \fBdpiInfo\fP (QPoint &custom) const "
.br
.ti -1c
.RI "QUuid \fBanimInfo\fP (bool &onlyOnce, bool &stopOnRelease) const "
.br
.ti -1c
.RI "void \fBkeyEvent\fP (\fBKbBind\fP *bind, bool down)"
.br
.ti -1c
.RI "void \fBkeyRelease\fP (\fBKbBind\fP *bind)"
.br
.ti -1c
.RI "void \fBadjustDisplay\fP ()"
.br
.ti -1c
.RI "\fB~KeyAction\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static QString \fBnoAction\fP ()"
.br
.ti -1c
.RI "static QString \fBdefaultAction\fP (const QString &\fBkey\fP)"
.br
.ti -1c
.RI "static QString \fBmodeAction\fP (int mode)"
.br
.ti -1c
.RI "static QString \fBdpiAction\fP (int level, int customX=0, int customY=0)"
.br
.ti -1c
.RI "static QString \fBlightAction\fP (int \fBtype\fP=\fBLIGHT_UP_WRAP\fP)"
.br
.ti -1c
.RI "static QString \fBlockAction\fP (int \fBtype\fP=\fBLOCK_TOGGLE\fP)"
.br
.ti -1c
.RI "static QString \fBprogramAction\fP (const QString &onPress, const QString &onRelease, int stop)"
.br
.ti -1c
.RI "static QString \fBanimAction\fP (const QUuid &guid, bool onlyOnce, bool stopOnRelease)"
.br
.ti -1c
.RI "static QString \fBmacroAction\fP (QString macroDef)"
.br
.RI "\fIwell documented in cpp file \fP"
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBMODE_PREV\fP = -2"
.br
.ti -1c
.RI "static const int \fBMODE_NEXT\fP = -1"
.br
.ti -1c
.RI "static const int \fBMODE_PREV_WRAP\fP = -4"
.br
.ti -1c
.RI "static const int \fBMODE_NEXT_WRAP\fP = -3"
.br
.ti -1c
.RI "static const int \fBDPI_UP\fP = -2"
.br
.ti -1c
.RI "static const int \fBDPI_DOWN\fP = -1"
.br
.ti -1c
.RI "static const int \fBDPI_SNIPER\fP = 0"
.br
.ti -1c
.RI "static const int \fBDPI_CUSTOM\fP = 6"
.br
.ti -1c
.RI "static const int \fBLIGHT_UP\fP = 0"
.br
.ti -1c
.RI "static const int \fBLIGHT_DOWN\fP = 1"
.br
.ti -1c
.RI "static const int \fBLIGHT_UP_WRAP\fP = 2"
.br
.ti -1c
.RI "static const int \fBLIGHT_DOWN_WRAP\fP = 3"
.br
.ti -1c
.RI "static const int \fBLOCK_TOGGLE\fP = 0"
.br
.ti -1c
.RI "static const int \fBLOCK_ON\fP = 1"
.br
.ti -1c
.RI "static const int \fBLOCK_OFF\fP = 2"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_MULTI\fP = 0x04"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_INDEF\fP = 0x00"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_KRSTOP\fP = 0x01"
.br
.ti -1c
.RI "static const int \fBPROGRAM_PR_KPSTOP\fP = 0x02"
.br
.ti -1c
.RI "static const int \fBPROGRAM_RE_MULTI\fP = 0x40"
.br
.ti -1c
.RI "static const int \fBPROGRAM_RE_INDEF\fP = 0x00"
.br
.ti -1c
.RI "static const int \fBPROGRAM_RE_KPSTOP\fP = 0x20"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBoperator=\fP (const \fBKeyAction\fP &rhs)"
.br
.RI "\fIccMSC: Don't copy key actions (the old one needs to be deleted first) frickler24: statement left as described, but copying is done in \fBKbBind\fP copy constructor \fP"
.ti -1c
.RI "\fBKeyAction\fP (const \fBKeyAction\fP &rhs)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QString \fB_value\fP"
.br
.ti -1c
.RI "QProcess * \fBpreProgram\fP"
.br
.ti -1c
.RI "QProcess * \fBrelProgram\fP"
.br
.ti -1c
.RI "quint64 \fBsniperValue\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 13 of file keyaction\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBKeyAction::Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNBOUND \fP\fP
.TP
\fB\fINORMAL \fP\fP
.TP
\fB\fISPECIAL \fP\fP
.PP
Definition at line 145 of file keyaction\&.h\&.
.PP
.nf
145               {
146         UNBOUND,
147         NORMAL,
148         SPECIAL,
149     };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KeyAction::KeyAction (const QString &action, \fBQObject\fP *parent = \fC0\fP)"

.PP
Definition at line 22 of file keyaction\&.cpp\&.
.PP
.nf
23     : QObject(parent), _value(action), preProgram(0), relProgram(0), sniperValue(0)
24 {
25 }
.fi
.SS "KeyAction::KeyAction (\fBQObject\fP *parent = \fC0\fP)\fC [explicit]\fP"

.PP
Definition at line 27 of file keyaction\&.cpp\&.
.PP
.nf
28     : QObject(parent), _value(""), preProgram(0), relProgram(0), sniperValue(0)
29 {
30 }
.fi
.SS "KeyAction::~KeyAction ()"

.PP
Definition at line 32 of file keyaction\&.cpp\&.
.PP
References preProgram, and relProgram\&.
.PP
.nf
32                      {
33     // Clean up processes
34     if(preProgram){
35         preProgram->kill();
36         delete preProgram;
37     }
38     if(relProgram){
39         relProgram->kill();
40         delete relProgram;
41     }
42 }
.fi
.SS "KeyAction::KeyAction (const \fBKeyAction\fP &rhs)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 186 of file keyaction\&.h\&.
.PP
.nf
186 : QObject() {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "void KeyAction::adjustDisplay ()"

.PP
Definition at line 445 of file keyaction\&.cpp\&.
.PP
Referenced by keyEvent()\&.
.PP
.nf
445                              {
446 #ifdef USE_LIBX11
447     // Try to get the current display from the X server
448     char* display_name = XDisplayName(NULL);
449     if(!display_name)
450         return;
451     Display* display = XOpenDisplay(display_name);
452     if(!display)
453         return;
454     char* display_string = DisplayString(display);
455     if(!display_string || strlen(display_string) == 0){
456         XCloseDisplay(display);
457         return;
458     }
459     size_t envstr_size = strlen(display_string) + 4;
460     char* envstr = new char[envstr_size];
461     strncpy(envstr, display_string, envstr_size);
462     envstr[envstr_size - 1] = 0;
463 
464     Window root_window = XRootWindow(display, DefaultScreen(display));
465     Window root_window_ret, child_window_ret, window;
466     XWindowAttributes attr;
467     int root_x, root_y, win_x, win_y;
468     unsigned int mask_ret;
469 
470     // Find the screen which currently has the mouse
471     XQueryPointer(display, root_window, &root_window_ret, &child_window_ret, &root_x, &root_y, &win_x, &win_y, &mask_ret);
472     if(child_window_ret == (Window)NULL)
473         window = root_window_ret;
474     else
475         window = child_window_ret;
476     XGetWindowAttributes(display, window,  &attr);
477 
478     char* ptr = strchr(envstr, ':');
479     if(ptr){
480         ptr = strchr(ptr, '\&.');
481         if(ptr)
482             *ptr = '\0';
483         char buf[16];
484         snprintf(buf, sizeof(buf), "\&.%i", XScreenNumberOfScreen(attr\&.screen));
485         strncat(envstr, buf, envstr_size - 1 - strlen(envstr));
486 
487         // Update environment variable
488         setenv("DISPLAY", envstr, 1);
489     }
490 
491     delete[] envstr;
492     XCloseDisplay(display);
493 #endif
494 }
.fi
.SS "QString KeyAction::animAction (const QUuid &guid, boolonlyOnce, boolstopOnRelease)\fC [static]\fP"

.PP
Definition at line 175 of file keyaction\&.cpp\&.
.PP
References ANIM_KRSTOP, and ANIM_ONCE\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
175                                                                                  {
176     int flags = (onlyOnce ? ANIM_ONCE : 0) | (stopOnRelease ? ANIM_KRSTOP : 0);
177     return "$anim:" + guid\&.toString() + QString("+%1")\&.arg(flags);
178 }
.fi
.SS "QUuid KeyAction::animInfo (bool &onlyOnce, bool &stopOnRelease) const"

.PP
Definition at line 216 of file keyaction\&.cpp\&.
.PP
References _value, ANIM_KRSTOP, ANIM_ONCE, and isAnim()\&.
.PP
Referenced by keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
216                                                                    {
217     if(!isAnim())
218         return QUuid();
219     QString param = _value\&.mid(6);
220     QStringList split = param\&.split("+");
221     if(split\&.length() < 2)
222         return QUuid();
223     QUuid id = split[0];
224     int flags = split[1]\&.toInt();
225     onlyOnce = !!(flags & ANIM_ONCE);
226     stopOnRelease = !!(flags & ANIM_KRSTOP);
227     return id;
228 }
.fi
.SS "QString KeyAction::defaultAction (const QString &key)\fC [static]\fP"

.PP
Definition at line 44 of file keyaction\&.cpp\&.
.PP
Referenced by KbBind::bindAction(), KbBind::defaultAction(), and KbBind::save()\&.
.PP
.nf
44                                                   {
45     // G1-G18 are unbound by default
46     if(key\&.length() >= 2 && key[0] == 'g'
47         && ((key\&.length() == 2 && key[1] >= '0' && key[1] <= '9')
48         || (key\&.length() == 3 && key[1] == '1' && key[2] >= '0' && key[2] <= '8')))
49         return "";
50     // So are thumbgrid buttons
51     if(key\&.startsWith("thumb"))
52         return "";
53     // TODO: default action for MR
54     if(key == "mr")
55         return "";
56     // M1-M3 switch modes
57     if(key == "m1")
58         return "$mode:0";
59     if(key == "m2")
60         return "$mode:1";
61     if(key == "m3")
62         return "$mode:2";
63     // Brightness and Win Lock are their own functions
64     if(key == "light")
65         return "$light:2";
66     if(key == "lock")
67         return "$lock:0";
68     // DPI buttons
69     if(key == "dpiup")
70         return "$dpi:-2";
71     if(key == "dpidn")
72         return "$dpi:-1";
73     if(key == "sniper")
74         return "$dpi:0";
75     // Everything else is a standard keypress
76     return key;
77 }
.fi
.SS "QString KeyAction::dpiAction (intlevel, intcustomX = \fC0\fP, intcustomY = \fC0\fP)\fC [static]\fP"

.PP
Definition at line 153 of file keyaction\&.cpp\&.
.PP
References DPI_CUSTOM\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
153                                                                {
154     QString action = tr("$dpi:%1")\&.arg(level);
155     if(level == DPI_CUSTOM)
156         action += tr("+%1+%2")\&.arg(customX)\&.arg(customY);
157     return action;
158 }
.fi
.SS "int KeyAction::dpiInfo (QPoint &custom) const"

.PP
Definition at line 202 of file keyaction\&.cpp\&.
.PP
References _value, DPI_CUSTOM, and isDPI()\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
202                                            {
203     if(!isDPI())
204         return 0;
205     QString param = _value\&.mid(5);
206     QStringList lxy = param\&.split("+");
207     int level = lxy[0]\&.toInt();
208     if(level == DPI_CUSTOM){
209         if(lxy\&.length() != 3)
210             return 0;
211         custom = QPoint(lxy[1]\&.toInt(), lxy[2]\&.toInt());
212     }
213     return level;
214 }
.fi
.SS "QString KeyAction::driverName () const"

.PP
Definition at line 230 of file keyaction\&.cpp\&.
.PP
References _value, and isSpecial()\&.
.PP
Referenced by KbBind::update()\&.
.PP
.nf
230                                     {
231     if(isSpecial())
232         return "";
233     return _value;
234 }
.fi
.SS "QString KeyAction::friendlyName (const \fBKeyMap\fP &map) const"

.PP
Definition at line 79 of file keyaction\&.cpp\&.
.PP
References _value, DPI_CUSTOM, DPI_DOWN, DPI_SNIPER, DPI_UP, dpiInfo(), KeyMap::friendlyName(), KeyMap::layout(), LIGHT_DOWN, LIGHT_DOWN_WRAP, LIGHT_UP, LIGHT_UP_WRAP, LOCK_OFF, LOCK_ON, LOCK_TOGGLE, MODE_NEXT, MODE_NEXT_WRAP, MODE_PREV, and MODE_PREV_WRAP\&.
.PP
.nf
79                                                        {
80     if(_value\&.isEmpty())
81         return "Unbound";
82     QStringList parts = _value\&.split(":");
83     QString prefix = parts[0];
84     if(parts\&.length() < 2){
85         KeyMap::Layout layout = map\&.layout();
86         QString name = KeyMap::friendlyName(_value, layout);
87         if(name\&.isEmpty())
88             return "(Unknown)";
89         return name;
90     }
91     int suffix = parts[1]\&.toInt();
92     if(prefix == "$mode"){
93         switch(suffix){
94         case MODE_PREV:
95         case MODE_PREV_WRAP:
96             return "Switch to previous mode";
97         case MODE_NEXT:
98         case MODE_NEXT_WRAP:
99             return "Switch to next mode";
100         default:
101             return tr("Switch to mode %1")\&.arg(suffix + 1);
102         }
103     } else if(prefix == "$dpi"){
104         // Split off custom parameters (if any)
105         int level = parts[1]\&.split("+")[0]\&.toInt();
106         switch(level){
107         case DPI_UP:
108             return "DPI up";
109         case DPI_DOWN:
110             return "DPI down";
111         case DPI_SNIPER:
112             return "Sniper";
113         case DPI_CUSTOM:{
114             QPoint xy;
115             dpiInfo(xy);
116             return tr("DPI: %1, %2")\&.arg(xy\&.x())\&.arg(xy\&.y());
117         }
118         default:
119             return tr("DPI stage %1")\&.arg(level);
120         }
121     } else if(prefix == "$light"){
122         switch(suffix){
123         case LIGHT_UP:
124         case LIGHT_UP_WRAP:
125             return "Brightness up";
126         case LIGHT_DOWN:
127         case LIGHT_DOWN_WRAP:
128             return "Brightness down";
129         }
130     } else if(prefix == "$lock"){
131         switch(suffix){
132         case LOCK_TOGGLE:
133             return "Toggle Windows lock";
134         case LOCK_ON:
135             return "Windows lock on";
136         case LOCK_OFF:
137             return "Windows lock off";
138         }
139     } else if(prefix == "$anim"){
140         return "Start animation";
141     } else if(prefix == "$program"){
142         return "Launch program";
143     } else if(prefix == "$macro"){
144         return "Send G-key macro";
145     }
146     return "(Unknown)";
147 }
.fi
.SS "bool KeyAction::isAnim () const\fC [inline]\fP"

.PP
Definition at line 158 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by animInfo(), and RebindWidget::setSelection()\&.
.PP
.nf
158 { return _value\&.startsWith("$anim:"); }
.fi
.SS "bool KeyAction::isDPI () const\fC [inline]\fP"

.PP
Definition at line 161 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by dpiInfo(), isMouse(), and RebindWidget::setSelection()\&.
.PP
.nf
161 { return _value\&.startsWith("$dpi:"); }
.fi
.SS "bool KeyAction::isMacro () const\fC [inline]\fP"

.PP
Definition at line 159 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by isValidMacro(), macroDisplay(), and macroFullLine()\&.
.PP
.nf
159 { return _value\&.startsWith("$macro:"); }
.fi
.SS "bool KeyAction::isMedia () const\fC [inline]\fP"

.PP
Definition at line 155 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
.nf
155 { return _value == "mute" || _value == "volup" || _value == "voldn" || _value == "stop" || _value == "prev" || _value == "play" || _value == "next"; }
.fi
.SS "bool KeyAction::isMouse () const\fC [inline]\fP"

.PP
Definition at line 162 of file keyaction\&.h\&.
.PP
References _value, isDPI(), and isNormal()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
162 { return (isNormal() && (_value\&.startsWith("mouse") || _value\&.startsWith("wheel"))) || isDPI(); }
.fi
.SS "bool KeyAction::isNormal () const\fC [inline]\fP"

.PP
Definition at line 152 of file keyaction\&.h\&.
.PP
References NORMAL, and type()\&.
.PP
Referenced by isMouse(), RebindWidget::setBind(), and RebindWidget::setSelection()\&.
.PP
.nf
152 { return type() == NORMAL; }
.fi
.SS "bool KeyAction::isProgram () const\fC [inline]\fP"

.PP
Definition at line 157 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by programInfo(), and RebindWidget::setSelection()\&.
.PP
.nf
157 { return _value\&.startsWith("$program:"); }
.fi
.SS "bool KeyAction::isSpecial () const\fC [inline]\fP"

.PP
Definition at line 153 of file keyaction\&.h\&.
.PP
References SPECIAL, and type()\&.
.PP
Referenced by driverName(), keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
153 { return type() == SPECIAL; }
.fi
.SS "bool KeyAction::isUnbound () const\fC [inline]\fP"

.PP
Definition at line 151 of file keyaction\&.h\&.
.PP
References type(), and UNBOUND\&.
.PP
.nf
151 { return type() == UNBOUND; }
.fi
.SS "bool KeyAction::isValidMacro () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
bool as true iff the macro definition contains all four elements\&. 
.RE
.PP

.PP
Definition at line 55 of file keyaction\&.h\&.
.PP
References _value, and isMacro()\&.
.PP
Referenced by macroContent(), macroDisplay(), macroLine(), macroTiming(), RebindWidget::setSelection(), and KbBind::update()\&.
.PP
.nf
55                                       {
56         if (isMacro()) {
57             QStringList ret;
58             ret =_value\&.split(":");
59             return ((ret\&.count() >= 4) && (ret\&.count() <= 5));
60         } else {
61             return false;
62         }
63     }
.fi
.SS "void KeyAction::keyEvent (\fBKbBind\fP *bind, booldown)"

.PP
Definition at line 236 of file keyaction\&.cpp\&.
.PP
References _value, adjustDisplay(), anim, animInfo(), KbProfile::currentMode(), Kb::currentProfile(), KbBind::devParent(), KbLight::dimming(), KbPerf::dpi(), KbPerf::DPI_COUNT, DPI_CUSTOM, DPI_DOWN, DPI_SNIPER, DPI_UP, KbPerf::dpiDown(), dpiInfo(), KbPerf::dpiUp(), KbLight::findAnim(), KbProfile::indexOf(), KbAnim::isActive(), isSpecial(), KbBind::light(), LIGHT_DOWN, LIGHT_DOWN_WRAP, LIGHT_UP, LIGHT_UP_WRAP, LOCK_OFF, LOCK_ON, LOCK_TOGGLE, KbLight::MAX_DIM, MODE_NEXT, MODE_NEXT_WRAP, MODE_PREV, MODE_PREV_WRAP, KbProfile::modeCount(), KbProfile::modes(), KbBind::perf(), KbPerf::popDpi(), preProgram, PROGRAM_PR_KPSTOP, PROGRAM_PR_KRSTOP, PROGRAM_PR_MULTI, PROGRAM_RE_KPSTOP, PROGRAM_RE_MULTI, programInfo(), KbPerf::pushDpi(), KbPerf::pushSniper(), relProgram, Kb::setCurrentMode(), sniperValue, KbAnim::stop(), KbAnim::trigger(), and KbBind::winLock()\&.
.PP
Referenced by KbBind::keyEvent()\&.
.PP
.nf
236                                                {
237     // No need to respond to standard actions
238     if(!isSpecial())
239         return;
240     QStringList parts = _value\&.split(":");
241     if(parts\&.length() < 2)
242         return;
243     QString prefix = parts[0];
244     int suffix = parts[1]\&.toInt();
245     if(prefix == "$mode"){
246         if(!down)
247             return;
248         // Change mode
249         Kb* device = bind->devParent();
250         KbProfile* currentProfile = device->currentProfile();
251         int mode = currentProfile->indexOf(currentProfile->currentMode());
252         int modeCount = currentProfile->modeCount();
253         switch(suffix){
254         case MODE_PREV_WRAP:
255             mode--;
256             if(mode < 0)
257                 mode = modeCount - 1;
258             break;
259         case MODE_NEXT_WRAP:
260             mode++;
261             if(mode >= modeCount)
262                 mode = 0;
263             break;
264         case MODE_PREV:
265             mode--;
266             break;
267         case MODE_NEXT:
268             mode++;
269             break;
270         default:
271             // Absolute
272             mode = suffix;
273             break;
274         }
275         if(mode < 0 || mode >= modeCount)
276             return;
277         device->setCurrentMode(currentProfile->modes()[mode]);
278     } else if(prefix == "$dpi"){
279         KbPerf* perf = bind->perf();
280         int level = parts[1]\&.split("+")[0]\&.toInt();
281         switch(level){
282         case DPI_UP:
283             if(!down)
284                 return;
285             perf->dpiUp();
286             break;
287         case DPI_DOWN:
288             if(!down)
289                 return;
290             perf->dpiDown();
291             break;
292         case DPI_SNIPER:
293             if(down)
294                 sniperValue = perf->pushSniper();
295             else {
296                 perf->popDpi(sniperValue);
297                 sniperValue = 0;
298             }
299             break;
300         case DPI_CUSTOM:{
301             QPoint xy;
302             dpiInfo(xy);
303             if(xy\&.x() <= 0 || xy\&.y() <= 0)
304                 break;
305             if(down)
306                 sniperValue = perf->pushDpi(xy);
307             else {
308                 perf->popDpi(sniperValue);
309                 sniperValue = 0;
310             }
311             break;
312         }
313         default:
314             if(level < 1 || level >= KbPerf::DPI_COUNT
315                     || !down)
316                 return;
317             perf->dpi(level);
318             break;
319         }
320     } else if(prefix == "$light"){
321         if(!down)
322             return;
323         // Change brightness
324         KbLight* light = bind->light();
325         int dim = light->dimming();
326         switch(suffix){
327         case LIGHT_UP:
328             if(dim > 0)
329                 dim--;
330             break;
331         case LIGHT_DOWN:
332             if(dim < KbLight::MAX_DIM)
333                 dim++;
334             break;
335         case LIGHT_UP_WRAP:
336             dim--;
337             if(dim < 0)
338                 dim = KbLight::MAX_DIM;
339             break;
340         case LIGHT_DOWN_WRAP:
341             dim++;
342             if(dim > KbLight::MAX_DIM)
343                 dim = 0;
344             break;
345         }
346         light->dimming(dim);
347     } else if(prefix == "$lock"){
348         if(!down)
349             return;
350         // Change win lock
351         switch(suffix){
352         case LOCK_TOGGLE:
353             bind->winLock(!bind->winLock());
354             break;
355         case LOCK_ON:
356             bind->winLock(true);
357             break;
358         case LOCK_OFF:
359             bind->winLock(false);
360             break;
361         }
362     } else if(prefix == "$anim"){
363         // Start animation
364         bool onlyOnce = false, stopOnRelease = false;
365         QUuid id = animInfo(onlyOnce, stopOnRelease);
366         KbAnim* anim = bind->light()->findAnim(id);
367         if(!anim)
368             return;
369         if(down){
370             if(!onlyOnce || !anim->isActive())
371                 // If "only once" is enabled, don't start the animation when it's already running
372                 anim->trigger(QDateTime::currentMSecsSinceEpoch(), true);
373         } else if(stopOnRelease){
374             // Key released - stop animation
375             anim->stop();
376         }
377     } else if(prefix == "$program"){
378         // Launch program
379         QString onPress, onRelease;
380         int stop = programInfo(onPress, onRelease);
381         // Stop running programs based on setting
382         QProcess* process = 0;
383         if(down){
384             if(stop & PROGRAM_PR_KPSTOP){
385                 process = preProgram;
386                 if(process)
387                     process->kill();
388                 process = 0;
389             }
390             if(stop & PROGRAM_RE_KPSTOP)
391                 process = relProgram;
392         } else {
393             if(stop & PROGRAM_PR_KRSTOP)
394                 process = preProgram;
395         }
396         if(process)
397             process->kill();
398         // Launch new process if requested
399         QString& program = down ? onPress : onRelease;
400         if(program\&.isEmpty())
401             return;
402         // Check if the program is running already\&. If so, don't start it again\&.
403         process = down ? preProgram : relProgram;
404         if(process){
405             if(process->state() == QProcess::NotRunning)
406                 delete process;
407             else
408                 return;
409         }
410 
411         // Adjust the selected display\&.
412         adjustDisplay();
413 
414         // Start the program\&. Wrap it around sh to parse arguments\&.
415         if((down && (stop & PROGRAM_PR_MULTI))
416                 || (!down && (stop & PROGRAM_RE_MULTI))){
417             // Multiple instances allowed? Start detached process
418             QProcess::startDetached("sh", QStringList() << "-c" << program);
419         } else {
420             process = new QProcess(this);
421             process->start("sh", QStringList() << "-c" << program);
422             if(down)
423                 preProgram = process;
424             else
425                 relProgram = process;
426         }
427     } else if (prefix == "$macro") {
428         // Do nothing, because all work is done by the keyboard itself\&.
429         // For now, there is no reason to react on G-key press or release\&.
430         // If u find some reason, then here is the place for it\&.
431     }
432 }
.fi
.SS "void KeyAction::keyRelease (\fBKbBind\fP *bind)"

.SS "QString KeyAction::lightAction (inttype = \fC\fBLIGHT_UP_WRAP\fP\fP)\fC [static]\fP"

.PP
Definition at line 160 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
160                                       {
161     return QString("$light:%1")\&.arg(type);
162 }
.fi
.SS "QString KeyAction::lockAction (inttype = \fC\fBLOCK_TOGGLE\fP\fP)\fC [static]\fP"

.PP
Definition at line 164 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
164                                      {
165     return QString("$lock:%1")\&.arg(type);
166 }
.fi
.SS "QString KeyAction::macroAction (QStringmacroDef)\fC [static]\fP"
\fBKeyAction::macroAction\fP is called when applying changes on a macro definition\&. macroAction ist called while being in the macro pane and clicking Apply with something in the Macro Text Box\&. It tags that input with '$macro:' for further recognition\&.
.PP
\fBParameters:\fP
.RS 4
\fImacroDef\fP holds the String containing parts 2-5 of a complete macro definition\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
QString holding the complete G-Key macro definition (parts 1-5) 
.RE
.PP

.PP
Definition at line 504 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
504                                                {
505     return QString ("$macro:%1")\&.arg(macroDef);
506 }
.fi
.SS "QString KeyAction::macroContent () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QString macroContent 
.RE
.PP

.PP
Definition at line 86 of file keyaction\&.h\&.
.PP
References _value, and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection(), and KbBind::update()\&.
.PP
.nf
86                                         {
87         // return isValidMacro() ? _value\&.split(":")[1]\&.replace(QRegExp("=\\d+"), "") : ""; ///> Is used if we have ckb without delay handling
88         return isValidMacro() ? _value\&.split(":")[1] : "";
89     }
.fi
.SS "void KeyAction::macroDisplay ()"
\fBKeyAction::macroDisplay\fP is just for debugging\&. It shows the content of the key action and some other info\&.
.PP
General Info on \fBKeyAction::_value\fP for macros: That string consists of 4 elements, all delimited by ':'\&.
.IP "1." 4
Macro command indicator '$macro:'
.IP "2." 4
Macro \fBKey\fP Definition (coming from pteMacroBox): This sequence will program the keyboard and is hardly readable
.IP "3." 4
Readable Macro String: This is displayed in pteMacroText
.IP "4." 4
Readable Macro Comment:This is displayed in pteMacroComment
.IP "5." 4
completely unreadable original macro information with timing values 
.PP

.PP
Definition at line 437 of file keyaction\&.cpp\&.
.PP
References _value, isMacro(), and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
437                              {
438     qDebug() << "isMacro returns" << (isMacro() ? "true" : "false");
439     qDebug() << "isValidMacro returns" << (isValidMacro() ? "true" : "false");
440     QStringList ret =_value\&.split(":");
441     qDebug() << "Macro definition contains" << ret\&.count() << "elements";
442     qDebug() << "Macro definition is" << _value;
443 }
.fi
.SS "QString KeyAction::macroFullLine () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QString All 5 parts are returned in one QString\&. If no definition exists, return '' 
.RE
.PP

.PP
Definition at line 43 of file keyaction\&.h\&.
.PP
References _value, and isMacro()\&.
.PP
.nf
43                                          {
44         return isMacro() ? _value\&.right(_value\&.length()-1) : "";
45     }
.fi
.SS "QStringList KeyAction::macroLine () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QStringList returns the Macro \fBKey\fP Definition, Readble Macro String, Readable Macro Comment and the original timing information (if it exists as a 5th part) as QStringList\&. 
.RE
.PP

.PP
Definition at line 73 of file keyaction\&.h\&.
.PP
References _value, and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
73                                          {
74         if (isValidMacro()) {
75             QStringList ret =_value\&.split(":");
76             ret\&.removeFirst();
77             return ret;
78         } else return QStringList();
79     }
.fi
.SS "QString KeyAction::macroTiming () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
QString macroTiming 
.RE
.PP

.PP
Definition at line 98 of file keyaction\&.h\&.
.PP
References _value, and isValidMacro()\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
98                                        {
99         if (isValidMacro()) {
100             QStringList rval = _value\&.split(":");
101             return (rval\&.length() == 4)? rval[1] : rval[4];
102         }
103         return QString("");
104     }
.fi
.SS "QString KeyAction::modeAction (intmode)\fC [static]\fP"

.PP
Definition at line 149 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
149                                      {
150     return QString("$mode:%1")\&.arg(mode);
151 }
.fi
.SS "static QString KeyAction::noAction ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 25 of file keyaction\&.h\&.
.PP
.nf
25 { return ""; }
.fi
.SS "KeyAction::operator QString () const\fC [inline]\fP"

.PP
Definition at line 20 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
.nf
20 { return _value; }
.fi
.SS "void KeyAction::operator= (const \fBKeyAction\fP &rhs)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 185 of file keyaction\&.h\&.
.PP
.nf
185 {}
.fi
.SS "QString KeyAction::programAction (const QString &onPress, const QString &onRelease, intstop)\fC [static]\fP"

.PP
Definition at line 168 of file keyaction\&.cpp\&.
.PP
Referenced by RebindWidget::applyChanges()\&.
.PP
.nf
168                                                                                           {
169     // URL-encode the commands and place them in the string (":" and "+" are both replaced, so they won't interfere)
170     return "$program:" + QString::fromUtf8(QUrl::toPercentEncoding(onPress\&.trimmed())) + "+" + QString::fromUtf8(QUrl::toPercentEncoding(onRelease\&.trimmed())) + QString("+%1")\&.arg(stop);
171 }
.fi
.SS "int KeyAction::programInfo (QString &onPress, QString &onRelease) const"

.PP
Definition at line 190 of file keyaction\&.cpp\&.
.PP
References _value, and isProgram()\&.
.PP
Referenced by keyEvent(), and RebindWidget::setSelection()\&.
.PP
.nf
190                                                                      {
191     if(!isProgram())
192         return 0;
193     QString param = _value\&.mid(9);
194     QStringList programs = param\&.split("+");
195     if(programs\&.length() != 3)
196         return 0;
197     onPress = QUrl::fromPercentEncoding(programs[0]\&.toUtf8());
198     onRelease = QUrl::fromPercentEncoding(programs[1]\&.toUtf8());
199     return programs[2]\&.toInt();
200 }
.fi
.SS "QString KeyAction::specialInfo (int &parameter) const"

.PP
Definition at line 180 of file keyaction\&.cpp\&.
.PP
References _value\&.
.PP
Referenced by RebindWidget::setSelection()\&.
.PP
.nf
180                                                    {
181     QStringList list = _value\&.split(":");
182     if(list\&.length() < 2){
183         parameter = INT_MIN;
184         return "";
185     }
186     parameter = list[1]\&.toInt();
187     return list[0]\&.replace("$", "");
188 }
.fi
.SS "\fBKeyAction::Type\fP KeyAction::type () const"

.PP
Definition at line 14 of file keyaction\&.cpp\&.
.PP
References _value, NORMAL, SPECIAL, and UNBOUND\&.
.PP
Referenced by isNormal(), isSpecial(), isUnbound(), KbBindWidget::on_copyButton_clicked(), and KbBindWidget::on_resetButton_clicked()\&.
.PP
.nf
14                                     {
15     if(_value\&.isEmpty())
16         return UNBOUND;
17     if(_value\&.at(0) == '$')
18         return SPECIAL;
19     return NORMAL;
20 }
.fi
.SS "QString KeyAction::value () const\fC [inline]\fP"

.PP
Definition at line 19 of file keyaction\&.h\&.
.PP
References _value\&.
.PP
Referenced by KbBind::action(), KbBind::KbBind(), KbBind::save(), and KbBind::update()\&.
.PP
.nf
19 { return _value; }
.fi
.SH "Field Documentation"
.PP 
.SS "QString KeyAction::_value\fC [private]\fP"

.PP
Definition at line 188 of file keyaction\&.h\&.
.PP
Referenced by animInfo(), dpiInfo(), driverName(), friendlyName(), isAnim(), isDPI(), isMacro(), isMedia(), isMouse(), isProgram(), isValidMacro(), keyEvent(), macroContent(), macroDisplay(), macroFullLine(), macroLine(), macroTiming(), operator QString(), programInfo(), specialInfo(), type(), and value()\&.
.SS "const int KeyAction::DPI_CUSTOM = 6\fC [static]\fP"

.PP
Definition at line 127 of file keyaction\&.h\&.
.PP
Referenced by dpiAction(), dpiInfo(), friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::DPI_DOWN = -1\fC [static]\fP"

.PP
Definition at line 126 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::DPI_SNIPER = 0\fC [static]\fP"

.PP
Definition at line 127 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::DPI_UP = -2\fC [static]\fP"

.PP
Definition at line 126 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::LIGHT_DOWN = 1\fC [static]\fP"

.PP
Definition at line 130 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LIGHT_DOWN_WRAP = 3\fC [static]\fP"

.PP
Definition at line 131 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LIGHT_UP = 0\fC [static]\fP"

.PP
Definition at line 130 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LIGHT_UP_WRAP = 2\fC [static]\fP"

.PP
Definition at line 131 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::LOCK_OFF = 2\fC [static]\fP"

.PP
Definition at line 134 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::LOCK_ON = 1\fC [static]\fP"

.PP
Definition at line 134 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::LOCK_TOGGLE = 0\fC [static]\fP"

.PP
Definition at line 134 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), and keyEvent()\&.
.SS "const int KeyAction::MODE_NEXT = -1\fC [static]\fP"

.PP
Definition at line 122 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::MODE_NEXT_WRAP = -3\fC [static]\fP"

.PP
Definition at line 123 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::MODE_PREV = -2\fC [static]\fP"

.PP
Definition at line 122 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::MODE_PREV_WRAP = -4\fC [static]\fP"

.PP
Definition at line 123 of file keyaction\&.h\&.
.PP
Referenced by friendlyName(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "QProcess* KeyAction::preProgram\fC [private]\fP"

.PP
Definition at line 191 of file keyaction\&.h\&.
.PP
Referenced by keyEvent(), and ~KeyAction()\&.
.SS "const int KeyAction::PROGRAM_PR_INDEF = 0x00\fC [static]\fP"

.PP
Definition at line 137 of file keyaction\&.h\&.
.SS "const int KeyAction::PROGRAM_PR_KPSTOP = 0x02\fC [static]\fP"

.PP
Definition at line 137 of file keyaction\&.h\&.
.PP
Referenced by keyEvent()\&.
.SS "const int KeyAction::PROGRAM_PR_KRSTOP = 0x01\fC [static]\fP"

.PP
Definition at line 137 of file keyaction\&.h\&.
.PP
Referenced by keyEvent()\&.
.SS "const int KeyAction::PROGRAM_PR_MULTI = 0x04\fC [static]\fP"

.PP
Definition at line 137 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::PROGRAM_RE_INDEF = 0x00\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::PROGRAM_RE_KPSTOP = 0x20\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "const int KeyAction::PROGRAM_RE_MULTI = 0x40\fC [static]\fP"

.PP
Definition at line 138 of file keyaction\&.h\&.
.PP
Referenced by RebindWidget::applyChanges(), keyEvent(), and RebindWidget::setSelection()\&.
.SS "QProcess* KeyAction::relProgram\fC [private]\fP"

.PP
Definition at line 192 of file keyaction\&.h\&.
.PP
Referenced by keyEvent(), and ~KeyAction()\&.
.SS "quint64 KeyAction::sniperValue\fC [private]\fP"

.PP
Definition at line 195 of file keyaction\&.h\&.
.PP
Referenced by keyEvent()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
