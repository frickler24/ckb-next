.TH "src/ckb-daemon/input.c" 3 "Sat Jun 3 2017" "Version beta-v0.2.8+testing at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/input.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBIS_WHEEL\fP(scan, kb)   (((scan) == KEY_VOLUMEUP || (scan) == KEY_VOLUMEDOWN || (scan) == \fBBTN_WHEELUP\fP || (scan) == \fBBTN_WHEELDOWN\fP) && !\fBIS_K65\fP(kb))"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBmacromask\fP (const \fBuchar\fP *key1, const \fBuchar\fP *key2)"
.br
.ti -1c
.RI "static void \fBinputupdate_keys\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBinputupdate\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "void \fBupdateindicators_kb\fP (\fBusbdevice\fP *kb, int force)"
.br
.ti -1c
.RI "void \fBinitbind\fP (\fBbinding\fP *bind)"
.br
.ti -1c
.RI "void \fBfreebind\fP (\fBbinding\fP *bind)"
.br
.ti -1c
.RI "void \fBcmd_bind\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, int keyindex, const char *to)"
.br
.ti -1c
.RI "void \fBcmd_unbind\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, int keyindex, const char *to)"
.br
.ti -1c
.RI "void \fBcmd_rebind\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, int dummy, int keyindex, const char *to)"
.br
.ti -1c
.RI "static void \fB_cmd_macro\fP (\fBusbmode\fP *mode, const char *keys, const char *assignment)"
.br
.ti -1c
.RI "void \fBcmd_macro\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, const int notifynumber, const char *keys, const char *assignment)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define IS_WHEEL(scan, kb)   (((scan) == KEY_VOLUMEUP || (scan) == KEY_VOLUMEDOWN || (scan) == \fBBTN_WHEELUP\fP || (scan) == \fBBTN_WHEELDOWN\fP) && !\fBIS_K65\fP(kb))"

.PP
Referenced by inputupdate_keys()\&.
.SH "Function Documentation"
.PP 
.SS "static void _cmd_macro (\fBusbmode\fP *mode, const char *keys, const char *assignment)\fC [static]\fP"

.PP
Definition at line 236 of file input\&.c\&.
.PP
References keymacro::actioncount, keymacro::actions, usbmode::bind, keymacro::combo, macroaction::delay, macroaction::down, keymap, left, MACRO_MAX, binding::macrocap, binding::macrocount, binding::macros, N_KEYBYTES_INPUT, N_KEYS_INPUT, right(), macroaction::scan, key::scan, and SET_KEYBIT\&.
.PP
Referenced by cmd_macro()\&.
.PP
.nf
236                                                                                {
237     binding* bind = &mode->bind;
238     if(!keys && !assignment){
239         // Null strings = "macro clear" -> erase the whole thing
240         for(int i = 0; i < bind->macrocount; i++)
241             free(bind->macros[i]\&.actions);
242         bind->macrocount = 0;
243         return;
244     }
245     if(bind->macrocount >= MACRO_MAX)
246         return;
247     // Create a key macro
248     keymacro macro;
249     memset(&macro, 0, sizeof(macro));
250     // Scan the left side for key names, separated by +
251     int empty = 1;
252     int left = strlen(keys), right = strlen(assignment);
253     int position = 0, field = 0;
254     char keyname[24];
255     while(position < left && sscanf(keys + position, "%10[^+]%n", keyname, &field) == 1){
256         int keycode;
257         if((sscanf(keyname, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)
258                   || (sscanf(keyname, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)){
259             // Set a key numerically
260             SET_KEYBIT(macro\&.combo, keycode);
261             empty = 0;
262         } else {
263             // Find this key in the keymap
264             for(unsigned i = 0; i < N_KEYS_INPUT; i++){
265                 if(keymap[i]\&.name && !strcmp(keyname, keymap[i]\&.name)){
266                     macro\&.combo[i / 8] |= 1 << (i % 8);
267                     empty = 0;
268                     break;
269                 }
270             }
271         }
272         if(keys[position += field] == '+')
273             position++;
274     }
275     if(empty)
276         return;
277     // Count the number of actions (comma separated)
278     int count = 1;
279     for(const char* c = assignment; *c != 0; c++){
280         if(*c == ',')
281             count++;
282     }
283     // Allocate a buffer for them
284     macro\&.actions = calloc(count, sizeof(macroaction));
285     macro\&.actioncount = 0;
286     // Scan the actions
287     position = 0;
288     field = 0;
289     // max action = old 11 chars plus 12 chars which is the max 32-bit int 4294967295 size
290     while(position < right && sscanf(assignment + position, "%23[^,]%n", keyname, &field) == 1){
291         if(!strcmp(keyname, "clear"))
292             break;
293 
294         // Check for local key delay of the form '[+-]<key>=<delay>'
295         long int long_delay;    // scanned delay value, used to keep delay in range\&.
296         unsigned int delay = UINT_MAX; // computed delay value\&. UINT_MAX means use global delay value\&.
297         char real_keyname[12];  // temp to hold the left side (key) of the <key>=<delay>
298         int scan_matches = sscanf(keyname, "%11[^=]=%ld", real_keyname, &long_delay);
299         if (scan_matches == 2) {
300             if (0 <= long_delay && long_delay < UINT_MAX) {
301                 delay = (unsigned int)long_delay;
302                 strcpy(keyname, real_keyname); // keyname[24], real_keyname[12]
303             }
304         }
305 
306         int down = (keyname[0] == '+');
307         if(down || keyname[0] == '-'){
308             int keycode;
309             if((sscanf(keyname + 1, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)
310                       || (sscanf(keyname + 1, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_INPUT)){
311                 // Set a key numerically
312                 macro\&.actions[macro\&.actioncount]\&.scan = keymap[keycode]\&.scan;
313                 macro\&.actions[macro\&.actioncount]\&.down = down;
314                 macro\&.actions[macro\&.actioncount]\&.delay = delay;
315                 macro\&.actioncount++;
316             } else {
317                 // Find this key in the keymap
318                 for(unsigned i = 0; i < N_KEYS_INPUT; i++){
319                     if(keymap[i]\&.name && !strcmp(keyname + 1, keymap[i]\&.name)){
320                         macro\&.actions[macro\&.actioncount]\&.scan = keymap[i]\&.scan;
321                         macro\&.actions[macro\&.actioncount]\&.down = down;
322                         macro\&.actions[macro\&.actioncount]\&.delay = delay;
323                         macro\&.actioncount++;
324                         break;
325                     }
326                 }
327             }
328         }
329         if(assignment[position += field] == ',')
330             position++;
331     }
332 
333     // See if there's already a macro with this trigger
334     keymacro* macros = bind->macros;
335     for(int i = 0; i < bind->macrocount; i++){
336         if(!memcmp(macros[i]\&.combo, macro\&.combo, N_KEYBYTES_INPUT)){
337             free(macros[i]\&.actions);
338             // If the new macro has no actions, erase the existing one
339             if(!macro\&.actioncount){
340                 for(int j = i + 1; j < bind->macrocount; j++)
341                     memcpy(macros + j - 1, macros + j, sizeof(keymacro));
342                 bind->macrocount--;
343             } else
344                 // If there are actions, replace the existing with the new
345                 memcpy(macros + i, &macro, sizeof(keymacro));
346             return;
347         }
348     }
349 
350     // Add the macro to the device settings if not empty
351     if(macro\&.actioncount < 1)
352         return;
353     memcpy(bind->macros + (bind->macrocount++), &macro, sizeof(keymacro));
354     if(bind->macrocount >= bind->macrocap)
355         bind->macros = realloc(bind->macros, (bind->macrocap += 16) * sizeof(keymacro));
356 }
.fi
.SS "void cmd_bind (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, intkeyindex, const char *to)"

.PP
Definition at line 198 of file input\&.c\&.
.PP
References binding::base, usbmode::bind, imutex, keymap, N_KEYS_INPUT, and key::scan\&.
.PP
.nf
198                                                                                     {
199     if(keyindex >= N_KEYS_INPUT)
200         return;
201     // Find the key to bind to
202     int tocode = 0;
203     if(sscanf(to, "#x%ux", &tocode) != 1 && sscanf(to, "#%u", &tocode) == 1 && tocode < N_KEYS_INPUT){
204         pthread_mutex_lock(imutex(kb));
205         mode->bind\&.base[keyindex] = tocode;
206         pthread_mutex_unlock(imutex(kb));
207         return;
208     }
209     // If not numeric, look it up
210     for(int i = 0; i < N_KEYS_INPUT; i++){
211         if(keymap[i]\&.name && !strcmp(to, keymap[i]\&.name)){
212             pthread_mutex_lock(imutex(kb));
213             mode->bind\&.base[keyindex] = keymap[i]\&.scan;
214             pthread_mutex_unlock(imutex(kb));
215             return;
216         }
217     }
218 }
.fi
.SS "void cmd_macro (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, const intnotifynumber, const char *keys, const char *assignment)"

.PP
Definition at line 358 of file input\&.c\&.
.PP
References _cmd_macro(), and imutex\&.
.PP
.nf
358                                                                                                               {
359     pthread_mutex_lock(imutex(kb));
360     _cmd_macro(mode, keys, assignment);
361     pthread_mutex_unlock(imutex(kb));
362 }
.fi
.SS "void cmd_rebind (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, intkeyindex, const char *to)"

.PP
Definition at line 228 of file input\&.c\&.
.PP
References binding::base, usbmode::bind, imutex, keymap, N_KEYS_INPUT, and key::scan\&.
.PP
.nf
228                                                                                       {
229     if(keyindex >= N_KEYS_INPUT)
230         return;
231     pthread_mutex_lock(imutex(kb));
232     mode->bind\&.base[keyindex] = keymap[keyindex]\&.scan;
233     pthread_mutex_unlock(imutex(kb));
234 }
.fi
.SS "void cmd_unbind (\fBusbdevice\fP *kb, \fBusbmode\fP *mode, intdummy, intkeyindex, const char *to)"

.PP
Definition at line 220 of file input\&.c\&.
.PP
References binding::base, usbmode::bind, imutex, KEY_UNBOUND, and N_KEYS_INPUT\&.
.PP
.nf
220                                                                                       {
221     if(keyindex >= N_KEYS_INPUT)
222         return;
223     pthread_mutex_lock(imutex(kb));
224     mode->bind\&.base[keyindex] = KEY_UNBOUND;
225     pthread_mutex_unlock(imutex(kb));
226 }
.fi
.SS "void freebind (\fBbinding\fP *bind)"

.PP
Definition at line 191 of file input\&.c\&.
.PP
References keymacro::actions, binding::macrocount, and binding::macros\&.
.PP
Referenced by freemode()\&.
.PP
.nf
191                             {
192     for(int i = 0; i < bind->macrocount; i++)
193         free(bind->macros[i]\&.actions);
194     free(bind->macros);
195     memset(bind, 0, sizeof(*bind));
196 }
.fi
.SS "void initbind (\fBbinding\fP *bind)"

.PP
Definition at line 183 of file input\&.c\&.
.PP
References binding::base, keymap, binding::macrocap, binding::macrocount, binding::macros, N_KEYS_INPUT, and key::scan\&.
.PP
Referenced by initmode()\&.
.PP
.nf
183                             {
184     for(int i = 0; i < N_KEYS_INPUT; i++)
185         bind->base[i] = keymap[i]\&.scan;
186     bind->macros = calloc(32, sizeof(keymacro));
187     bind->macrocap = 32;
188     bind->macrocount = 0;
189 }
.fi
.SS "void inputupdate (\fBusbdevice\fP *kb)"

.PP
Definition at line 132 of file input\&.c\&.
.PP
References usbdevice::input, inputupdate_keys(), os_mousemove(), usbdevice::profile, usbinput::rel_x, usbinput::rel_y, usbdevice::uinput_kb, and usbdevice::uinput_mouse\&.
.PP
Referenced by os_inputmain(), setactive_kb(), and setactive_mouse()\&.
.PP
.nf
132                                {
133 #ifdef OS_LINUX
134     if((!kb->uinput_kb || !kb->uinput_mouse)
135 #else
136     if(!kb->event
137 #endif
138             || !kb->profile)
139         return;
140     // Process key/button input
141     inputupdate_keys(kb);
142     // Process mouse movement
143     usbinput* input = &kb->input;
144     if(input->rel_x != 0 || input->rel_y != 0){
145         os_mousemove(kb, input->rel_x, input->rel_y);
146         input->rel_x = input->rel_y = 0;
147     }
148     // Finish up
149     memcpy(input->prevkeys, input->keys, N_KEYBYTES_INPUT);
150 }
.fi
.SS "static void inputupdate_keys (\fBusbdevice\fP *kb)\fC [static]\fP"

.PP
Definition at line 15 of file input\&.c\&.
.PP
References keymacro::actioncount, keymacro::actions, usbdevice::active, binding::base, usbmode::bind, keymacro::combo, usbprofile::currentmode, macroaction::delay, usbdevice::delay, macroaction::down, usbdevice::input, IS_MOD, IS_WHEEL, keymap, usbinput::keys, binding::macrocount, macromask(), binding::macros, mmutex, N_KEYBYTES_INPUT, N_KEYS_INPUT, usbmode::notify, nprintkey(), os_keypress(), os_mousemove(), OUTFIFO_MAX, usbinput::prevkeys, usbdevice::profile, macroaction::rel_x, macroaction::rel_y, macroaction::scan, key::scan, SCAN_SILENT, and keymacro::triggered\&.
.PP
Referenced by inputupdate()\&.
.PP
.nf
15                                            {
16     usbmode* mode = kb->profile->currentmode;
17     binding* bind = &mode->bind;
18     usbinput* input = &kb->input;
19     // Don't do anything if the state hasn't changed
20     if(!memcmp(input->prevkeys, input->keys, N_KEYBYTES_INPUT))
21         return;
22     // Look for macros matching the current state
23     int macrotrigger = 0;
24     if(kb->active){
25         for(int i = 0; i < bind->macrocount; i++){
26             keymacro* macro = &bind->macros[i];
27             if(macromask(input->keys, macro->combo)){
28                 if(!macro->triggered){
29                     macrotrigger = 1;
30                     macro->triggered = 1;
31                     // Send events for each keypress in the macro
32                     pthread_mutex_lock(mmutex(kb)); // Synchonization between macro output and color information
33                     for(int a = 0; a < macro->actioncount; a++){
34                         macroaction* action = macro->actions + a;
35                         if(action->rel_x != 0 || action->rel_y != 0)
36                             os_mousemove(kb, action->rel_x, action->rel_y);
37                         else {
38                             os_keypress(kb, action->scan, action->down);
39                             if (action->delay != UINT_MAX) {    // local delay set
40                                 usleep(action->delay);
41                             } else if (kb->delay != UINT_MAX) { // use default global delay
42                                 usleep(kb->delay);
43                             } else if (a < (macro->actioncount - 1)) { // use delays depending on macro length
44                                 if (a > 200) {
45                                     usleep (100);
46                                 } else if (a > 20) {
47                                     usleep(30);
48                                 }
49                             }
50                         }
51                     }
52                     pthread_mutex_unlock(mmutex(kb));
53                 }
54             } else {
55                 macro->triggered = 0;
56                 macrotrigger = 0;
57             }
58         }
59     }
60     // Make a list of keycodes to send\&. Rearrange them so that modifier keydowns always come first
61     // and modifier keyups always come last\&. This ensures that shortcut keys will register properly
62     // even if both keydown events happen at once\&.
63     // N_KEYS + 4 is used because the volume wheel generates keydowns and keyups at the same time
64     // (it's currently impossible to press all four at once, but safety first)
65     int events[N_KEYS_INPUT + 4];
66     int modcount = 0, keycount = 0, rmodcount = 0;
67     for(int byte = 0; byte < N_KEYBYTES_INPUT; byte++){
68         char oldb = input->prevkeys[byte], newb = input->keys[byte];
69         if(oldb == newb)
70             continue;
71         for(int bit = 0; bit < 8; bit++){
72             int keyindex = byte * 8 + bit;
73             if(keyindex >= N_KEYS_INPUT)
74                 break;
75             const key* map = keymap + keyindex;
76             int scancode = (kb->active) ? bind->base[keyindex] : map->scan;
77             char mask = 1 << bit;
78             char old = oldb & mask, new = newb & mask;
79             // If the key state changed, send it to the input device
80             if(old != new){
81                 // Don't echo a key press if a macro was triggered or if there's no scancode associated
82                 if(!macrotrigger && !(scancode & SCAN_SILENT)){
83                     if(IS_MOD(scancode)){
84                         if(new){
85                             // Modifier down: Add to the end of modifier keys
86                             for(int i = keycount + rmodcount; i > 0; i--)
87                                 events[modcount + i] = events[modcount + i - 1];
88                             // Add 1 to the scancode because A is zero on OSX
89                             // Positive code = keydown, negative code = keyup
90                             events[modcount++] = scancode + 1;
91                         } else {
92                             // Modifier up: Add to the end of everything
93                             events[modcount + keycount + rmodcount++] = -(scancode + 1);
94                         }
95                     } else {
96                         // Regular keypress: add to the end of regular keys
97                         for(int i = rmodcount; i > 0; i--)
98                             events[modcount + keycount + i] = events[modcount + keycount + i - 1];
99                         events[modcount + keycount++] = new ? (scancode + 1) : -(scancode + 1);
100                         // The volume wheel and the mouse wheel don't generate keyups, so create them automatically
101 #define IS_WHEEL(scan, kb)  (((scan) == KEY_VOLUMEUP || (scan) == KEY_VOLUMEDOWN || (scan) == BTN_WHEELUP || (scan) == BTN_WHEELDOWN) && !IS_K65(kb))
102                         if(new && IS_WHEEL(map->scan, kb)){
103                             for(int i = rmodcount; i > 0; i--)
104                                 events[modcount + keycount + i] = events[modcount + keycount + i - 1];
105                             events[modcount + keycount++] = -(scancode + 1);
106                             input->keys[byte] &= ~mask;
107                         }
108                     }
109                 }
110                 // Print notifications if desired
111                 if(kb->active){
112                     for(int notify = 0; notify < OUTFIFO_MAX; notify++){
113                         if(mode->notify[notify][byte] & mask){
114                             nprintkey(kb, notify, keyindex, new);
115                             // Wheels doesn't generate keyups
116                             if(new && IS_WHEEL(map->scan, kb))
117                                 nprintkey(kb, notify, keyindex, 0);
118                         }
119                     }
120                 }
121             }
122         }
123     }
124     // Process all queued keypresses
125     int totalkeys = modcount + keycount + rmodcount;
126     for(int i = 0; i < totalkeys; i++){
127         int scancode = events[i];
128         os_keypress(kb, (scancode < 0 ? -scancode : scancode) - 1, scancode > 0);
129     }
130 }
.fi
.SS "int macromask (const \fBuchar\fP *key1, const \fBuchar\fP *key2)"

.PP
Definition at line 5 of file input\&.c\&.
.PP
References N_KEYBYTES_INPUT\&.
.PP
Referenced by inputupdate_keys()\&.
.PP
.nf
5                                                    {
6     // Scan a macro against key input\&. Return 0 if any of them don't match
7     for(int i = 0; i < N_KEYBYTES_INPUT; i++){
8         // if((key1[i] & key2[i]) != key2[i])
9         if(key1[i] != key2[i])  // Changed to detect G-keys + modifiers
10             return 0;
11     }
12     return 1;
13 }
.fi
.SS "void updateindicators_kb (\fBusbdevice\fP *kb, intforce)"

.PP
Definition at line 152 of file input\&.c\&.
.PP
References usbdevice::active, usbprofile::currentmode, DELAY_SHORT, usbdevice::hw_ileds, usbdevice::hw_ileds_old, I_CAPS, I_NUM, I_SCROLL, usbdevice::ileds, usbmode::inotify, usbmode::ioff, usbmode::ion, nprintind(), os_sendindicators(), OUTFIFO_MAX, and usbdevice::profile\&.
.PP
.nf
152                                                   {
153     // Read current hardware indicator state (set externally)
154     uchar old = kb->ileds, hw_old = kb->hw_ileds_old;
155     uchar new = kb->hw_ileds, hw_new = new;
156     // Update them if needed
157     if(kb->active){
158         usbmode* mode = kb->profile->currentmode;
159         new = (new & ~mode->ioff) | mode->ion;
160     }
161     kb->ileds = new;
162     kb->hw_ileds_old = hw_new;
163     if(old != new || force){
164         DELAY_SHORT(kb);
165         os_sendindicators(kb);
166     }
167     // Print notifications if desired
168     if(!kb->active)
169         return;
170     usbmode* mode = kb->profile->currentmode;
171     uchar indicators[] = { I_NUM, I_CAPS, I_SCROLL };
172     for(unsigned i = 0; i < sizeof(indicators) / sizeof(uchar); i++){
173         uchar mask = indicators[i];
174         if((hw_old & mask) == (hw_new & mask))
175             continue;
176         for(int notify = 0; notify < OUTFIFO_MAX; notify++){
177             if(mode->inotify[notify] & mask)
178                 nprintind(kb, notify, mask, hw_new & mask);
179         }
180     }
181 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
