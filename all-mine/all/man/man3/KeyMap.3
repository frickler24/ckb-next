.TH "KeyMap" 3 "Mon May 22 2017" "Version beta-v0.2.7 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KeyMap \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/keymap\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBModel\fP { \fBNO_MODEL\fP = -1, \fBK65\fP, \fBK70\fP, \fBK95\fP, \fBSTRAFE\fP, \fBM65\fP, \fBSABRE\fP, \fBSCIMITAR\fP, \fB_MODEL_MAX\fP }"
.br
.ti -1c
.RI "enum \fBLayout\fP { \fBNO_LAYOUT\fP = -1, \fBDK\fP, \fBEU\fP, \fBEU_DVORAK\fP, \fBGB\fP, \fBGB_DVORAK\fP, \fBUS\fP, \fBUS_DVORAK\fP, \fBFR\fP, \fBDE\fP, \fBIT\fP, \fBNO\fP, \fBPL\fP, \fBMX\fP, \fBES\fP, \fBSE\fP, \fB_LAYOUT_MAX\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBisISO\fP () const "
.br
.ti -1c
.RI "bool \fBisKeyboard\fP () const "
.br
.ti -1c
.RI "bool \fBisMouse\fP () const "
.br
.ti -1c
.RI "\fBKeyMap\fP ()"
.br
.ti -1c
.RI "\fBKeyMap\fP (\fBModel\fP _keyModel, \fBLayout\fP _keyLayout)"
.br
.ti -1c
.RI "QString \fBstrLayout\fP () const "
.br
.ti -1c
.RI "QString \fBstrModel\fP () const "
.br
.ti -1c
.RI "\fBModel\fP \fBmodel\fP () const "
.br
.ti -1c
.RI "\fBLayout\fP \fBlayout\fP () const "
.br
.ti -1c
.RI "QString \fBname\fP () const "
.br
.ti -1c
.RI "uint \fBcount\fP () const "
.br
.ti -1c
.RI "uint \fBwidth\fP () const "
.br
.ti -1c
.RI "uint \fBheight\fP () const "
.br
.ti -1c
.RI "\fBKey\fP \fBkey\fP (const QString &\fBname\fP) const "
.br
.ti -1c
.RI "\fBKey\fP \fBoperator[]\fP (const QString &\fBname\fP) const "
.br
.ti -1c
.RI "bool \fBcontains\fP (const QString &\fBname\fP) const "
.br
.ti -1c
.RI "const QHash< QString, \fBKey\fP > & \fBmap\fP () const "
.br
.ti -1c
.RI "\fBoperator const QHash< QString, Key > &\fP () const "
.br
.ti -1c
.RI "QStringList \fBkeys\fP () const "
.br
.ti -1c
.RI "QList< \fBKey\fP > \fBpositions\fP () const "
.br
.ti -1c
.RI "QString \fBtoStorage\fP (const QString &\fBname\fP)"
.br
.ti -1c
.RI "QString \fBfromStorage\fP (const QString &storage)"
.br
.ti -1c
.RI "QStringList \fBbyPosition\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static QStringList \fBlayoutNames\fP ()"
.br
.ti -1c
.RI "static bool \fBisISO\fP (\fBLayout\fP \fBlayout\fP)"
.br
.ti -1c
.RI "static \fBLayout\fP \fBlocale\fP ()"
.br
.ti -1c
.RI "static bool \fBisKeyboard\fP (\fBModel\fP \fBmodel\fP)"
.br
.ti -1c
.RI "static bool \fBisMouse\fP (\fBModel\fP \fBmodel\fP)"
.br
.ti -1c
.RI "static \fBKeyMap\fP \fBfromName\fP (const QString &\fBname\fP)"
.br
.ti -1c
.RI "static \fBLayout\fP \fBgetLayout\fP (const QString &\fBname\fP)"
.br
.ti -1c
.RI "static QString \fBgetLayout\fP (\fBLayout\fP \fBlayout\fP)"
.br
.ti -1c
.RI "static \fBModel\fP \fBgetModel\fP (const short vendor, const short product)"
.br
.RI "\fI\fBKeyMap::getModel\fP get the \fBKeyMap::Model\fP from the vendor / product special table\&. Use this function first, if you want to determine the firmware version to load or check\&. \fP"
.ti -1c
.RI "static \fBModel\fP \fBgetModel\fP (const QString &\fBname\fP)"
.br
.RI "\fI\fBKeyMap::getModel\fP \fBKeyMap\fP model name\&. \fP"
.ti -1c
.RI "static QString \fBgetModel\fP (\fBModel\fP \fBmodel\fP)"
.br
.RI "\fI\fBKeyMap::getModel\fP get the \fBKeyMap\fP name from the \fBKeyMap::Model\fP\&. \fP"
.ti -1c
.RI "static QString \fBfriendlyName\fP (const QString &\fBkey\fP, \fBLayout\fP \fBlayout\fP=\fBUS\fP)"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static int \fBmodelWidth\fP (\fBModel\fP \fBmodel\fP)"
.br
.ti -1c
.RI "static int \fBmodelHeight\fP (\fBModel\fP \fBmodel\fP)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QHash< QString, \fBKey\fP > \fB_keys\fP"
.br
.ti -1c
.RI "short \fBkeyWidth\fP"
.br
.ti -1c
.RI "short \fBkeyHeight\fP"
.br
.ti -1c
.RI "\fBModel\fP \fBkeyModel\fP:8"
.br
.ti -1c
.RI "\fBLayout\fP \fBkeyLayout\fP:8"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 49 of file keymap\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBKeyMap::Layout\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINO_LAYOUT \fP\fP
.TP
\fB\fIDK \fP\fP
.TP
\fB\fIEU \fP\fP
.TP
\fB\fIEU_DVORAK \fP\fP
.TP
\fB\fIGB \fP\fP
.TP
\fB\fIGB_DVORAK \fP\fP
.TP
\fB\fIUS \fP\fP
.TP
\fB\fIUS_DVORAK \fP\fP
.TP
\fB\fIFR \fP\fP
.TP
\fB\fIDE \fP\fP
.TP
\fB\fIIT \fP\fP
.TP
\fB\fINO \fP\fP
.TP
\fB\fIPL \fP\fP
.TP
\fB\fIMX \fP\fP
.TP
\fB\fIES \fP\fP
.TP
\fB\fISE \fP\fP
.TP
\fB\fI_LAYOUT_MAX \fP\fP
.PP
Definition at line 65 of file keymap\&.h\&.
.PP
.nf
65                 {
66         NO_LAYOUT = -1,
67         DK,                 // Danish
68         EU,                 // English (EU)
69         EU_DVORAK,
70         GB,                 // English (UK)
71         GB_DVORAK,
72         US,                 // English (US)
73         US_DVORAK,
74         FR,                 // French
75         DE,                 // German
76         IT,                 // Italian
77         NO,                 // Norwegian
78         PL,                 // Polish (identical to US)
79         MX,                 // Spanish (Mexico/Latin America)
80         ES,                 // Spanish (Spain)
81         SE,                 // Swedish
82         _LAYOUT_MAX
83     };
.fi
.SS "enum \fBKeyMap::Model\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINO_MODEL \fP\fP
.TP
\fB\fIK65 \fP\fP
.TP
\fB\fIK70 \fP\fP
.TP
\fB\fIK95 \fP\fP
.TP
\fB\fISTRAFE \fP\fP
.TP
\fB\fIM65 \fP\fP
.TP
\fB\fISABRE \fP\fP
.TP
\fB\fISCIMITAR \fP\fP
.TP
\fB\fI_MODEL_MAX \fP\fP
.PP
Definition at line 51 of file keymap\&.h\&.
.PP
.nf
51                {
52         NO_MODEL = -1,
53         // Keyboard models
54         K65,
55         K70,
56         K95,
57         STRAFE,
58         // Mouse models
59         M65,
60         SABRE,
61         SCIMITAR,
62         _MODEL_MAX
63     };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KeyMap::KeyMap ()"

.PP
Definition at line 613 of file keymap\&.cpp\&.
.PP
Referenced by friendlyName(), and fromName()\&.
.PP
.nf
613                :
614      keyWidth(0), keyHeight(0),
615      keyModel(NO_MODEL), keyLayout(NO_LAYOUT)
616 {}
.fi
.SS "KeyMap::KeyMap (\fBModel\fP_keyModel, \fBLayout\fP_keyLayout)"

.PP
Definition at line 607 of file keymap\&.cpp\&.
.PP
.nf
607                                                  :
608     _keys(getMap(_keyModel, _keyLayout)),
609     keyWidth(modelWidth(_keyModel)), keyHeight(modelHeight(_keyModel)),
610     keyModel(_keyModel), keyLayout(_keyLayout)
611 {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "QStringList KeyMap::byPosition () const"

.PP
Definition at line 618 of file keymap\&.cpp\&.
.PP
References Key::x, x, Key::y, and y\&.
.PP
Referenced by RebindWidget::setBind()\&.
.PP
.nf
618                                      {
619     // Use QMaps to order the keys
620     QMap<int, QMap<int, QString> > ordered;
621     QHashIterator<QString, Key> i(*this);
622     while(i\&.hasNext()){
623         i\&.next();
624         const Key& key = i\&.value();
625         ordered[key\&.y][key\&.x] = i\&.key();
626     }
627     // Merge them into a single list
628     QStringList result;
629     QMapIterator<int, QMap<int, QString> > y(ordered);
630     while(y\&.hasNext()){
631         y\&.next();
632         QMapIterator<int, QString> x(y\&.value());
633         while(x\&.hasNext()){
634             x\&.next();
635             result << x\&.value();
636         }
637     }
638     return result;
639 }
.fi
.SS "bool KeyMap::contains (const QString &name) const\fC [inline]\fP"

.PP
Definition at line 128 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
Referenced by friendlyName(), and KbAnimWidget::on_keyButton_clicked()\&.
.PP
.nf
128 { return _keys\&.contains(name); }
.fi
.SS "uint KeyMap::count () const\fC [inline]\fP"

.PP
Definition at line 119 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
Referenced by KeyWidget::map(), KbBindWidget::on_copyButton_clicked(), and KbBindWidget::on_resetButton_clicked()\&.
.PP
.nf
119 { return _keys\&.count(); }
.fi
.SS "QString KeyMap::friendlyName (const QString &key, \fBLayout\fPlayout = \fC\fBUS\fP\fP)\fC [static]\fP"

.PP
Definition at line 641 of file keymap\&.cpp\&.
.PP
References contains(), K95, KeyMap(), M65, map(), SCIMITAR, and STRAFE\&.
.PP
Referenced by KeyAction::friendlyName(), and RebindWidget::RebindWidget()\&.
.PP
.nf
641                                                              {
642     // Try K95 map first
643     // FIXME: This is an odd function and probably should be refactored
644     // it would probably be best to remove the friendly names from the maps and have a completely separate name->friendlyName store
645     KeyMap map(K95, layout);
646     if(map\&.contains(key))
647         return map[key]\&.friendlyName();
648 
649     // The only key missing from it should be Fn, which is found on STRAFE
650     map = KeyMap(STRAFE, layout);
651     if(map\&.contains(key))
652         return map[key]\&.friendlyName();
653 
654     // Additionally, there are a handful of keys not present on any physical keyboard, but we need names for them
655     if(key == "f13" || key == "f14" || key == "f15" || key == "f16" || key == "f17" || key == "f18" || key == "f19" || key == "f20")
656         return key\&.toUpper();
657     else if(key == "lightup")
658         return "Screen Brightness Up";
659     else if(key == "lightdn")
660         return "Screen Brightness Down";
661     else if(key == "eject" || key == "power")
662         return key[0]\&.toUpper() + key\&.mid(1);   // capitalize first letter
663 
664     // All other names are found on mice
665     map = KeyMap(SCIMITAR, layout);
666     if(map\&.contains(key))
667         return map[key]\&.friendlyName();
668     map = KeyMap(M65, layout);
669     if(map\&.contains(key))
670         return map[key]\&.friendlyName();
671 
672     // Not found at all
673     return "";
674 }
.fi
.SS "\fBKeyMap\fP KeyMap::fromName (const QString &name)\fC [static]\fP"

.PP
Definition at line 565 of file keymap\&.cpp\&.
.PP
References getLayout(), getModel(), and KeyMap()\&.
.PP
Referenced by KbBind::load(), and KbLight::load()\&.
.PP
.nf
565                                           {
566     QStringList list = name\&.trimmed()\&.split(" ");
567     if(list\&.length() != 2)
568         return KeyMap();
569     return KeyMap(getModel(list[0]), getLayout(list[1]));
570 }
.fi
.SS "QString KeyMap::fromStorage (const QString &storage)\fC [inline]\fP"

.PP
Definition at line 136 of file keymap\&.h\&.
.PP
Referenced by KbAnim::KbAnim(), KbBind::load(), and KbLight::load()\&.
.PP
.nf
136 { QHashIterator<QString, Key> i(*this); while(i\&.hasNext()) { i\&.next(); const char* s = i\&.value()\&.storageName(); if(s == storage) return i\&.value()\&.name; } return storage; }
.fi
.SS "\fBKeyMap::Layout\fP KeyMap::getLayout (const QString &name)\fC [static]\fP"

.PP
Definition at line 409 of file keymap\&.cpp\&.
.PP
References DE, DK, ES, EU, EU_DVORAK, FR, GB, GB_DVORAK, IT, MX, NO, NO_LAYOUT, PL, SE, US, and US_DVORAK\&.
.PP
Referenced by fromName(), SettingsWidget::on_layoutBox_activated(), SettingsWidget::SettingsWidget(), and strLayout()\&.
.PP
.nf
409                                                  {
410     QString lower = name\&.toLower();
411     if(lower == "dk")
412         return DK;
413     if(lower == "eu")
414         return EU;
415     if(lower == "eu_dvorak")
416         return EU_DVORAK;
417     if(lower == "gb_dvorak")
418         return GB_DVORAK;
419     if(lower == "us")
420         return US;
421     if(lower == "us_dvorak")
422         return US_DVORAK;
423     if(lower == "fr")
424         return FR;
425     if(lower == "de")
426         return DE;
427     if(lower == "it")
428         return IT;
429     if(lower == "no")
430         return NO;
431     if(lower == "pl")
432         return PL;
433     if(lower == "mx")
434         return MX;
435     if(lower == "es")
436         return ES;
437     if(lower == "se")
438         return SE;
439     if(lower == "gb")
440         return GB;
441     return NO_LAYOUT;
442 }
.fi
.SS "QString KeyMap::getLayout (\fBKeyMap::Layout\fPlayout)\fC [static]\fP"

.PP
Definition at line 444 of file keymap\&.cpp\&.
.PP
References DE, DK, ES, EU, EU_DVORAK, FR, GB, GB_DVORAK, IT, MX, NO, PL, SE, US, and US_DVORAK\&.
.PP
.nf
444                                             {
445     switch(layout){
446     case DK:
447         return "dk";
448     case EU:
449         return "eu";
450     case EU_DVORAK:
451         return "eu_dvorak";
452     case GB:
453         return "gb";
454     case GB_DVORAK:
455         return "gb_dvorak";
456     case US:
457         return "us";
458     case US_DVORAK:
459         return "us_dvorak";
460     case FR:
461         return "fr";
462     case DE:
463         return "de";
464     case IT:
465         return "it";
466     case NO:
467         return "no";
468     case PL:
469         return "pl";
470     case MX:
471         return "mx";
472     case ES:
473         return "es";
474     case SE:
475         return "se";
476     default:
477         return "";
478     }
479 }
.fi
.SS "\fBKeyMap::Model\fP KeyMap::getModel (const shortvendor, const shortmyProduct)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIvendor\fP Corsair's vendor ID V_CORSAIR - just to be sure\&.\&.\&. 
.br
\fImyProduct\fP the productID of your USB device 
.RE
.PP
\fBReturns:\fP
.RS 4
the corresponding \fBKeyMap::Model\fP if the v/p-combination could be found, NO_MODEL else\&. 
.RE
.PP

.PP
Definition at line 504 of file keymap\&.cpp\&.
.PP
References firmwareSpecial::model, NO_MODEL, specials, and V_CORSAIR\&.
.PP
Referenced by fromName(), Kb::Kb(), and strModel()\&.
.PP
.nf
504                                                                      {
505     if (vendor != V_CORSAIR) {
506         qCritical() << "Wrong vendor number" << vendor << "with product number" << myProduct;
507         return NO_MODEL;
508     }
509     for (uint i = 0; i < sizeof(specials)/sizeof(struct firmwareSpecial)  ; i++) {
510         if (specials[i]\&.product == myProduct) return specials[i]\&.model;
511     }
512     return NO_MODEL;
513 }
.fi
.SS "\fBKeyMap::Model\fP KeyMap::getModel (const QString &name)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIname\fP QString with the name from 'features' file 
.RE
.PP
\fBReturns:\fP
.RS 4
the corresponding \fBKeyMap::Model\fP or NO_MODEL (-1), if name does not exist\&. 
.RE
.PP

.PP
Definition at line 520 of file keymap\&.cpp\&.
.PP
References K65, K70, K95, M65, NO_MODEL, SABRE, SCIMITAR, and STRAFE\&.
.PP
.nf
520                                                {
521     QString lower = name\&.toLower();
522     if(lower == "k65")
523         return K65;
524     if(lower == "k70")
525         return K70;
526     if(lower == "k95")
527         return K95;
528     if(lower == "strafe")
529         return STRAFE;
530     if(lower == "m65")
531         return M65;
532     if(lower == "sabre")
533         return SABRE;
534     if(lower == "scimitar")
535         return SCIMITAR;
536     return NO_MODEL;
537 }
.fi
.SS "QString KeyMap::getModel (\fBKeyMap::Model\fPmodel)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fImodel\fP \fBKeyMap::Model\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
QString with model name or '' if model exceeds boundaries 
.RE
.PP

.PP
Definition at line 544 of file keymap\&.cpp\&.
.PP
References K65, K70, K95, M65, SABRE, SCIMITAR, and STRAFE\&.
.PP
.nf
544                                          {
545     switch(model){
546     case K65:
547         return "k65";
548     case K70:
549         return "k70";
550     case K95:
551         return "k95";
552     case STRAFE:
553         return "strafe";
554     case M65:
555         return "m65";
556     case SABRE:
557         return "sabre";
558     case SCIMITAR:
559         return "scimitar";
560     default:
561         return "";
562     }
563 }
.fi
.SS "uint KeyMap::height () const\fC [inline]\fP"

.PP
Definition at line 123 of file keymap\&.h\&.
.PP
References keyHeight\&.
.PP
Referenced by KeyWidget::drawInfo(), and KeyWidget::map()\&.
.PP
.nf
123 { return keyHeight; }
.fi
.SS "static bool KeyMap::isISO (\fBLayout\fPlayout)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 87 of file keymap\&.h\&.
.PP
References PL, US, and US_DVORAK\&.
.PP
Referenced by KbBind::isISO(), and RebindWidget::setBind()\&.
.PP
.nf
87 { return layout != US && layout != US_DVORAK && layout != PL; }
.fi
.SS "bool KeyMap::isISO () const\fC [inline]\fP"

.PP
Definition at line 88 of file keymap\&.h\&.
.PP
References isISO(), and keyLayout\&.
.PP
Referenced by getMap(), isISO(), Kb::Kb(), and Kb::updateLayout()\&.
.PP
.nf
88 { return isISO(keyLayout); }
.fi
.SS "static bool KeyMap::isKeyboard (\fBModel\fPmodel)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 93 of file keymap\&.h\&.
.PP
References isMouse(), and NO_MODEL\&.
.PP
Referenced by KbBind::isKeyboard()\&.
.PP
.nf
93 { return !isMouse(model) && model != NO_MODEL; }
.fi
.SS "bool KeyMap::isKeyboard () const\fC [inline]\fP"

.PP
Definition at line 94 of file keymap\&.h\&.
.PP
References isKeyboard(), and keyModel\&.
.PP
Referenced by Kb::isKeyboard(), and isKeyboard()\&.
.PP
.nf
94 { return isKeyboard(keyModel); }
.fi
.SS "static bool KeyMap::isMouse (\fBModel\fPmodel)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 95 of file keymap\&.h\&.
.PP
References M65, SABRE, and SCIMITAR\&.
.PP
Referenced by KbBind::isMouse(), KeyWidget::map(), KbLightWidget::newSelection(), and KeyWidget::paintEvent()\&.
.PP
.nf
95 { return model == M65 || model == SABRE || model == SCIMITAR; }
.fi
.SS "bool KeyMap::isMouse () const\fC [inline]\fP"

.PP
Definition at line 96 of file keymap\&.h\&.
.PP
References isMouse(), and keyModel\&.
.PP
Referenced by isKeyboard(), Kb::isMouse(), isMouse(), and KeyWidget::paintEvent()\&.
.PP
.nf
96 { return isMouse(keyModel); }
.fi
.SS "\fBKey\fP KeyMap::key (const QString &name) const\fC [inline]\fP"

.PP
Definition at line 126 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
Referenced by AnimScript::begin(), AnimScript::keypress(), KbBind::noAction(), operator[](), KbBind::setAction(), and toStorage()\&.
.PP
.nf
126 { Key empty = {0,0,0,0,0,0,0,0,0}; return _keys\&.value(name, empty); }
.fi
.SS "QStringList KeyMap::keys () const\fC [inline]\fP"

.PP
Definition at line 132 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
Referenced by KeyWidget::mouseReleaseEvent(), KbBindWidget::on_copyButton_clicked(), KbBindWidget::on_resetButton_clicked(), KeyWidget::setAnimation(), KeyWidget::setSelection(), and KbBindWidget::updateBind()\&.
.PP
.nf
132 { return _keys\&.keys(); }
.fi
.SS "\fBLayout\fP KeyMap::layout () const\fC [inline]\fP"

.PP
Definition at line 115 of file keymap\&.h\&.
.PP
References keyLayout\&.
.PP
Referenced by KeyAction::friendlyName(), KeyWidget::paintEvent(), and RebindWidget::setBind()\&.
.PP
.nf
115 { return keyLayout; }
.fi
.SS "QStringList KeyMap::layoutNames ()\fC [static]\fP"

.PP
Definition at line 481 of file keymap\&.cpp\&.
.PP
Referenced by LayoutDialog::LayoutDialog(), and SettingsWidget::SettingsWidget()\&.
.PP
.nf
481                                {
482     return QStringList()
483             << "Danish"
484             << "English (ISO/European)" << "English (ISO/European, Dvorak)"
485             << "English (United Kingdom)" << "English (United Kingdom, Dvorak)"
486             << "English (United States)" << "English (United States, Dvorak)"
487             << "French"
488             << "German"
489             << "Italian"
490             << "Norwegian"
491             << "Polish"
492             << "Spanish (Latin America)"
493             << "Spanish (Spain)"
494             << "Swedish";
495 }
.fi
.SS "\fBKeyMap::Layout\fP KeyMap::locale ()\fC [static]\fP"

.PP
Definition at line 377 of file keymap\&.cpp\&.
.PP
References DE, DK, ES, FR, GB, IT, MX, NO, PL, SE, and US\&.
.PP
Referenced by SettingsWidget::SettingsWidget()\&.
.PP
.nf
377                            {
378     setlocale(LC_ALL, "");
379     QString loc = setlocale(LC_CTYPE, 0);
380     loc = loc\&.toLower()\&.replace('_', '-');
381     if(loc\&.startsWith("dk-"))
382         return KeyMap::DK;
383     else if(loc\&.startsWith("fr-"))
384         return KeyMap::FR;
385     else if(loc\&.startsWith("de-"))
386         return KeyMap::DE;
387     else if(loc\&.startsWith("it-"))
388         return KeyMap::IT;
389     else if(loc\&.startsWith("pl-"))
390         return KeyMap::PL;
391     else if(loc\&.startsWith("no-"))
392         return KeyMap::NO;
393     else if(loc\&.startsWith("es-es"))
394         // Spain uses the ES layout
395         return KeyMap::ES;
396     else if(loc\&.startsWith("es-"))
397         // Other Spanish locales use MX
398         return KeyMap::MX;
399     else if(loc\&.startsWith("se-"))
400         return KeyMap::SE;
401     else if(loc\&.startsWith("en-us") || loc\&.startsWith("en-au") || loc\&.startsWith("en-ca") || loc\&.startsWith("en-hk") || loc\&.startsWith("en-in") || loc\&.startsWith("en-nz") || loc\&.startsWith("en-ph") || loc\&.startsWith("en-sg") || loc\&.startsWith("en-za"))
402         // Most English locales use US
403         return KeyMap::US;
404     else
405         // Default to GB
406         return KeyMap::GB;
407 }
.fi
.SS "const QHash<QString, \fBKey\fP>& KeyMap::map () const\fC [inline]\fP"

.PP
Definition at line 130 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
Referenced by friendlyName()\&.
.PP
.nf
130 { return _keys; }
.fi
.SS "\fBModel\fP KeyMap::model () const\fC [inline]\fP"

.PP
Definition at line 114 of file keymap\&.h\&.
.PP
References keyModel\&.
.PP
Referenced by KeyWidget::mouseMoveEvent(), KeyWidget::paintEvent(), and KPerfWidget::setPerf()\&.
.PP
.nf
114 { return keyModel; }
.fi
.SS "int KeyMap::modelHeight (\fBModel\fPmodel)\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 591 of file keymap\&.cpp\&.
.PP
References K65, K70, K95, K95_HEIGHT, M65, M65_HEIGHT, SABRE, SCIMITAR, and STRAFE\&.
.PP
.nf
591                                   {
592     switch(model){
593     case K65:
594     case K70:
595     case K95:
596     case STRAFE:
597         return K95_HEIGHT;
598     case M65:
599     case SABRE:
600     case SCIMITAR:
601         return M65_HEIGHT;
602     default:
603         return 0;
604     }
605 }
.fi
.SS "int KeyMap::modelWidth (\fBModel\fPmodel)\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 572 of file keymap\&.cpp\&.
.PP
References K65, K65_WIDTH, K70, K70_WIDTH, K95, K95_WIDTH, KSTRAFE_WIDTH, M65, M65_WIDTH, SABRE, SCIMITAR, and STRAFE\&.
.PP
.nf
572                                  {
573     switch(model){
574     case K65:
575         return K65_WIDTH;
576     case K70:
577         return K70_WIDTH;
578     case K95:
579         return K95_WIDTH;
580     case STRAFE:
581         return KSTRAFE_WIDTH;
582     case M65:
583     case SABRE:
584     case SCIMITAR:
585         return M65_WIDTH;
586     default:
587         return 0;
588     }
589 }
.fi
.SS "QString KeyMap::name () const\fC [inline]\fP"

.PP
Definition at line 116 of file keymap\&.h\&.
.PP
References strLayout(), and strModel()\&.
.PP
Referenced by KbBind::save(), KbLight::save(), and toStorage()\&.
.PP
.nf
116 { return (strModel() + " " + strLayout())\&.toUpper(); }
.fi
.SS "KeyMap::operator const QHash< QString, \fBKey\fP > & () const\fC [inline]\fP"

.PP
Definition at line 131 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
.nf
131 { return _keys; }
.fi
.SS "\fBKey\fP KeyMap::operator[] (const QString &name) const\fC [inline]\fP"

.PP
Definition at line 127 of file keymap\&.h\&.
.PP
References key()\&.
.PP
.nf
127 { return key(name); }
.fi
.SS "QList<\fBKey\fP> KeyMap::positions () const\fC [inline]\fP"

.PP
Definition at line 133 of file keymap\&.h\&.
.PP
References _keys\&.
.PP
Referenced by ColorMap::init(), and KeyWidget::selectAll()\&.
.PP
.nf
133 { return _keys\&.values(); }
.fi
.SS "QString KeyMap::strLayout () const\fC [inline]\fP"

.PP
Definition at line 106 of file keymap\&.h\&.
.PP
References getLayout(), and keyLayout\&.
.PP
Referenced by name()\&.
.PP
.nf
106 { return getLayout(keyLayout); }
.fi
.SS "QString KeyMap::strModel () const\fC [inline]\fP"

.PP
Definition at line 111 of file keymap\&.h\&.
.PP
References getModel(), and keyModel\&.
.PP
Referenced by name()\&.
.PP
.nf
111 { return getModel(keyModel); }
.fi
.SS "QString KeyMap::toStorage (const QString &name)\fC [inline]\fP"

.PP
Definition at line 135 of file keymap\&.h\&.
.PP
References key(), name(), and Key::storageName()\&.
.PP
.nf
135 { const char* storage = key(name)\&.storageName(); if(!storage) return name; return storage; }
.fi
.SS "uint KeyMap::width () const\fC [inline]\fP"

.PP
Definition at line 121 of file keymap\&.h\&.
.PP
References keyWidth\&.
.PP
Referenced by KeyWidget::drawInfo(), and KeyWidget::map()\&.
.PP
.nf
121 { return keyWidth; }
.fi
.SH "Field Documentation"
.PP 
.SS "QHash<QString, \fBKey\fP> KeyMap::_keys\fC [private]\fP"

.PP
Definition at line 148 of file keymap\&.h\&.
.PP
Referenced by contains(), count(), key(), keys(), map(), operator const QHash< QString, Key > &(), and positions()\&.
.SS "short KeyMap::keyHeight\fC [private]\fP"

.PP
Definition at line 149 of file keymap\&.h\&.
.PP
Referenced by height()\&.
.SS "\fBLayout\fP KeyMap::keyLayout\fC [private]\fP"

.PP
Definition at line 151 of file keymap\&.h\&.
.PP
Referenced by isISO(), layout(), and strLayout()\&.
.SS "\fBModel\fP KeyMap::keyModel\fC [private]\fP"

.PP
Definition at line 150 of file keymap\&.h\&.
.PP
Referenced by isKeyboard(), isMouse(), model(), and strModel()\&.
.SS "short KeyMap::keyWidth\fC [private]\fP"

.PP
Definition at line 149 of file keymap\&.h\&.
.PP
Referenced by width()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
