.TH "src/ckb-daemon/device.h" 3 "Sun Jun 4 2017" "Version beta-v0.2.8+testing at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/device.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br
\fC#include 'keymap\&.h'\fP
.br
\fC#include <limits\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEV_MAX\fP   9"
.br
.ti -1c
.RI "#define \fBIS_CONNECTED\fP(kb)   ((kb) && (kb)->handle && (kb)->uinput_kb && (kb)->uinput_mouse)"
.br
.ti -1c
.RI "#define \fBdmutex\fP(kb)   (\fBdevmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBimutex\fP(kb)   (\fBinputmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBmmutex\fP(kb)   (\fBmacromutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"
.br
.ti -1c
.RI "#define \fBsetactive\fP(kb, makeactive)   ((makeactive) ? (kb)->vtable->active((kb), 0, 0, 0, 0) : (kb)->vtable->idle((kb), 0, 0, 0, 0))"
.br
.RI "\fI\fBsetactive()\fP calls via the corresponding kb->vtable either the active() or the idle() function\&. 
.br
 active() is called if the parameter makeactive is true, idle if it is false\&. 
.br
 What function is called effectively is device dependent\&. Have a look at \fI\fBdevice_vtable\&.c\fP\fP for more information\&. \fP"
.ti -1c
.RI "#define \fBIN_HID\fP   0x80"
.br
.ti -1c
.RI "#define \fBIN_CORSAIR\fP   0x40"
.br
.ti -1c
.RI "#define \fBACT_LIGHT\fP   1"
.br
.ti -1c
.RI "#define \fBACT_NEXT\fP   3"
.br
.ti -1c
.RI "#define \fBACT_NEXT_NOWRAP\fP   5"
.br
.ti -1c
.RI "#define \fBACT_LOCK\fP   8"
.br
.ti -1c
.RI "#define \fBACT_MR_RING\fP   9"
.br
.ti -1c
.RI "#define \fBACT_M1\fP   10"
.br
.ti -1c
.RI "#define \fBACT_M2\fP   11"
.br
.ti -1c
.RI "#define \fBACT_M3\fP   12"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBstart_dev\fP (\fBusbdevice\fP *kb, int makeactive)"
.br
.ti -1c
.RI "int \fBstart_kb_nrgb\fP (\fBusbdevice\fP *kb, int makeactive)"
.br
.ti -1c
.RI "int \fBsetactive_kb\fP (\fBusbdevice\fP *kb, int active)"
.br
.ti -1c
.RI "int \fBsetactive_mouse\fP (\fBusbdevice\fP *kb, int active)"
.br
.ti -1c
.RI "int \fBcmd_active_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_active_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_idle_kb\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_idle_mouse\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int dummy3, const char *dummy4)"
.br
.ti -1c
.RI "int \fBcmd_pollrate\fP (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, int dummy2, int rate, const char *dummy3)"
.br
.ti -1c
.RI "void \fBsetmodeindex_nrgb\fP (\fBusbdevice\fP *kb, int index)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBusbdevice\fP \fBkeyboard\fP [9]"
.br
.RI "\fIremember all usb devices\&. Needed for \fBcloseusb()\fP\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBdevmutex\fP [9]"
.br
.ti -1c
.RI "pthread_mutex_t \fBinputmutex\fP [9]"
.br
.ti -1c
.RI "pthread_mutex_t \fBmacromutex\fP [9]"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ACT_LIGHT   1"

.PP
Definition at line 64 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_LOCK   8"

.PP
Definition at line 67 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_M1   10"

.PP
Definition at line 69 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_M2   11"

.PP
Definition at line 70 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_M3   12"

.PP
Definition at line 71 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_MR_RING   9"

.PP
Definition at line 68 of file device\&.h\&.
.PP
Referenced by setactive_kb()\&.
.SS "#define ACT_NEXT   3"

.PP
Definition at line 65 of file device\&.h\&.
.SS "#define ACT_NEXT_NOWRAP   5"

.PP
Definition at line 66 of file device\&.h\&.
.SS "#define DEV_MAX   9"

.PP
Definition at line 8 of file device\&.h\&.
.PP
Referenced by _updateconnected(), quitWithLock(), usb_rm_device(), and usbadd()\&.
.SS "#define dmutex(kb)   (\fBdevmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 18 of file device\&.h\&.
.PP
Referenced by _ledthread(), _setupusb(), closeusb(), devmain(), and usbadd()\&.
.SS "#define imutex(kb)   (\fBinputmutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 22 of file device\&.h\&.
.PP
Referenced by _setupusb(), closeusb(), cmd_bind(), cmd_erase(), cmd_eraseprofile(), cmd_get(), cmd_macro(), cmd_notify(), cmd_rebind(), cmd_unbind(), os_inputmain(), setactive_kb(), setactive_mouse(), and setupusb()\&.
.SS "#define IN_CORSAIR   0x40"

.PP
Definition at line 61 of file device\&.h\&.
.PP
Referenced by setactive_kb(), and setactive_mouse()\&.
.SS "#define IN_HID   0x80"

.PP
Definition at line 60 of file device\&.h\&.
.PP
Referenced by setactive_kb(), and setactive_mouse()\&.
.SS "#define IS_CONNECTED(kb)   ((kb) && (kb)->handle && (kb)->uinput_kb && (kb)->uinput_mouse)"

.PP
Definition at line 12 of file device\&.h\&.
.PP
Referenced by _updateconnected(), devmain(), quitWithLock(), and usbadd()\&.
.SS "#define mmutex(kb)   (\fBmacromutex\fP + \fBINDEX_OF\fP(kb, \fBkeyboard\fP))"

.PP
Definition at line 26 of file device\&.h\&.
.PP
Referenced by _usbsend(), and inputupdate_keys()\&.
.SS "#define setactive(kb, makeactive)   ((makeactive) ? (kb)->vtable->active((kb), 0, 0, 0, 0) : (kb)->vtable->idle((kb), 0, 0, 0, 0))"

.PP
Definition at line 40 of file device\&.h\&.
.PP
Referenced by _start_dev(), and revertusb()\&.
.SH "Function Documentation"
.PP 
.SS "int cmd_active_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 112 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
112                                                                                              {
113     return setactive_kb(kb, 1);
114 }
.fi
.SS "int cmd_active_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 44 of file device_mouse\&.c\&.
.PP
References setactive_mouse()\&.
.PP
.nf
44                                                                                                 {
45     return setactive_mouse(kb, 1);
46 }
.fi
.SS "int cmd_idle_kb (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 116 of file device_keyboard\&.c\&.
.PP
References setactive_kb()\&.
.PP
.nf
116                                                                                            {
117     return setactive_kb(kb, 0);
118 }
.fi
.SS "int cmd_idle_mouse (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intdummy3, const char *dummy4)"

.PP
Definition at line 48 of file device_mouse\&.c\&.
.PP
References setactive_mouse()\&.
.PP
.nf
48                                                                                               {
49     return setactive_mouse(kb, 0);
50 }
.fi
.SS "int cmd_pollrate (\fBusbdevice\fP *kb, \fBusbmode\fP *dummy1, intdummy2, intrate, const char *dummy3)"

.PP
Definition at line 52 of file device_mouse\&.c\&.
.PP
References MSG_SIZE, usbdevice::pollrate, and usbsend\&.
.PP
.nf
52                                                                                           {
53     uchar msg[MSG_SIZE] = {
54         0x07, 0x0a, 0, 0, (uchar)rate
55     };
56     if(!usbsend(kb, msg, 1))
57         return -1;
58     // Device should disconnect+reconnect, but update the poll rate field in case it doesn't
59     kb->pollrate = rate;
60     return 0;
61 }
.fi
.SS "int setactive_kb (\fBusbdevice\fP *kb, intactive)"

.PP
Definition at line 18 of file device_keyboard\&.c\&.
.PP
References ACT_LIGHT, ACT_LOCK, ACT_M1, ACT_M2, ACT_M3, ACT_MR_RING, usbdevice::active, DELAY_MEDIUM, lighting::forceupdate, imutex, IN_CORSAIR, IN_HID, usbdevice::input, inputupdate(), keymap, usbinput::keys, usbprofile::lastlight, MSG_SIZE, N_KEYS_HW, NEEDS_FW_UPDATE, usbdevice::profile, usbsend, and usbdevice::vtable\&.
.PP
Referenced by cmd_active_kb(), and cmd_idle_kb()\&.
.PP
.nf
18                                            {
19     if(NEEDS_FW_UPDATE(kb))
20         return 0;
21 
22     pthread_mutex_lock(imutex(kb));
23     kb->active = !!active;
24     kb->profile->lastlight\&.forceupdate = 1;
25     // Clear input
26     memset(&kb->input\&.keys, 0, sizeof(kb->input\&.keys));
27     inputupdate(kb);
28     pthread_mutex_unlock(imutex(kb));
29 
30     uchar msg[3][MSG_SIZE] = {
31         { 0x07, 0x04, 0 },                  // Disables or enables HW control for top row
32         { 0x07, 0x40, 0 },                  // Selects key input
33         { 0x07, 0x05, 2, 0, 0x03, 0x00 }    // Commits key input selection
34     };
35     if(active){
36         // Put the M-keys (K95) as well as the Brightness/Lock keys into software-controlled mode\&.
37         msg[0][2] = 2;
38         if(!usbsend(kb, msg[0], 1))
39             return -1;
40         DELAY_MEDIUM(kb);
41         // Set input mode on the keys\&. They must be grouped into packets of 60 bytes (+ 4 bytes header)
42         // Keys are referenced in byte pairs, with the first byte representing the key and the second byte representing the mode\&.
43         for(int key = 0; key < N_KEYS_HW; ){
44             int pair;
45             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
46                 // Select both standard and Corsair input\&. The standard input will be ignored except in BIOS mode\&.
47                 uchar action = IN_HID | IN_CORSAIR;
48                 // Additionally, make MR activate the MR ring (this is disabled for now, may be back later)
49                 //if(keymap[key]\&.name && !strcmp(keymap[key]\&.name, "mr"))
50                 //    action |= ACT_MR_RING;
51                 msg[1][4 + pair * 2] = key;
52                 msg[1][5 + pair * 2] = action;
53             }
54             // Byte 2 = pair count (usually 30, less on final message)
55             msg[1][2] = pair;
56             if(!usbsend(kb, msg[1], 1))
57                 return -1;
58         }
59         // Commit new input settings
60         if(!usbsend(kb, msg[2], 1))
61             return -1;
62         DELAY_MEDIUM(kb);
63     } else {
64         // Set the M-keys back into hardware mode, restore hardware RGB profile\&. It has to be sent twice for some reason\&.
65         msg[0][2] = 1;
66         if(!usbsend(kb, msg[0], 1))
67             return -1;
68         DELAY_MEDIUM(kb);
69         if(!usbsend(kb, msg[0], 1))
70             return -1;
71         DELAY_MEDIUM(kb);
72 #ifdef OS_LINUX
73         // On OSX the default key mappings are fine\&. On Linux, the G keys will freeze the keyboard\&. Set the keyboard entirely to HID input\&.
74         for(int key = 0; key < N_KEYS_HW; ){
75             int pair;
76             for(pair = 0; pair < 30 && key < N_KEYS_HW; pair++, key++){
77                 uchar action = IN_HID;
78                 // Enable hardware actions
79                 if(keymap[key]\&.name){
80                     if(!strcmp(keymap[key]\&.name, "mr"))
81                         action = ACT_MR_RING;
82                     else if(!strcmp(keymap[key]\&.name, "m1"))
83                         action = ACT_M1;
84                     else if(!strcmp(keymap[key]\&.name, "m2"))
85                         action = ACT_M2;
86                     else if(!strcmp(keymap[key]\&.name, "m3"))
87                         action = ACT_M3;
88                     else if(!strcmp(keymap[key]\&.name, "light"))
89                         action = ACT_LIGHT;
90                     else if(!strcmp(keymap[key]\&.name, "lock"))
91                         action = ACT_LOCK;
92                 }
93                 msg[1][4 + pair * 2] = key;
94                 msg[1][5 + pair * 2] = action;
95             }
96             // Byte 2 = pair count (usually 30, less on final message)
97             msg[1][2] = pair;
98             if(!usbsend(kb, msg[1], 1))
99                 return -1;
100         }
101         // Commit new input settings
102         if(!usbsend(kb, msg[2], 1))
103             return -1;
104         DELAY_MEDIUM(kb);
105 #endif
106     }
107     // Update indicator LEDs if the profile contains settings for them
108     kb->vtable->updateindicators(kb, 0);
109     return 0;
110 }
.fi
.SS "int setactive_mouse (\fBusbdevice\fP *kb, intactive)"

.PP
Definition at line 9 of file device_mouse\&.c\&.
.PP
References usbdevice::active, lighting::forceupdate, imutex, IN_CORSAIR, IN_HID, usbdevice::input, inputupdate(), usbinput::keys, usbprofile::lastlight, MSG_SIZE, NEEDS_FW_UPDATE, usbdevice::profile, and usbsend\&.
.PP
Referenced by cmd_active_mouse(), and cmd_idle_mouse()\&.
.PP
.nf
9                                               {
10     if(NEEDS_FW_UPDATE(kb))
11         return 0;
12     const int keycount = 20;
13     uchar msg[2][MSG_SIZE] = {
14         { 0x07, 0x04, 0 },                  // Disables or enables HW control for DPI and Sniper button
15         { 0x07, 0x40, keycount, 0 },        // Select button input (simlilar to the packet sent to keyboards, but lacks a commit packet)
16     };
17     if(active)
18         // Put the mouse into SW mode
19         msg[0][2] = 2;
20     else
21         // Restore HW mode
22         msg[0][2] = 1;
23     pthread_mutex_lock(imutex(kb));
24     kb->active = !!active;
25     kb->profile->lastlight\&.forceupdate = 1;
26     // Clear input
27     memset(&kb->input\&.keys, 0, sizeof(kb->input\&.keys));
28     inputupdate(kb);
29     pthread_mutex_unlock(imutex(kb));
30     if(!usbsend(kb, msg[0], 1))
31         return -1;
32     if(active){
33         // Set up key input
34         if(!usbsend(kb, msg[1], 1))
35             return -1;
36         for(int i = 0; i < keycount; i++){
37             msg[1][i * 2 + 4] = i + 1;
38             msg[1][i * 2 + 5] = (i < 6 ? IN_HID : IN_CORSAIR);
39         }
40     }
41     return 0;
42 }
.fi
.SS "void setmodeindex_nrgb (\fBusbdevice\fP *kb, intindex)"

.PP
Definition at line 120 of file device_keyboard\&.c\&.
.PP
References NK95_M1, NK95_M2, NK95_M3, and nk95cmd\&.
.PP
.nf
120                                                 {
121     switch(index % 3){
122     case 0:
123         nk95cmd(kb, NK95_M1);
124         break;
125     case 1:
126         nk95cmd(kb, NK95_M2);
127         break;
128     case 2:
129         nk95cmd(kb, NK95_M3);
130         break;
131     }
132 }
.fi
.SS "int start_dev (\fBusbdevice\fP *kb, intmakeactive)"

.PP
Definition at line 78 of file device\&.c\&.
.PP
References _start_dev(), USB_DELAY_DEFAULT, and usbdevice::usbdelay\&.
.PP
.nf
78                                             {
79     // Force USB interval to 10ms during initial setup phase; return to nominal 5ms after setup completes\&.
80     kb->usbdelay = 10;
81     int res = _start_dev(kb, makeactive);
82     kb->usbdelay = USB_DELAY_DEFAULT;
83     return res;
84 }
.fi
.SS "int start_kb_nrgb (\fBusbdevice\fP *kb, intmakeactive)"

.PP
Definition at line 9 of file device_keyboard\&.c\&.
.PP
References usbdevice::active, NK95_HWOFF, nk95cmd, and usbdevice::pollrate\&.
.PP
.nf
9                                                 {
10     // Put the non-RGB K95 into software mode\&. Nothing else needs to be done hardware wise
11     nk95cmd(kb, NK95_HWOFF);
12     // Fill out RGB features for consistency, even though the keyboard doesn't have them
13     kb->active = 1;
14     kb->pollrate = -1;
15     return 0;
16 }
.fi
.SH "Variable Documentation"
.PP 
.SS "pthread_mutex_t devmutex[9]"

.PP
Definition at line 12 of file device\&.c\&.
.PP
Referenced by _updateconnected(), quitWithLock(), and usb_rm_device()\&.
.SS "pthread_mutex_t inputmutex[9]"

.PP
Definition at line 13 of file device\&.c\&.
.SS "\fBusbdevice\fP keyboard[9]"

.PP
Definition at line 10 of file device\&.c\&.
.PP
Referenced by _mkdevpath(), _mknotifynode(), _rmnotifynode(), _setupusb(), _updateconnected(), closeusb(), main(), mkfwnode(), os_closeusb(), os_inputmain(), os_inputopen(), os_setupusb(), quitWithLock(), rmdevpath(), usb_rm_device(), and usbadd()\&.
.SS "pthread_mutex_t macromutex[9]"

.PP
Definition at line 14 of file device\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
