.TH "src/ckb/ckb-anim.h" 3 "Sun Jun 4 2017" "Version beta-v0.2.8+testing at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb/ckb-anim.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <ctype\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBckb_key\fP"
.br
.ti -1c
.RI "struct \fBckb_runctx\fP"
.br
.ti -1c
.RI "struct \fBckb_gradient\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBM_PI\fP   3\&.14159265358979323846"
.br
.ti -1c
.RI "#define \fBTRUE\fP   1"
.br
.ti -1c
.RI "#define \fBFALSE\fP   0"
.br
.ti -1c
.RI "#define \fBCKB_DOWN\fP   1"
.br
.ti -1c
.RI "#define \fBCKB_UP\fP   0"
.br
.ti -1c
.RI "#define \fBCKB_CONTAINER\fP(macro)   do { macro } while(0)"
.br
.ti -1c
.RI "#define \fBCKB_GUID\fP(guid)   \fBCKB_CONTAINER\fP( printf('guid '); printurl(guid); printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_NAME\fP(name)   \fBCKB_CONTAINER\fP( printf('name '); printurl(name); printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_VERSION\fP(version)   \fBCKB_CONTAINER\fP( printf('version '); printurl(version); printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_COPYRIGHT\fP(year, author)   \fBCKB_CONTAINER\fP( printf('author '); printurl(author); printf('\\nyear %s\\n', year); )"
.br
.ti -1c
.RI "#define \fBCKB_LICENSE\fP(license)   \fBCKB_CONTAINER\fP( printf('license '); printurl(license); printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_DESCRIPTION\fP(description)   \fBCKB_CONTAINER\fP( printf('description '); printurl(description); printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_PARAM\fP(type, name, prefix, postfix, extra)   \fBCKB_CONTAINER\fP( printf('param %s %s ', type, name); \fBprinturl\fP(prefix); printf(' '); \fBprinturl\fP(postfix); printf(' '); extra; printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_LONG\fP(name, prefix, postfix, default, \fBmin\fP, \fBmax\fP)   \fBCKB_PARAM\fP('long', name, prefix, postfix, printf('%ld %ld %ld', (long)(default), (long)(\fBmin\fP), (long)(\fBmax\fP)))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_DOUBLE\fP(name, prefix, postfix, default, \fBmin\fP, \fBmax\fP)   \fBCKB_PARAM\fP('double', name, prefix, postfix, printf('%lf %lf %lf', (double)(default), (double)(\fBmin\fP), (double)(\fBmax\fP)))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_BOOL\fP(name, text, default)   \fBCKB_PARAM\fP('bool', name, text, '', printf((default) ? '1' : '0'))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_RGB\fP(name, prefix, postfix, r, g, b)   \fBCKB_PARAM\fP('rgb', name, prefix, postfix, printf('%02x%02x%02x', (unsigned char)(r), (unsigned char)(g), (unsigned char)(b)))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_ARGB\fP(name, prefix, postfix, a, r, g, b)   \fBCKB_PARAM\fP('argb', name, prefix, postfix, printf('%02x%02x%02x%02x', (unsigned char)(a), (unsigned char)(r), (unsigned char)(g), (unsigned char)(b)))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_GRADIENT\fP(name, prefix, postfix, default)   \fBCKB_PARAM\fP('gradient', name, prefix, postfix, \fBprinturl\fP(default))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_AGRADIENT\fP(name, prefix, postfix, default)   \fBCKB_PARAM\fP('agradient', name, prefix, postfix, \fBprinturl\fP(default))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_ANGLE\fP(name, prefix, postfix, default)   \fBCKB_PARAM\fP('angle', name, prefix, postfix, printf('%ld', (long)(default)))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_STRING\fP(name, prefix, postfix, default)   \fBCKB_PARAM\fP('string', name, prefix, postfix, \fBprinturl\fP(default))"
.br
.ti -1c
.RI "#define \fBCKB_PARAM_LABEL\fP(name, text)   \fBCKB_PARAM\fP('label', name, text, '', )"
.br
.ti -1c
.RI "#define \fBCKB_PRESET_START\fP(name)   \fBCKB_CONTAINER\fP( printf('preset '); printurl(name); )"
.br
.ti -1c
.RI "#define \fBCKB_PRESET_PARAM\fP(name, value)   \fBCKB_CONTAINER\fP( printf(' %s=', name); \fBprinturl\fP(value); )"
.br
.ti -1c
.RI "#define \fBCKB_PRESET_END\fP   \fBCKB_CONTAINER\fP( printf('\\n'); )"
.br
.ti -1c
.RI "#define \fBCKB_KP_NONE\fP   'none'"
.br
.ti -1c
.RI "#define \fBCKB_KP_NAME\fP   'name'"
.br
.ti -1c
.RI "#define \fBCKB_KP_POSITION\fP   'position'"
.br
.ti -1c
.RI "#define \fBCKB_KPMODE\fP(mode)   \fBCKB_CONTAINER\fP( printf('kpmode %s\\n', mode); )"
.br
.ti -1c
.RI "#define \fBCKB_TIME_DURATION\fP   'duration'"
.br
.ti -1c
.RI "#define \fBCKB_TIME_ABSOLUTE\fP   'absolute'"
.br
.ti -1c
.RI "#define \fBCKB_TIMEMODE\fP(mode)   \fBCKB_CONTAINER\fP( printf('time %s\\n', mode); )"
.br
.ti -1c
.RI "#define \fBCKB_REPEAT\fP(enable)   \fBCKB_CONTAINER\fP( printf('repeat %s\\n', (enable) ? 'on' : 'off'); )"
.br
.ti -1c
.RI "#define \fBCKB_PREEMPT\fP(enable)   \fBCKB_CONTAINER\fP( printf('preempt %s\\n', (enable) ? 'on' : 'off'); )"
.br
.ti -1c
.RI "#define \fBCKB_LIVEPARAMS\fP(enable)   \fBCKB_CONTAINER\fP( printf('parammode %s\\n', (enable) ? 'live' : 'static'); )"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_LONG\fP(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%ld', value_ptr) == 1)"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_DOUBLE\fP(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%lf', value_ptr) == 1)"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_BOOL\fP(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%u', value_ptr) == 1)"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_RGB\fP(param_name, r_ptr, g_ptr, b_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%2hhx%2hhx%2hhx', r_ptr, g_ptr, b_ptr) == 3)"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_ARGB\fP(param_name, a_ptr, r_ptr, g_ptr, b_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%2hhx%2hhx%2hhx%2hhx', a_ptr, r_ptr, g_ptr, b_ptr) == 4)"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_GRADIENT\fP(param_name, gradient_ptr)   if(!strcmp(name, param_name) && \fBckb_scan_grad\fP(value, gradient_ptr, 0))"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_AGRADIENT\fP(param_name, gradient_ptr)   if(!strcmp(name, param_name) && \fBckb_scan_grad\fP(value, gradient_ptr, 1))"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_ANGLE\fP(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%ld', value_ptr) == 1)"
.br
.ti -1c
.RI "#define \fBCKB_PARSE_STRING\fP(param_name)   if(!strcmp(name, param_name))"
.br
.ti -1c
.RI "#define \fBCKB_REAL_ANGLE\fP(\fBangle\fP)   fmod((-(\fBangle\fP) + 90\&.) * \fBM_PI\fP / 180\&. + \fBM_PI\fP * 2\&., \fBM_PI\fP * 2\&.)"
.br
.ti -1c
.RI "#define \fBCKB_KEYNAME_MAX\fP   12"
.br
.ti -1c
.RI "#define \fBCKB_KEYCLEAR\fP(context)   \fBCKB_CONTAINER\fP( \fBckb_key\fP* \fBkey\fP = context->keys; unsigned count = context->keycount; unsigned i = 0; for(; i < count; i++) \fBkey\fP[i]\&.a = \fBkey\fP[i]\&.r = \fBkey\fP[i]\&.g = \fBkey\fP[i]\&.b = 0; )"
.br
.ti -1c
.RI "#define \fBCKB_GRAD_MAX\fP   100"
.br
.ti -1c
.RI "#define \fBCKB_MAX_WORD\fP   (4 * 1024)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBckb_scan_grad\fP (const char *string, \fBckb_gradient\fP *gradient, int alpha)"
.br
.ti -1c
.RI "void \fBckb_grad_color\fP (float *a, float *r, float *g, float *b, const \fBckb_gradient\fP *grad, float pos)"
.br
.ti -1c
.RI "void \fBckb_alpha_blend\fP (\fBckb_key\fP *\fBkey\fP, float a, float r, float g, float b)"
.br
.ti -1c
.RI "void \fBprinturl\fP (const char *src)"
.br
.ti -1c
.RI "void \fBurldecode\fP (char *dst, const char *src)"
.br
.ti -1c
.RI "void \fBckb_getline\fP (char word1[(4 *1024)], char word2[(4 *1024)], char word3[(4 *1024)])"
.br
.ti -1c
.RI "void \fBckb_info\fP ()"
.br
.ti -1c
.RI "void \fBckb_init\fP (\fBckb_runctx\fP *context)"
.br
.ti -1c
.RI "void \fBckb_parameter\fP (\fBckb_runctx\fP *, const char *, const char *)"
.br
.ti -1c
.RI "void \fBckb_keypress\fP (\fBckb_runctx\fP *, \fBckb_key\fP *, int, int, int)"
.br
.ti -1c
.RI "void \fBckb_start\fP (\fBckb_runctx\fP *, int)"
.br
.ti -1c
.RI "void \fBckb_time\fP (\fBckb_runctx\fP *, double)"
.br
.ti -1c
.RI "int \fBckb_frame\fP (\fBckb_runctx\fP *)"
.br
.ti -1c
.RI "void \fBckb_read_params\fP (\fBckb_runctx\fP *ctx)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct ckb_key"
.PP 
Definition at line 131 of file ckb-anim\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
unsigned char \fIa\fP 
.br
.PP
unsigned char \fIb\fP 
.br
.PP
unsigned char \fIg\fP 
.br
.PP
char \fIname[12]\fP 
.br
.PP
unsigned char \fIr\fP 
.br
.PP
int \fIx\fP 
.br
.PP
int \fIy\fP 
.br
.PP
.RE
.PP
.SH "struct ckb_runctx"
.PP 
Definition at line 138 of file ckb-anim\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
unsigned \fIheight\fP 
.br
.PP
unsigned \fIkeycount\fP 
.br
.PP
\fBckb_key\fP * \fIkeys\fP 
.br
.PP
unsigned \fIwidth\fP 
.br
.PP
.RE
.PP
.SH "struct ckb_gradient"
.PP 
Definition at line 152 of file ckb-anim\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
unsigned char \fIa[100]\fP 
.br
.PP
unsigned char \fIb[100]\fP 
.br
.PP
unsigned char \fIg[100]\fP 
.br
.PP
int \fIptcount\fP 
.br
.PP
char \fIpts[100]\fP 
.br
.PP
unsigned char \fIr[100]\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define CKB_CONTAINER(macro)   do { macro } while(0)"

.PP
Definition at line 57 of file ckb-anim\&.h\&.
.SS "#define CKB_COPYRIGHT(year, author)   \fBCKB_CONTAINER\fP( printf('author '); printurl(author); printf('\\nyear %s\\n', year); )"

.PP
Definition at line 66 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_DESCRIPTION(description)   \fBCKB_CONTAINER\fP( printf('description '); printurl(description); printf('\\n'); )"

.PP
Definition at line 70 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_DOWN   1"

.PP
Definition at line 52 of file ckb-anim\&.h\&.
.SS "#define CKB_GRAD_MAX   100"

.PP
Definition at line 151 of file ckb-anim\&.h\&.
.SS "#define CKB_GUID(guid)   \fBCKB_CONTAINER\fP( printf('guid '); printurl(guid); printf('\\n'); )"

.PP
Definition at line 60 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_KEYCLEAR(context)   \fBCKB_CONTAINER\fP( \fBckb_key\fP* \fBkey\fP = context->keys; unsigned count = context->keycount; unsigned i = 0; for(; i < count; i++) \fBkey\fP[i]\&.a = \fBkey\fP[i]\&.r = \fBkey\fP[i]\&.g = \fBkey\fP[i]\&.b = 0; )"

.PP
Definition at line 148 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_frame()\&.
.SS "#define CKB_KEYNAME_MAX   12"

.PP
Definition at line 130 of file ckb-anim\&.h\&.
.PP
Referenced by main()\&.
.SS "#define CKB_KP_NAME   'name'"

.PP
Definition at line 91 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_KP_NONE   'none'"

.PP
Definition at line 90 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_KP_POSITION   'position'"

.PP
Definition at line 92 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_KPMODE(mode)   \fBCKB_CONTAINER\fP( printf('kpmode %s\\n', mode); )"

.PP
Definition at line 93 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_LICENSE(license)   \fBCKB_CONTAINER\fP( printf('license '); printurl(license); printf('\\n'); )"

.PP
Definition at line 68 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_LIVEPARAMS(enable)   \fBCKB_CONTAINER\fP( printf('parammode %s\\n', (enable) ? 'live' : 'static'); )"

.PP
Definition at line 104 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_MAX_WORD   (4 * 1024)"

.PP
Definition at line 238 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_read_params(), and main()\&.
.SS "#define CKB_NAME(name)   \fBCKB_CONTAINER\fP( printf('name '); printurl(name); printf('\\n'); )"

.PP
Definition at line 62 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM(type, name, prefix, postfix, extra)   \fBCKB_CONTAINER\fP( printf('param %s %s ', type, name); \fBprinturl\fP(prefix); printf(' '); \fBprinturl\fP(postfix); printf(' '); extra; printf('\\n'); )"

.PP
Definition at line 73 of file ckb-anim\&.h\&.
.SS "#define CKB_PARAM_AGRADIENT(name, prefix, postfix, default)   \fBCKB_PARAM\fP('agradient', name, prefix, postfix, \fBprinturl\fP(default))"

.PP
Definition at line 80 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM_ANGLE(name, prefix, postfix, default)   \fBCKB_PARAM\fP('angle', name, prefix, postfix, printf('%ld', (long)(default)))"

.PP
Definition at line 81 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM_ARGB(name, prefix, postfix, a, r, g, b)   \fBCKB_PARAM\fP('argb', name, prefix, postfix, printf('%02x%02x%02x%02x', (unsigned char)(a), (unsigned char)(r), (unsigned char)(g), (unsigned char)(b)))"

.PP
Definition at line 78 of file ckb-anim\&.h\&.
.SS "#define CKB_PARAM_BOOL(name, text, default)   \fBCKB_PARAM\fP('bool', name, text, '', printf((default) ? '1' : '0'))"

.PP
Definition at line 76 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM_DOUBLE(name, prefix, postfix, default, \fBmin\fP, \fBmax\fP)   \fBCKB_PARAM\fP('double', name, prefix, postfix, printf('%lf %lf %lf', (double)(default), (double)(\fBmin\fP), (double)(\fBmax\fP)))"

.PP
Definition at line 75 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM_GRADIENT(name, prefix, postfix, default)   \fBCKB_PARAM\fP('gradient', name, prefix, postfix, \fBprinturl\fP(default))"

.PP
Definition at line 79 of file ckb-anim\&.h\&.
.SS "#define CKB_PARAM_LABEL(name, text)   \fBCKB_PARAM\fP('label', name, text, '', )"

.PP
Definition at line 83 of file ckb-anim\&.h\&.
.SS "#define CKB_PARAM_LONG(name, prefix, postfix, default, \fBmin\fP, \fBmax\fP)   \fBCKB_PARAM\fP('long', name, prefix, postfix, printf('%ld %ld %ld', (long)(default), (long)(\fBmin\fP), (long)(\fBmax\fP)))"

.PP
Definition at line 74 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM_RGB(name, prefix, postfix, r, g, b)   \fBCKB_PARAM\fP('rgb', name, prefix, postfix, printf('%02x%02x%02x', (unsigned char)(r), (unsigned char)(g), (unsigned char)(b)))"

.PP
Definition at line 77 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PARAM_STRING(name, prefix, postfix, default)   \fBCKB_PARAM\fP('string', name, prefix, postfix, \fBprinturl\fP(default))"

.PP
Definition at line 82 of file ckb-anim\&.h\&.
.SS "#define CKB_PARSE_AGRADIENT(param_name, gradient_ptr)   if(!strcmp(name, param_name) && \fBckb_scan_grad\fP(value, gradient_ptr, 1))"

.PP
Definition at line 121 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_PARSE_ANGLE(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%ld', value_ptr) == 1)"

.PP
Definition at line 122 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_PARSE_ARGB(param_name, a_ptr, r_ptr, g_ptr, b_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%2hhx%2hhx%2hhx%2hhx', a_ptr, r_ptr, g_ptr, b_ptr) == 4)"

.PP
Definition at line 119 of file ckb-anim\&.h\&.
.SS "#define CKB_PARSE_BOOL(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%u', value_ptr) == 1)"

.PP
Definition at line 117 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_PARSE_DOUBLE(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%lf', value_ptr) == 1)"

.PP
Definition at line 116 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_PARSE_GRADIENT(param_name, gradient_ptr)   if(!strcmp(name, param_name) && \fBckb_scan_grad\fP(value, gradient_ptr, 0))"

.PP
Definition at line 120 of file ckb-anim\&.h\&.
.SS "#define CKB_PARSE_LONG(param_name, value_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%ld', value_ptr) == 1)"

.PP
Definition at line 115 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_PARSE_RGB(param_name, r_ptr, g_ptr, b_ptr)   if(!strcmp(name, param_name) && sscanf(value, '%2hhx%2hhx%2hhx', r_ptr, g_ptr, b_ptr) == 3)"

.PP
Definition at line 118 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_PARSE_STRING(param_name)   if(!strcmp(name, param_name))"

.PP
Definition at line 123 of file ckb-anim\&.h\&.
.SS "#define CKB_PREEMPT(enable)   \fBCKB_CONTAINER\fP( printf('preempt %s\\n', (enable) ? 'on' : 'off'); )"

.PP
Definition at line 102 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PRESET_END   \fBCKB_CONTAINER\fP( printf('\\n'); )"

.PP
Definition at line 87 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PRESET_PARAM(name, value)   \fBCKB_CONTAINER\fP( printf(' %s=', name); \fBprinturl\fP(value); )"

.PP
Definition at line 86 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_PRESET_START(name)   \fBCKB_CONTAINER\fP( printf('preset '); printurl(name); )"

.PP
Definition at line 85 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_REAL_ANGLE(\fBangle\fP)   fmod((-(\fBangle\fP) + 90\&.) * \fBM_PI\fP / 180\&. + \fBM_PI\fP * 2\&., \fBM_PI\fP * 2\&.)"

.PP
Definition at line 127 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_parameter()\&.
.SS "#define CKB_REPEAT(enable)   \fBCKB_CONTAINER\fP( printf('repeat %s\\n', (enable) ? 'on' : 'off'); )"

.PP
Definition at line 99 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_TIME_ABSOLUTE   'absolute'"

.PP
Definition at line 96 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_TIME_DURATION   'duration'"

.PP
Definition at line 95 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_TIMEMODE(mode)   \fBCKB_CONTAINER\fP( printf('time %s\\n', mode); )"

.PP
Definition at line 97 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define CKB_UP   0"

.PP
Definition at line 53 of file ckb-anim\&.h\&.
.SS "#define CKB_VERSION(version)   \fBCKB_CONTAINER\fP( printf('version '); printurl(version); printf('\\n'); )"

.PP
Definition at line 64 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define FALSE   0"

.PP
Definition at line 49 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SS "#define M_PI   3\&.14159265358979323846"

.PP
Definition at line 42 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_frame(), and ckb_parameter()\&.
.SS "#define TRUE   1"

.PP
Definition at line 46 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_info()\&.
.SH "Function Documentation"
.PP 
.SS "void ckb_alpha_blend (\fBckb_key\fP *key, floata, floatr, floatg, floatb)"

.PP
Definition at line 283 of file ckb-anim\&.h\&.
.PP
References ckb_key::a, ckb_key::b, ckb_key::g, and ckb_key::r\&.
.PP
Referenced by ckb_frame()\&.
.PP
.nf
283                                                                       {
284     a /= 255\&.f;
285     float ka = key->a / 255\&.f;
286     float a2 = a + (1\&.f - a) * ka;
287     if(a2 == 0\&.f){
288         key->a = key->r = key->g = key->b = 0;
289         return;
290     }
291     key->a = round(a2 * 255\&.f);
292     key->r = round((r * a + key->r * ka * (1\&.f - a)) / a2);
293     key->g = round((g * a + key->g * ka * (1\&.f - a)) / a2);
294     key->b = round((b * a + key->b * ka * (1\&.f - a)) / a2);
295 }
.fi
.SS "int ckb_frame (\fBckb_runctx\fP *)"

.PP
Definition at line 137 of file main\&.c\&.
.PP
References ckb_key::a, aa, ab, ag, angle, ANGLE, anim, ANIM_MAX, animcolor, animlength, ar, ckb_key::b, ckb_alpha_blend(), ckb_grad_color(), CKB_KEYCLEAR, counter_clock, drop, DROP_MAX, ffade, frame, ckb_key::g, getFreqDec(), keyAnim::gradient, ckb_runctx::height, HOLD, ckb_runctx::keycount, ckb_runctx::keys, M_PI, max(), min(), phase, power, powers, pressestofull, ckb_key::r, randomBright, randomize, symmetric, keyAnim::target, width, ckb_runctx::width, x, and y\&.
.PP
Referenced by main()\&.
.PP
.nf
137                                   {
138     // Draw key colors
139     unsigned count = context->keycount;
140     for(unsigned i = 0; i < count; i++){
141         float phase = anim[i]\&.target;
142 
143         if(phase == HOLD)
144             phase = 0\&.f;
145         else if(phase < 0\&.f)
146             phase = 1\&.f;
147         ckb_key* key = context->keys + i;
148         float a, r, g, b;
149         ckb_gradient thisGradient;
150         if (randomize) {
151             thisGradient = anim[i]\&.gradient;
152         } else {
153             thisGradient = animcolor;
154         }
155         ckb_grad_color(&a, &r, &g, &b, &thisGradient, phase * 100\&.);
156         key->a = a;
157         key->r = r;
158         key->g = g;
159         key->b = b;
160     }
161     return 0;
162 }
.fi
.SS "void ckb_getline (charword1[(4 *1024)], charword2[(4 *1024)], charword3[(4 *1024)])"

.PP
Definition at line 239 of file ckb-anim\&.h\&.
.PP
References urldecode()\&.
.PP
Referenced by ckb_read_params(), and main()\&.
.PP
.nf
239                                                                                               {
240     char line[CKB_MAX_WORD * 3 + 3];
241     fgets(line, sizeof(line), stdin);
242     word1[0] = word1[1] = word1[2] = 0;
243     int res = sscanf(line, "%s %s %s", word1, word2, word3);
244     if(res >= 1)
245         urldecode(word1, word1);
246     if(res >= 2)
247         urldecode(word2, word2);
248     if(res >= 3)
249         urldecode(word3, word3);
250     line[strlen(line) - 1] = 0;
251 }
.fi
.SS "void ckb_grad_color (float *a, float *r, float *g, float *b, const \fBckb_gradient\fP *grad, floatpos)"

.PP
Definition at line 254 of file ckb-anim\&.h\&.
.PP
References ckb_gradient::a, ckb_gradient::b, ckb_gradient::g, ckb_gradient::ptcount, ckb_gradient::pts, and ckb_gradient::r\&.
.PP
Referenced by ckb_frame(), and ckb_keypress()\&.
.PP
.nf
254                                                                                                 {
255     // Find the points surrounding this position
256     int count = grad->ptcount;
257     if(count == 0){
258         *a = *r = *g = *b = 0\&.f;
259         return;
260     }
261     int i = 1;
262     for(; i < count; i++){
263         if(grad->pts[i] >= pos)
264             break;
265     }
266     // Get color by linear interpolation\&. Premultiply the alpha value so that it returns the expected color
267     // (i\&.e\&. stops with zero opacity won't contribute to color)
268     float distance = grad->pts[i] - grad->pts[i - 1];
269     float dx = (pos - grad->pts[i - 1]) / distance;
270     float a1 = grad->a[i] / 255\&., a2 = grad->a[i - 1] / 255\&.;
271     float a3 = *a = a1 * dx + a2 * (1\&.f - dx);
272     if(a3 == 0\&.){
273         *a = *r = *g = *b = 0\&.f;
274         return;
275     }
276     *a *= 255\&.f;
277     *r = (grad->r[i] * a1 * dx + grad->r[i - 1] * a2 * (1\&.f - dx)) / a3;
278     *g = (grad->g[i] * a1 * dx + grad->g[i - 1] * a2 * (1\&.f - dx)) / a3;
279     *b = (grad->b[i] * a1 * dx + grad->b[i - 1] * a2 * (1\&.f - dx)) / a3;
280 }
.fi
.SS "void ckb_info ()"

.PP
Definition at line 5 of file main\&.c\&.
.PP
References CKB_COPYRIGHT, CKB_DESCRIPTION, CKB_GUID, CKB_KP_NAME, CKB_KP_NONE, CKB_KP_POSITION, CKB_KPMODE, CKB_LICENSE, CKB_LIVEPARAMS, CKB_NAME, CKB_PARAM_AGRADIENT, CKB_PARAM_ANGLE, CKB_PARAM_BOOL, CKB_PARAM_DOUBLE, CKB_PARAM_LONG, CKB_PARAM_RGB, CKB_PREEMPT, CKB_PRESET_END, CKB_PRESET_PARAM, CKB_PRESET_START, CKB_REPEAT, CKB_TIME_ABSOLUTE, CKB_TIME_DURATION, CKB_TIMEMODE, CKB_VERSION, FALSE, and TRUE\&.
.PP
Referenced by main(), and quitWithLock()\&.
.PP
.nf
5                {
6     // Plugin info
7     CKB_NAME("Gradient");
8     CKB_VERSION("0\&.9");
9     CKB_COPYRIGHT("2014-2016", "MSC");
10     CKB_LICENSE("GPLv2");
11     CKB_GUID("{54DD2975-E192-457D-BCFC-D912A24E33B4}");
12     CKB_DESCRIPTION("A transition from one color to another\&.");
13 
14     // Effect parameters
15     CKB_PARAM_AGRADIENT("color", "Color:", "", "ffffffff");
16     CKB_PARAM_BOOL("kphold", "Freeze until key is released", TRUE);
17     CKB_PARAM_BOOL("randomize", "Randomly select from gradient", 0);
18 
19     // Timing/input parameters
20     CKB_KPMODE(CKB_KP_NAME);
21     CKB_TIMEMODE(CKB_TIME_DURATION);
22     CKB_LIVEPARAMS(TRUE);
23 
24     // Presets
25     CKB_PRESET_START("Fade in");
26     CKB_PRESET_PARAM("color", "ff000000");
27     CKB_PRESET_PARAM("duration", "1\&.0");
28     CKB_PRESET_PARAM("stop", "0");
29     CKB_PRESET_PARAM("kpstop", "0");
30     CKB_PRESET_END;
31 
32     CKB_PRESET_START("Rainbow");
33     CKB_PRESET_PARAM("color", "0:ffff0000 17:ffffff00 33:ff00ff00 50:ff00ffff 67:ff0000ff 83:ffff00ff 100:ffff0000");
34     CKB_PRESET_PARAM("duration", "2\&.0");
35     CKB_PRESET_END;
36 
37     CKB_PRESET_START("Type lighting");
38     CKB_PRESET_PARAM("duration", "1\&.0");
39     CKB_PRESET_PARAM("trigger", "0");
40     CKB_PRESET_PARAM("kptrigger", "1");
41     CKB_PRESET_END;
42 }
.fi
.SS "void ckb_init (\fBckb_runctx\fP *context)"

.PP
Definition at line 57 of file main\&.c\&.
.PP
References ckb_runctx::height, kbsize, ckb_runctx::keycount, ckb_runctx::keys, NONE, pas, ckb_runctx::width, keyanim::x, ckb_key::x, keyanim::y, and ckb_key::y\&.
.PP
Referenced by main()\&.
.PP
.nf
57                                   {
58     // Initialize all keys to 100% (animation over)
59 
60     srand((unsigned)time(NULL));
61     unsigned count = context->keycount;
62     anim =  malloc(count * sizeof *anim);
63     for(unsigned i = 0; i < count; i++) {
64         anim[i]\&.target = NONE;
65     }
66 }
.fi
.SS "void ckb_keypress (\fBckb_runctx\fP *, \fBckb_key\fP *, int, int, int)"

.PP
Definition at line 75 of file main\&.c\&.
.PP
References ckb_gradient::a, anim_add(), anim_remove(), ckb_gradient::b, ckb_grad_color(), drop_add(), ckb_gradient::g, keyAnim::gradient, ckb_runctx::height, HOLD, ckb_runctx::keys, kphold, kprelease, NONE, ckb_gradient::ptcount, ckb_gradient::pts, ckb_gradient::r, randomize, keyAnim::target, and ckb_runctx::width\&.
.PP
Referenced by main()\&.
.PP
.nf
75                                                                              {
76     // Start or stop animation on key
77     int i = key - context->keys;
78     if(state){
79         if (randomize) {
80             float a, r, g, b;
81             float colorChoice = (float)rand()/(float)(RAND_MAX);
82             ckb_grad_color(&a, &r, &g, &b, &animcolor, colorChoice * 100\&.);
83             ckb_gradient newGradient = { 0 };
84             newGradient\&.ptcount = 2;
85             newGradient\&.pts[0] = 0;
86             newGradient\&.pts[1] = 100;
87             newGradient\&.a[0] = 255;
88             newGradient\&.b[0] = b;
89             newGradient\&.g[0] = g;
90             newGradient\&.r[0] = r;
91             newGradient\&.a[1] = 0;
92             newGradient\&.b[1] = b;
93             newGradient\&.g[1] = g;
94             newGradient\&.r[1] = r;
95 
96             anim[i]\&.gradient = newGradient;
97         }
98 
99         if(kphold) {
100             anim[i]\&.target = HOLD;
101         } else {
102             anim[i]\&.target = 0\&.f;
103         }
104     } else {
105         if(kprelease) {
106             anim[i]\&.target = NONE;
107         }
108         else if(kphold) {
109             anim[i]\&.target = 0\&.f;
110         }
111     }
112 }
.fi
.SS "void ckb_parameter (\fBckb_runctx\fP *, const char *, const char *)"

.PP
Definition at line 68 of file main\&.c\&.
.PP
References aa, ab, ag, angle, animlength, ar, CKB_PARSE_AGRADIENT, CKB_PARSE_ANGLE, CKB_PARSE_BOOL, CKB_PARSE_DOUBLE, CKB_PARSE_LONG, CKB_PARSE_RGB, CKB_REAL_ANGLE, counter_clock, fadein, ffade, ckb_runctx::height, kphold, kprelease, left, M_PI, maxsize, period, power, pressestofull, randomBright, randomize, spawn, speed, symmetric, top, useopacity, width, ckb_runctx::width, x, x_offset, y, and y_offset\&.
.PP
Referenced by ckb_read_params()\&.
.PP
.nf
68                                                                             {
69     CKB_PARSE_AGRADIENT("color", &animcolor){}
70     CKB_PARSE_BOOL("kphold", &kphold){}
71     CKB_PARSE_BOOL("kprelease", &kprelease){}
72     CKB_PARSE_BOOL("randomize", &randomize){}
73 }
.fi
.SS "void ckb_read_params (\fBckb_runctx\fP *ctx)"

.PP
Definition at line 349 of file ckb-anim\&.h\&.
.PP
References ckb_getline(), CKB_MAX_WORD, and ckb_parameter()\&.
.PP
Referenced by main()\&.
.PP
.nf
349                                      {
350     char cmd[CKB_MAX_WORD], param[CKB_MAX_WORD], value[CKB_MAX_WORD];
351     do {
352         ckb_getline(cmd, param, value);
353         if(!*cmd){
354             printf("Error [ckb-main]: Reached EOF reading parameters");
355             return;
356         }
357         if(!strcmp(cmd, "end") && !strcmp(param, "params"))
358             break;
359         if(strcmp(cmd, "param"))
360             continue;
361         ckb_parameter(ctx, param, value);
362     } while(1);
363 }
.fi
.SS "int ckb_scan_grad (const char *string, \fBckb_gradient\fP *gradient, intalpha)"

.PP
Definition at line 298 of file ckb-anim\&.h\&.
.PP
References ckb_gradient::a, ckb_gradient::b, ckb_gradient::g, ckb_gradient::ptcount, ckb_gradient::pts, and ckb_gradient::r\&.
.PP
.nf
298                                                                         {
299     char pos = -1;
300     unsigned char a = 255, r, g, b;
301     int count = 0;
302     while(1){
303         int scanned = 0;
304         char newpos;
305         if(sscanf(string, "%hhd:%2hhx%2hhx%2hhx%2hhx%n", &newpos, &a, &r, &g, &b, &scanned) != 5)
306             break;
307         string += scanned;
308         // Don't allow stops out-of-order or past 100
309         if(newpos <= pos || newpos > 100)
310             return 0;
311         pos = newpos;
312         if(!alpha)
313             a = 255;
314         gradient->pts[count] = pos;
315         gradient->a[count] = a;
316         gradient->r[count] = r;
317         gradient->g[count] = g;
318         gradient->b[count] = b;
319         count++;
320     }
321     if(count == 0){
322         // If nothing was read, try a single ARGB constant\&.
323         if(sscanf(string, "%2hhx%2hhx%2hhx%2hhx", &a, &r, &g, &b) != 4)
324             return 0;
325         count = 2;
326         gradient->pts[0] = 0;
327         gradient->pts[1] = 100;
328         gradient->a[0] = a;
329         gradient->a[1] = 0;
330         gradient->r[0] = gradient->r[1] = r;
331         gradient->g[0] = gradient->g[1] = g;
332         gradient->b[0] = gradient->b[1] = b;
333     }
334     if(count < 2)
335         return 0;
336     gradient->ptcount = count;
337     return 1;
338 }
.fi
.SS "void ckb_start (\fBckb_runctx\fP *, int)"

.PP
Definition at line 114 of file main\&.c\&.
.PP
References rgb::a, ckb_key::a, anim_add(), anim_remove(), rgb::b, ckb_key::b, fadein, frame, rgb::g, ckb_key::g, ckb_runctx::height, ckb_runctx::keycount, ckb_runctx::keys, kprelease, left, newtarget(), NONE, phase, rgb::r, ckb_key::r, keyAnim::target, tick, top, ckb_runctx::width, x, x_offset, y, and y_offset\&.
.PP
Referenced by main()\&.
.PP
.nf
114                                               {
115     // Start/stop all keys
116     unsigned count = context->keycount;
117     if(state) {
118         memset(anim, 0, count * sizeof *anim);
119     } else {
120         for(unsigned i = 0; i < count; i++) {
121             anim[i]\&.target = NONE;
122         }
123     }
124 }
.fi
.SS "void ckb_time (\fBckb_runctx\fP *, double)"

.PP
Definition at line 126 of file main\&.c\&.
.PP
References anim, ANIM_MAX, animlength, current, drop, drop_add(), DROP_MAX, frame, ckb_runctx::height, kbsize, ckb_runctx::keycount, maxsize, newtarget(), period, phase, spawn, speed, target, keyAnim::target, tick, keyanim::timing, keyanim::usages, width, and ckb_runctx::width\&.
.PP
Referenced by main()\&.
.PP
.nf
126                                                 {
127     // Advance animation on each key
128     unsigned count = context->keycount;
129     for(unsigned i = 0; i < count; i++){
130         float phase = anim[i]\&.target;
131         if(phase > 1\&.f || phase < 0\&.f)
132             continue;
133         anim[i]\&.target = phase + delta;
134     }
135 }
.fi
.SS "int main (intargc, char *argv[])"

.PP
Definition at line 365 of file ckb-anim\&.h\&.
.PP
References ckb_key::a, ckb_key::b, ckb_frame(), ckb_getline(), ckb_info(), ckb_init(), CKB_KEYNAME_MAX, ckb_keypress(), CKB_MAX_WORD, ckb_read_params(), ckb_start(), ckb_time(), ckb_key::g, ckb_runctx::height, ckb_runctx::keycount, ckb_runctx::keys, ckb_key::name, ckb_key::r, ckb_runctx::width, x, ckb_key::x, y, and ckb_key::y\&.
.PP
.nf
365                                 {
366     if(argc == 2){
367         if(!strcmp(argv[1], "--ckb-info")){
368             ckb_info();
369             fflush(stdout);
370             return 0;
371         } else if(!strcmp(argv[1], "--ckb-run")){
372             ckb_runctx ctx;
373             // Read the keymap lines
374             char cmd[CKB_MAX_WORD], param[CKB_MAX_WORD], value[CKB_MAX_WORD];
375             // Skip anything up until "begin keymap"
376             do {
377                 ckb_getline(cmd, param, value);
378                 if(!*cmd){
379                     // If end-of-file is reached, abort
380                     printf("Error [ckb-main]: Reached EOF looking for \"begin keymap\"");
381                     return -2;
382                 }
383             } while(strcmp(cmd, "begin") || strcmp(param, "keymap"));
384             ckb_getline(cmd, param, value);
385             unsigned keycount;
386             if(strcmp(cmd, "keycount") || sscanf(param, "%u", &keycount) != 1 || keycount == 0){
387                 // If keycount isn't the next line, something is wrong
388                 printf("Error [ckb-main]: \"begin keymap\" not followed with \"keycount\"");
389                 return -3;
390             }
391             ctx\&.keys = (ckb_key*)calloc(keycount, sizeof(ckb_key));
392             ctx\&.keycount = keycount;
393             unsigned max_x = 0, max_y = 0;
394             unsigned i = 0;
395             for(; i < ctx\&.keycount; i++){
396                 ckb_getline(cmd, param, value);
397                 unsigned x, y;
398                 if(strcmp(cmd, "key") || !*param || !sscanf(value, "%u,%u", &x, &y)){
399                     i--;
400                     continue;
401                 }
402                 ckb_key* key = ctx\&.keys + i;
403                 strncpy(key->name, param, CKB_KEYNAME_MAX);
404                 key->x = x;
405                 key->y = y;
406                 if(x > max_x)
407                     max_x = x;
408                 if(y > max_y)
409                     max_y = y;
410             }
411             ctx\&.width = max_x + 1;
412             ctx\&.height = max_y + 1;
413             // Skip anything else until "end keymap"
414             do {
415                 ckb_getline(cmd, param, value);
416                 if(!*cmd){
417                     printf("Error [ckb-main]: Reached EOF looking for \"end keymap\"");
418                     return -2;
419                 }
420             } while(strcmp(cmd, "end") || strcmp(param, "keymap"));
421             // Run init function
422             ckb_init(&ctx);
423             // Skip anything else until "begin params"
424             do {
425                 ckb_getline(cmd, param, value);
426                 if(!*cmd){
427                     printf("Error [ckb-main]: Reached EOF looking for \"begin params\"");
428                     return -2;
429                 }
430             } while(strcmp(cmd, "begin") || strcmp(param, "params"));
431             // Parse parameters
432             ckb_read_params(&ctx);
433             // Skip anything else until "begin run"
434             do {
435                 ckb_getline(cmd, param, value);
436                 if(!*cmd){
437                     printf("Error [ckb-main]: Reached EOF looking for \"begin run\"");
438                     return -2;
439                 }
440             } while(strcmp(cmd, "begin") || strcmp(param, "run"));
441             // Run the main loop
442             printf("begin run\n");
443             fflush(stdout);
444             while(1){
445                 ckb_getline(cmd, param, value);
446                 if(!*cmd || (!strcmp(cmd, "end") && !strcmp(param, "run")))
447                     break;
448                 // Parse input
449                 if(!strcmp(cmd, "start"))
450                     ckb_start(&ctx, 1);
451                 else if(!strcmp(cmd, "stop"))
452                     ckb_start(&ctx, 0);
453                 else if(!strcmp(cmd, "begin") && !strcmp(param, "params"))
454                     ckb_read_params(&ctx);
455                 else if(!strcmp(cmd, "key")){
456                     int x, y;
457                     if(sscanf(param, "%d,%d", &x, &y) == 2){
458                         // Find a key with this position
459                         ckb_key* key = 0;
460                         for(i = 0; i < keycount; i++){
461                             if(ctx\&.keys[i]\&.x == x && ctx\&.keys[i]\&.y == y){
462                                 key = ctx\&.keys + i;
463                                 break;
464                             }
465                         }
466                         if(key)
467                             ckb_keypress(&ctx, key, key->x, key->y, !strcmp(value, "down"));
468                         else
469                             ckb_keypress(&ctx, 0, x, y, !strcmp(value, "down"));
470                     } else {
471                         // Find a key with this name
472                         ckb_key* key = 0;
473                         for(i = 0; i < keycount; i++){
474                             if(!strcmp(ctx\&.keys[i]\&.name, param)){
475                                 key = ctx\&.keys + i;
476                                 break;
477                             }
478                         }
479                         if(key)
480                             ckb_keypress(&ctx, key, key->x, key->y, !strcmp(value, "down"));
481                     }
482                 } else if(!strcmp(cmd, "frame")){
483                     int end = ckb_frame(&ctx);
484                     // Output the frame
485                     printf("begin frame\n");
486                     for(i = 0; i < ctx\&.keycount; i++){
487                         ckb_key* key = ctx\&.keys + i;
488                         printf("argb %s %02hhx%02hhx%02hhx%02hhx\n", key->name, key->a, key->r, key->g, key->b);
489                     }
490                     printf("end frame\n");
491                     if(end)
492                         break;
493                     fflush(stdout);
494                 } else {
495                     double delta = 0\&.;
496                     if(!strcmp(cmd, "time") && sscanf(param, "%lf", &delta) == 1)
497                         ckb_time(&ctx, delta);
498                 }
499             }
500             printf("end run\n");
501             fflush(stdout);
502             free(ctx\&.keys);
503             return 0;
504         }
505     }
506     printf("This program must be run from within ckb\n");
507     return -1;
508 }
.fi
.SS "void printurl (const char *src)"

.PP
Definition at line 178 of file ckb-anim\&.h\&.
.PP
.nf
178                               {
179     char out[strlen(src) * 3 + 1];
180     char* dst = out;
181     char s;
182     while((s = *src++)){
183         if(s <= ',' || s == '/' ||
184                 (s >= ':' && s <= '@') ||
185                 s == '[' || s == ']' ||
186                 s >= 0x7F){
187             char a = s >> 4, b = s & 0xF;
188             if(a >= 10)
189                 a += 'A' - 10;
190             else
191                 a += '0';
192             if(b >= 10)
193                 b += 'A' - 10;
194             else
195                 b += '0';
196             dst[0] = '%';
197             dst[1] = a;
198             dst[2] = b;
199             dst += 3;
200         } else
201             *dst++ = s;
202     }
203     *dst = '\0';
204     printf("%s", out);
205 }
.fi
.SS "void urldecode (char *dst, const char *src)"

.PP
Definition at line 208 of file ckb-anim\&.h\&.
.PP
Referenced by ckb_getline()\&.
.PP
.nf
208                                           {
209     char a, b;
210     char s;
211     while((s = *src)){
212         if((s == '%') &&
213                 ((a = src[1]) && (b = src[2])) &&
214                 (isxdigit(a) && isxdigit(b))){
215             if(a >= 'a')
216                 a -= 'a'-'A';
217             if(a >= 'A')
218                 a -= 'A' - 10;
219             else
220                 a -= '0';
221             if(b >= 'a')
222                 b -= 'a'-'A';
223             if(b >= 'A')
224                 b -= 'A' - 10;
225             else
226                 b -= '0';
227             *dst++ = 16*a + b;
228             src += 3;
229         } else {
230             *dst++ = s;
231             src++;
232         }
233     }
234     *dst = '\0';
235 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
