.TH "src/ckb-daemon/devnode.c" 3 "Sat Jun 3 2017" "Version beta-v0.2.8+testing at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/devnode.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'device\&.h'\fP
.br
\fC#include 'devnode\&.h'\fP
.br
\fC#include 'firmware\&.h'\fP
.br
\fC#include 'input\&.h'\fP
.br
\fC#include 'led\&.h'\fP
.br
\fC#include 'notify\&.h'\fP
.br
\fC#include 'profile\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_readlines_ctx\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBS_GID_READ\fP   (\fBgid\fP >= 0 ? \fBS_CUSTOM_R\fP : \fBS_READ\fP)"
.br
.ti -1c
.RI "#define \fBMAX_BUFFER\fP   (1024 * 1024 - 1)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBrm_recursive\fP (const char *path)"
.br
.ti -1c
.RI "void \fB_updateconnected\fP ()"
.br
.RI "\fI_updateconnected Update the list of connected devices\&. \fP"
.ti -1c
.RI "void \fBupdateconnected\fP ()"
.br
.RI "\fIUpdate the list of connected devices\&. \fP"
.ti -1c
.RI "int \fB_mknotifynode\fP (\fBusbdevice\fP *kb, int notify)"
.br
.ti -1c
.RI "int \fBmknotifynode\fP (\fBusbdevice\fP *kb, int notify)"
.br
.RI "\fICreates a notification node for the specified keyboard\&. \fP"
.ti -1c
.RI "int \fB_rmnotifynode\fP (\fBusbdevice\fP *kb, int notify)"
.br
.ti -1c
.RI "int \fBrmnotifynode\fP (\fBusbdevice\fP *kb, int notify)"
.br
.RI "\fIRemoves a notification node for the specified keyboard\&. \fP"
.ti -1c
.RI "static int \fB_mkdevpath\fP (\fBusbdevice\fP *kb)"
.br
.ti -1c
.RI "int \fBmkdevpath\fP (\fBusbdevice\fP *kb)"
.br
.RI "\fICreate a dev path for the keyboard at index\&. Returns 0 on success\&. \fP"
.ti -1c
.RI "int \fBrmdevpath\fP (\fBusbdevice\fP *kb)"
.br
.RI "\fIRemove the dev path for the keyboard at index\&. Returns 0 on success\&. \fP"
.ti -1c
.RI "int \fBmkfwnode\fP (\fBusbdevice\fP *kb)"
.br
.RI "\fIWrites a keyboard's firmware version and poll rate to its device node\&. \fP"
.ti -1c
.RI "void \fBreadlines_ctx_init\fP (\fBreadlines_ctx\fP *ctx)"
.br
.ti -1c
.RI "void \fBreadlines_ctx_free\fP (\fBreadlines_ctx\fP ctx)"
.br
.ti -1c
.RI "unsigned \fBreadlines\fP (int fd, \fBreadlines_ctx\fP ctx, const char **input)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char *const \fBdevpath\fP = '/dev/input/ckb'"
.br
.ti -1c
.RI "long \fBgid\fP = -1"
.br
.RI "\fIGroup ID for the control nodes\&. -1 to give read/write access to everybody\&. \fP"
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct _readlines_ctx"
.PP 
Definition at line 350 of file devnode\&.c\&.
.PP
\fBData Fields:\fP
.RS 4
char * \fIbuffer\fP 
.br
.PP
int \fIbuffersize\fP 
.br
.PP
int \fIleftover\fP 
.br
.PP
int \fIleftoverlen\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAX_BUFFER   (1024 * 1024 - 1)"

.PP
Definition at line 349 of file devnode\&.c\&.
.PP
Referenced by readlines()\&.
.SS "#define S_GID_READ   (\fBgid\fP >= 0 ? \fBS_CUSTOM_R\fP : \fBS_READ\fP)"

.PP
Definition at line 17 of file devnode\&.c\&.
.PP
Referenced by _mkdevpath(), _mknotifynode(), _updateconnected(), and mkfwnode()\&.
.SH "Function Documentation"
.PP 
.SS "static int _mkdevpath (\fBusbdevice\fP *kb)\fC [static]\fP"

.PP
Definition at line 136 of file devnode\&.c\&.
.PP
References _mknotifynode(), _updateconnected(), ckb_err, ckb_warn, devpath, FEAT_ADJRATE, FEAT_BIND, FEAT_FWUPDATE, FEAT_FWVERSION, FEAT_MONOCHROME, FEAT_NOTIFY, FEAT_POLLRATE, FEAT_RGB, gid, HAS_FEATURES, INDEX_OF, usbdevice::infifo, keyboard, mkfwnode(), usbdevice::name, usbdevice::product, product_str(), rm_recursive(), S_CUSTOM, S_GID_READ, S_READ, S_READDIR, S_READWRITE, usbdevice::serial, usbdevice::vendor, and vendor_str()\&.
.PP
Referenced by mkdevpath()\&.
.PP
.nf
136                                     {
137     int index = INDEX_OF(kb, keyboard);
138     // Create the control path
139     char path[strlen(devpath) + 2];
140     snprintf(path, sizeof(path), "%s%d", devpath, index);
141     if(rm_recursive(path) != 0 && errno != ENOENT){
142         ckb_err("Unable to delete %s: %s\n", path, strerror(errno));
143         return -1;
144     }
145     if(mkdir(path, S_READDIR) != 0){
146         ckb_err("Unable to create %s: %s\n", path, strerror(errno));
147         rm_recursive(path);
148         return -1;
149     }
150     if(gid >= 0)
151         chown(path, 0, gid);
152 
153     if(kb == keyboard + 0){
154         // Root keyboard: write a list of devices
155         _updateconnected();
156         // Write version number
157         char vpath[sizeof(path) + 8];
158         snprintf(vpath, sizeof(vpath), "%s/version", path);
159         FILE* vfile = fopen(vpath, "w");
160         if(vfile){
161             fprintf(vfile, "%s\n", CKB_VERSION_STR);
162             fclose(vfile);
163             chmod(vpath, S_GID_READ);
164             if(gid >= 0)
165                 chown(vpath, 0, gid);
166         } else {
167             ckb_warn("Unable to create %s: %s\n", vpath, strerror(errno));
168             remove(vpath);
169         }
170         // Write PID
171         char ppath[sizeof(path) + 4];
172         snprintf(ppath, sizeof(ppath), "%s/pid", path);
173         FILE* pfile = fopen(ppath, "w");
174         if(pfile){
175             fprintf(pfile, "%u\n", getpid());
176             fclose(pfile);
177             chmod(ppath, S_READ);
178             if(gid >= 0)
179                 chown(vpath, 0, gid);
180         } else {
181             ckb_warn("Unable to create %s: %s\n", ppath, strerror(errno));
182             remove(ppath);
183         }
184     } else {
185         // Create command FIFO
186         char inpath[sizeof(path) + 4];
187         snprintf(inpath, sizeof(inpath), "%s/cmd", path);
188         if(mkfifo(inpath, gid >= 0 ? S_CUSTOM : S_READWRITE) != 0
189                 // Open the node in RDWR mode because RDONLY will lock the thread
190                 || (kb->infifo = open(inpath, O_RDWR) + 1) == 0){
191             // Add one to the FD because 0 is a valid descriptor, but ckb uses 0 for uninitialized devices
192             ckb_err("Unable to create %s: %s\n", inpath, strerror(errno));
193             rm_recursive(path);
194             kb->infifo = 0;
195             return -1;
196         }
197         if(gid >= 0)
198             fchown(kb->infifo - 1, 0, gid);
199 
200         // Create notification FIFO
201         _mknotifynode(kb, 0);
202 
203         // Write the model and serial to files
204         char mpath[sizeof(path) + 6], spath[sizeof(path) + 7], ipath[sizeof(path) + 10];
205         snprintf(mpath, sizeof(mpath), "%s/model", path);
206         snprintf(spath, sizeof(spath), "%s/serial", path);
207         snprintf(ipath, sizeof(ipath), "%s/productid", path);
208         FILE* mfile = fopen(mpath, "w");
209         if(mfile){
210             fputs(kb->name, mfile);
211             fputc('\n', mfile);
212             fclose(mfile);
213             chmod(mpath, S_GID_READ);
214             if(gid >= 0)
215                 chown(mpath, 0, gid);
216         } else {
217             ckb_warn("Unable to create %s: %s\n", mpath, strerror(errno));
218             remove(mpath);
219         }
220         FILE* sfile = fopen(spath, "w");
221         if(sfile){
222             fputs(kb->serial, sfile);
223             fputc('\n', sfile);
224             fclose(sfile);
225             chmod(spath, S_GID_READ);
226             if(gid >= 0)
227                 chown(spath, 0, gid);
228         } else {
229             ckb_warn("Unable to create %s: %s\n", spath, strerror(errno));
230             remove(spath);
231         }
232         FILE* ifile = fopen(ipath, "w");
233         if(ifile){
234             char productid [5];
235             snprintf(productid, 5, "%04x", kb->product);
236             fputs(productid, ifile);
237             fputc('\n', ifile);
238             fclose(ifile);
239             chmod(ipath, S_GID_READ);
240             if(gid >= 0)
241                 chown(ipath, 0, gid);
242         } else {
243             ckb_warn("Unable to create %s: %s\n", ipath, strerror(errno));
244             remove(ipath);
245         }
246         // Write the keyboard's features
247         char fpath[sizeof(path) + 9];
248         snprintf(fpath, sizeof(fpath), "%s/features", path);
249         FILE* ffile = fopen(fpath, "w");
250         if(ffile){
251             fprintf(ffile, "%s %s", vendor_str(kb->vendor), product_str(kb->product));
252             if(HAS_FEATURES(kb, FEAT_MONOCHROME))
253                 fputs(" monochrome", ffile);
254             if(HAS_FEATURES(kb, FEAT_RGB))
255                 fputs(" rgb", ffile);
256             if(HAS_FEATURES(kb, FEAT_POLLRATE))
257                 fputs(" pollrate", ffile);
258             if(HAS_FEATURES(kb, FEAT_ADJRATE))
259                 fputs(" adjrate", ffile);
260             if(HAS_FEATURES(kb, FEAT_BIND))
261                 fputs(" bind", ffile);
262             if(HAS_FEATURES(kb, FEAT_NOTIFY))
263                 fputs(" notify", ffile);
264             if(HAS_FEATURES(kb, FEAT_FWVERSION))
265                 fputs(" fwversion", ffile);
266             if(HAS_FEATURES(kb, FEAT_FWUPDATE))
267                 fputs(" fwupdate", ffile);
268             fputc('\n', ffile);
269             fclose(ffile);
270             chmod(fpath, S_GID_READ);
271             if(gid >= 0)
272                 chown(fpath, 0, gid);
273         } else {
274             ckb_warn("Unable to create %s: %s\n", fpath, strerror(errno));
275             remove(fpath);
276         }
277         // Write firmware version and poll rate
278         mkfwnode(kb);
279     }
280     return 0;
281 }
.fi
.SS "int _mknotifynode (\fBusbdevice\fP *kb, intnotify)"

.PP
Definition at line 87 of file devnode\&.c\&.
.PP
References ckb_warn, devpath, gid, INDEX_OF, keyboard, usbdevice::outfifo, OUTFIFO_MAX, and S_GID_READ\&.
.PP
Referenced by _mkdevpath(), and mknotifynode()\&.
.PP
.nf
87                                             {
88     if(notify < 0 || notify >= OUTFIFO_MAX)
89         return -1;
90     if(kb->outfifo[notify] != 0)
91         return 0;
92     // Create the notification node
93     int index = INDEX_OF(kb, keyboard);
94     char outpath[strlen(devpath) + 10];
95     snprintf(outpath, sizeof(outpath), "%s%d/notify%d", devpath, index, notify);
96     if(mkfifo(outpath, S_GID_READ) != 0 || (kb->outfifo[notify] = open(outpath, O_RDWR | O_NONBLOCK) + 1) == 0){
97         // Add one to the FD because 0 is a valid descriptor, but ckb uses 0 for uninitialized devices
98         ckb_warn("Unable to create %s: %s\n", outpath, strerror(errno));
99         kb->outfifo[notify] = 0;
100         remove(outpath);
101         return -1;
102     }
103     if(gid >= 0)
104         fchown(kb->outfifo[notify] - 1, 0, gid);
105     return 0;
106 }
.fi
.SS "int _rmnotifynode (\fBusbdevice\fP *kb, intnotify)"

.PP
Definition at line 115 of file devnode\&.c\&.
.PP
References devpath, INDEX_OF, keyboard, usbdevice::outfifo, and OUTFIFO_MAX\&.
.PP
Referenced by rmdevpath(), and rmnotifynode()\&.
.PP
.nf
115                                             {
116     if(notify < 0 || notify >= OUTFIFO_MAX || !kb->outfifo[notify])
117         return -1;
118     int index = INDEX_OF(kb, keyboard);
119     char outpath[strlen(devpath) + 10];
120     snprintf(outpath, sizeof(outpath), "%s%d/notify%d", devpath, index, notify);
121     // Close FIFO
122     close(kb->outfifo[notify] - 1);
123     kb->outfifo[notify] = 0;
124     // Delete node
125     int res = remove(outpath);
126     return res;
127 }
.fi
.SS "void _updateconnected ()"
<devicepath> normally is /dev/input/ckb or /input/ckb\&. 
.br
 Open the normal file under <devicepath>0/connected for writing\&. For each device connected, print its devicepath+number, the serial number of the usb device and the usb name of the device connected to that usb interface\&. 
.br
 eg: 
.br
 /dev/input/ckb1 0F022014ABABABABABABABABABABA999 Corsair K95 RGB Gaming Keyboard 
.br
 /dev/input/ckb2 0D02303DBACBACBACBACBACBACBAC998 Corsair M65 RGB Gaming Mouse
.PP
Set the file ownership to root\&. If the glob var gid is explicitly set to something different from -1 (the initial value), set file permission to 640, else to 644\&. This is used if you start the daemon with --gid=<GID> Parameter\&.
.PP
Because several independent threads may call \fBupdateconnected()\fP, protect that procedure with locking/unlocking of \fBdevmutex\fP\&. 
.PP
Definition at line 55 of file devnode\&.c\&.
.PP
References ckb_warn, DEV_MAX, devmutex, devpath, gid, IS_CONNECTED, keyboard, and S_GID_READ\&.
.PP
Referenced by _mkdevpath(), and updateconnected()\&.
.PP
.nf
55                        {
56     pthread_mutex_lock(devmutex);
57     char cpath[strlen(devpath) + 12];
58     snprintf(cpath, sizeof(cpath), "%s0/connected", devpath);
59     FILE* cfile = fopen(cpath, "w");
60     if(!cfile){
61         ckb_warn("Unable to update %s: %s\n", cpath, strerror(errno));
62         pthread_mutex_unlock(devmutex);
63         return;
64     }
65     int written = 0;
66     for(int i = 1; i < DEV_MAX; i++){
67         if(IS_CONNECTED(keyboard + i)){
68             written = 1;
69             fprintf(cfile, "%s%d %s %s\n", devpath, i, keyboard[i]\&.serial, keyboard[i]\&.name);
70         }
71     }
72     if(!written)
73         fputc('\n', cfile);
74     fclose(cfile);
75     chmod(cpath, S_GID_READ);
76     if(gid >= 0)
77         chown(cpath, 0, gid);
78     pthread_mutex_unlock(devmutex);
79 }
.fi
.SS "int mkdevpath (\fBusbdevice\fP *kb)"

.PP
Definition at line 283 of file devnode\&.c\&.
.PP
References _mkdevpath(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by _setupusb(), and main()\&.
.PP
.nf
283                             {
284     euid_guard_start;
285     int res = _mkdevpath(kb);
286     euid_guard_stop;
287     return res;
288 }
.fi
.SS "int mkfwnode (\fBusbdevice\fP *kb)"

.PP
Definition at line 314 of file devnode\&.c\&.
.PP
References ckb_warn, devpath, usbdevice::fwversion, gid, INDEX_OF, keyboard, usbdevice::pollrate, and S_GID_READ\&.
.PP
Referenced by _mkdevpath(), and fwupdate()\&.
.PP
.nf
314                            {
315     int index = INDEX_OF(kb, keyboard);
316     char fwpath[strlen(devpath) + 12];
317     snprintf(fwpath, sizeof(fwpath), "%s%d/fwversion", devpath, index);
318     FILE* fwfile = fopen(fwpath, "w");
319     if(fwfile){
320         fprintf(fwfile, "%04x", kb->fwversion);
321         fputc('\n', fwfile);
322         fclose(fwfile);
323         chmod(fwpath, S_GID_READ);
324         if(gid >= 0)
325             chown(fwpath, 0, gid);
326     } else {
327         ckb_warn("Unable to create %s: %s\n", fwpath, strerror(errno));
328         remove(fwpath);
329         return -1;
330     }
331     char ppath[strlen(devpath) + 11];
332     snprintf(ppath, sizeof(ppath), "%s%d/pollrate", devpath, index);
333     FILE* pfile = fopen(ppath, "w");
334     if(pfile){
335         fprintf(pfile, "%d ms", kb->pollrate);
336         fputc('\n', pfile);
337         fclose(pfile);
338         chmod(ppath, S_GID_READ);
339         if(gid >= 0)
340             chown(ppath, 0, gid);
341     } else {
342         ckb_warn("Unable to create %s: %s\n", fwpath, strerror(errno));
343         remove(ppath);
344         return -2;
345     }
346     return 0;
347 }
.fi
.SS "int mknotifynode (\fBusbdevice\fP *kb, intnotify)"

.PP
Definition at line 108 of file devnode\&.c\&.
.PP
References _mknotifynode(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by readcmd()\&.
.PP
.nf
108                                            {
109     euid_guard_start;
110     int res = _mknotifynode(kb, notify);
111     euid_guard_stop;
112     return res;
113 }
.fi
.SS "unsigned readlines (intfd, \fBreadlines_ctx\fPctx, const char **input)"

.PP
Definition at line 368 of file devnode\&.c\&.
.PP
References _readlines_ctx::buffer, _readlines_ctx::buffersize, ckb_warn, _readlines_ctx::leftover, _readlines_ctx::leftoverlen, and MAX_BUFFER\&.
.PP
Referenced by devmain()\&.
.PP
.nf
368                                                                  {
369     // Move any data left over from a previous read to the start of the buffer
370     char* buffer = ctx->buffer;
371     int buffersize = ctx->buffersize;
372     int leftover = ctx->leftover, leftoverlen = ctx->leftoverlen;
373     memcpy(buffer, buffer + leftover, leftoverlen);
374     // Read data from the file
375     ssize_t length = read(fd, buffer + leftoverlen, buffersize - leftoverlen);
376     length = (length < 0 ? 0 : length) + leftoverlen;
377     leftover = ctx->leftover = leftoverlen = ctx->leftoverlen = 0;
378     if(length <= 0){
379         *input = 0;
380         return 0;
381     }
382     // Continue buffering until all available input is read or there's no room left
383     while(length == buffersize){
384         if(buffersize == MAX_BUFFER)
385             break;
386         int oldsize = buffersize;
387         buffersize += 4096;
388         ctx->buffersize = buffersize;
389         buffer = ctx->buffer = realloc(buffer, buffersize + 1);
390         ssize_t length2 = read(fd, buffer + oldsize, buffersize - oldsize);
391         if(length2 <= 0)
392             break;
393         length += length2;
394     }
395     buffer[length] = 0;
396     // Input should be issued one line at a time and should end with a newline\&.
397     char* lastline = memrchr(buffer, '\n', length);
398     if(lastline == buffer + length - 1){
399         // If the buffer ends in a newline, process the whole string
400         *input = buffer;
401         return length;
402     } else if(lastline){
403         // Otherwise, chop off the last line but process everything else
404         *lastline = 0;
405         leftover = ctx->leftover = lastline + 1 - buffer;
406         leftoverlen = ctx->leftoverlen = length - leftover;
407         *input = buffer;
408         return leftover - 1;
409     } else {
410         // If a newline wasn't found at all, process the whole buffer next time
411         *input = 0;
412         if(length == MAX_BUFFER){
413             // Unless the buffer is completely full, in which case discard it
414             ckb_warn("Too much input (1MB)\&. Dropping\&.\n");
415             return 0;
416         }
417         leftoverlen = ctx->leftoverlen = length;
418         return 0;
419     }
420 }
.fi
.SS "void readlines_ctx_free (\fBreadlines_ctx\fPctx)"

.PP
Definition at line 363 of file devnode\&.c\&.
.PP
References _readlines_ctx::buffer\&.
.PP
Referenced by devmain()\&.
.PP
.nf
363                                           {
364     free(ctx->buffer);
365     free(ctx);
366 }
.fi
.SS "void readlines_ctx_init (\fBreadlines_ctx\fP *ctx)"

.PP
Definition at line 356 of file devnode\&.c\&.
.PP
Referenced by devmain()\&.
.PP
.nf
356                                            {
357     // Allocate buffers to store data
358     *ctx = calloc(1, sizeof(struct _readlines_ctx));
359     int buffersize = (*ctx)->buffersize = 4095;
360     (*ctx)->buffer = malloc(buffersize + 1);
361 }
.fi
.SS "int rm_recursive (const char *path)"

.PP
Definition at line 19 of file devnode\&.c\&.
.PP
Referenced by _mkdevpath(), and rmdevpath()\&.
.PP
.nf
19                                   {
20     DIR* dir = opendir(path);
21     if(!dir)
22         return remove(path);
23     struct dirent* file;
24     while((file = readdir(dir)))
25     {
26         if(!strcmp(file->d_name, "\&.") || !strcmp(file->d_name, "\&.\&."))
27             continue;
28         char path2[FILENAME_MAX];
29         snprintf(path2, FILENAME_MAX, "%s/%s", path, file->d_name);
30         int stat = rm_recursive(path2);
31         if(stat != 0)
32             return stat;
33     }
34     closedir(dir);
35     return remove(path);
36 }
.fi
.SS "int rmdevpath (\fBusbdevice\fP *kb)"

.PP
Definition at line 290 of file devnode\&.c\&.
.PP
References _rmnotifynode(), ckb_info, ckb_warn, devpath, euid_guard_start, euid_guard_stop, INDEX_OF, usbdevice::infifo, keyboard, OUTFIFO_MAX, and rm_recursive()\&.
.PP
Referenced by closeusb(), and quitWithLock()\&.
.PP
.nf
290                             {
291     euid_guard_start;
292     int index = INDEX_OF(kb, keyboard);
293     if(kb->infifo != 0){
294 #ifdef OS_LINUX
295         write(kb->infifo - 1, "\n", 1); // hack to prevent the FIFO thread from perma-blocking
296 #endif
297         close(kb->infifo - 1);
298         kb->infifo = 0;
299     }
300     for(int i = 0; i < OUTFIFO_MAX; i++)
301         _rmnotifynode(kb, i);
302     char path[strlen(devpath) + 2];
303     snprintf(path, sizeof(path), "%s%d", devpath, index);
304     if(rm_recursive(path) != 0 && errno != ENOENT){
305         ckb_warn("Unable to delete %s: %s\n", path, strerror(errno));
306         euid_guard_stop;
307         return -1;
308     }
309     ckb_info("Removed device path %s\n", path);
310     euid_guard_stop;
311     return 0;
312 }
.fi
.SS "int rmnotifynode (\fBusbdevice\fP *kb, intnotify)"

.PP
Definition at line 129 of file devnode\&.c\&.
.PP
References _rmnotifynode(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by readcmd()\&.
.PP
.nf
129                                            {
130     euid_guard_start;
131     int res = _rmnotifynode(kb, notify);
132     euid_guard_stop;
133     return res;
134 }
.fi
.SS "void updateconnected ()"

.PP
Definition at line 81 of file devnode\&.c\&.
.PP
References _updateconnected(), euid_guard_start, and euid_guard_stop\&.
.PP
Referenced by _setupusb(), and closeusb()\&.
.PP
.nf
81                       {
82     euid_guard_start;
83     _updateconnected();
84     euid_guard_stop;
85 }
.fi
.SH "Variable Documentation"
.PP 
.SS "const char* const devpath = '/dev/input/ckb'"

.PP
Definition at line 11 of file devnode\&.c\&.
.PP
Referenced by _mkdevpath(), _mknotifynode(), _rmnotifynode(), _updateconnected(), mkfwnode(), and rmdevpath()\&.
.SS "long gid = -1"

.PP
Definition at line 16 of file devnode\&.c\&.
.PP
Referenced by _mkdevpath(), _mknotifynode(), _updateconnected(), main(), and mkfwnode()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
