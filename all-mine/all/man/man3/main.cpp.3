.TH "src/ckb/main.cpp" 3 "Tue Jun 6 2017" "Version beta-v0.2.8+testing at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb/main.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'mainwindow\&.h'\fP
.br
\fC#include <QApplication>\fP
.br
\fC#include <QDateTime>\fP
.br
\fC#include <QSharedMemory>\fP
.br
\fC#include <QCommandLineParser>\fP
.br
\fC#include <cstring>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSHMEM_SIZE\fP   128 * 1024"
.br
.ti -1c
.RI "#define \fBSHMEM_SIZE_V015\fP   16"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBCommandLineParseResults\fP { \fBCommandLineOK\fP, \fBCommandLineError\fP, \fBCommandLineVersionRequested\fP, \fBCommandLineHelpRequested\fP, \fBCommandLineClose\fP, \fBCommandLineBackground\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "QSharedMemory \fBappShare\fP ('ckb')"
.br
.ti -1c
.RI "\fBCommandLineParseResults\fP \fBparseCommandLine\fP (QCommandLineParser &parser, QString *errorMessage)"
.br
.RI "\fIparseCommandLine - Setup options and parse command line arguments\&. \fP"
.ti -1c
.RI "static bool \fBpidActive\fP (const QStringList &lines)"
.br
.ti -1c
.RI "static bool \fBisRunning\fP (const char *command)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define SHMEM_SIZE   128 * 1024"

.PP
Definition at line 20 of file main\&.cpp\&.
.PP
Referenced by isRunning()\&.
.SS "#define SHMEM_SIZE_V015   16"

.PP
Definition at line 21 of file main\&.cpp\&.
.PP
Referenced by isRunning()\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBCommandLineParseResults\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICommandLineOK \fP\fP
.TP
\fB\fICommandLineError \fP\fP
.TP
\fB\fICommandLineVersionRequested \fP\fP
.TP
\fB\fICommandLineHelpRequested \fP\fP
.TP
\fB\fICommandLineClose \fP\fP
.TP
\fB\fICommandLineBackground \fP\fP
.PP
Definition at line 24 of file main\&.cpp\&.
.PP
.nf
24                              {
25     CommandLineOK,
26     CommandLineError,
27     CommandLineVersionRequested,
28     CommandLineHelpRequested,
29     CommandLineClose,
30     CommandLineBackground
31 };
.fi
.SH "Function Documentation"
.PP 
.SS "QSharedMemory appShare ('ckb')"

.PP
Referenced by isRunning()\&.
.SS "static bool isRunning (const char *command)\fC [static]\fP"

.PP
Definition at line 109 of file main\&.cpp\&.
.PP
References appShare(), pidActive(), SHMEM_SIZE, and SHMEM_SIZE_V015\&.
.PP
Referenced by main()\&.
.PP
.nf
109                                           {
110     // Try to create shared memory (if successful, application was not already running)
111     if(!appShare\&.create(SHMEM_SIZE) || !appShare\&.lock()){
112         // Lock existing shared memory
113         if(!appShare\&.attach() || !appShare\&.lock())
114             return true;
115         bool running = false;
116         if(appShare\&.size() == SHMEM_SIZE_V015){
117             // Old shmem - no PID listed so assume the process is running, and print the command directly to the buffer
118             if(command){
119                 void* data = appShare\&.data();
120                 snprintf((char*)data, SHMEM_SIZE_V015, "%s", command);
121             }
122             running = true;
123         } else {
124             // New shmem\&. Scan the contents of the shared memory for a PID
125             QStringList lines = QString((const char*)appShare\&.constData())\&.split("\n");
126             if(pidActive(lines)){
127                 running = true;
128                 // Append the command
129                 if(command){
130                     lines\&.append(QString("Option ") + command);
131                     QByteArray newMem = lines\&.join("\n")\&.left(SHMEM_SIZE)\&.toLatin1();
132                     // Copy the NUL byte as well as the string
133                     memcpy(appShare\&.data(), newMem\&.constData(), newMem\&.length() + 1);
134                 }
135             }
136         }
137         if(running){
138             appShare\&.unlock();
139             return true;
140         }
141     }
142     // Not already running\&. Initialize the shared memory with our PID
143     snprintf((char*)appShare\&.data(), appShare\&.size(), "PID %ld", (long)getpid());
144     appShare\&.unlock();
145     return false;
146 }
.fi
.SS "int main (intargc, char *argv[])"

.PP
Definition at line 148 of file main\&.cpp\&.
.PP
References CommandLineBackground, CommandLineClose, CommandLineError, CommandLineHelpRequested, CommandLineOK, CommandLineVersionRequested, disableAppNap(), isRunning(), and parseCommandLine()\&.
.PP
.nf
148                                 {
149     // Setup main application
150     QApplication a(argc, argv);
151 
152     // Setup names and versions
153     QCoreApplication::setOrganizationName("ckb");
154     QCoreApplication::setApplicationVersion(CKB_VERSION_STR);
155     QCoreApplication::setApplicationName("ckb");
156 
157     // Setup argument parser
158     QCommandLineParser parser;
159     QString errorMessage;
160     parser\&.setApplicationDescription("Open Source Corsair Input Device Driver for Linux and OSX\&.");
161     bool background = 0;
162 
163     // Although the daemon runs as root, the GUI needn't and shouldn't be, as it has the potential to corrupt settings data\&.
164     if(getuid() == 0){
165         printf("The ckb GUI should not be run as root\&.\n");
166         return 0;
167     }
168 
169     // Seed the RNG for UsbIds
170     qsrand(QDateTime::currentMSecsSinceEpoch());
171 #ifdef Q_OS_MACX
172     disableAppNap();
173 #endif
174 #if QT_VERSION >= QT_VERSION_CHECK(5, 3, 0)
175     // Enable HiDPI support
176     qApp->setAttribute(Qt::AA_UseHighDpiPixmaps);
177 #endif
178 
179     // Parse arguments
180     switch (parseCommandLine(parser, &errorMessage)) {
181     case CommandLineOK:
182         // If launched with no argument
183         break;
184     case CommandLineError:
185         fputs(qPrintable(errorMessage), stderr);
186         fputs("\n\n", stderr);
187         fputs(qPrintable(parser\&.helpText()), stderr);
188         return 1;
189     case CommandLineVersionRequested:
190         // If launched with --version, print version info and then quit
191         printf("%s %s\n", qPrintable(QCoreApplication::applicationName()),
192                qPrintable(QCoreApplication::applicationVersion()));
193         return 0;
194     case CommandLineHelpRequested:
195         // If launched with --help, print help and then quit
196         parser\&.showHelp();
197         return 0;
198     case CommandLineClose:
199         // If launched with --close, kill existing app
200         if (isRunning("Close"))
201             printf("Asking existing instance to close\&.\n");
202         else
203             printf("ckb is not running\&.\n");
204         return 0;
205     case CommandLineBackground:
206         // If launched with --background, launch in background
207         background = 1;
208         break;
209     }
210 
211     // Launch in background if requested, or if re-launching a previous session
212     if(qApp->isSessionRestored())
213             background = 1;
214     if(isRunning(background ? 0 : "Open")){
215         printf("ckb is already running\&. Exiting\&.\n");
216         return 0;
217     }
218     MainWindow w;
219     if(!background)
220         w\&.show();
221 
222     return a\&.exec();
223 }
.fi
.SS "\fBCommandLineParseResults\fP parseCommandLine (QCommandLineParser &parser, QString *errorMessage)"

.PP
\fBParameters:\fP
.RS 4
\fIparser\fP parser instance to use for parse the arguments 
.br
\fIerrorMessage\fP argument parse error message
.RE
.PP
\fBReturns:\fP
.RS 4
integer, representing the requested argument 
.RE
.PP

.PP
Definition at line 41 of file main\&.cpp\&.
.PP
References CommandLineBackground, CommandLineClose, CommandLineError, CommandLineHelpRequested, CommandLineOK, and CommandLineVersionRequested\&.
.PP
Referenced by main()\&.
.PP
.nf
41                                                                                             {
42     // setup parser to interpret -abc as -a -b -c
43     parser\&.setSingleDashWordOptionMode(QCommandLineParser::ParseAsCompactedShortOptions);
44 
45     /* add command line options */
46     // add -v, --version
47     const QCommandLineOption versionOption = parser\&.addVersionOption();
48     // add -h, --help (/? on windows)
49     const QCommandLineOption helpOption = parser\&.addHelpOption();
50     // add -b, --background
51     const QCommandLineOption backgroundOption(QStringList() << "b" << "background",
52                                               "Starts in background, without displaying the main window\&.");
53     parser\&.addOption(backgroundOption);
54     // add -c, --close
55     const QCommandLineOption closeOption(QStringList() << "c" << "close",
56                                          "Causes already running instance (if any) to exit\&.");
57     parser\&.addOption(closeOption);
58 
59     /* parse arguments */
60     if (!parser\&.parse(QCoreApplication::arguments())) {
61         // set error, if there already are some
62         *errorMessage = parser\&.errorText();
63         return CommandLineError;
64     }
65 
66     /* return requested operation/setup */
67     if (parser\&.isSet(versionOption)) {
68         // print version and exit
69         return CommandLineVersionRequested;
70     }
71 
72     if (parser\&.isSet(helpOption)) {
73         // print help and exit
74         return CommandLineHelpRequested;
75     }
76 
77     if (parser\&.isSet(backgroundOption)) {
78         // open application in background
79         return CommandLineBackground;
80     }
81 
82     if (parser\&.isSet(closeOption)) {
83         // close already running application instances, if any
84         return CommandLineClose;
85     }
86 
87     /* no explicit argument was passed */
88     return CommandLineOK;
89 };
.fi
.SS "static bool pidActive (const QStringList &lines)\fC [static]\fP"

.PP
Definition at line 92 of file main\&.cpp\&.
.PP
Referenced by isRunning()\&.
.PP
.nf
92                                                {
93     foreach(const QString& line, lines){
94         if(line\&.startsWith("PID ")){
95             bool ok;
96             pid_t pid;
97             // Valid PID found?
98             if((pid = line\&.split(" ")[1]\&.toLong(&ok)) > 0 && ok){
99                 // kill -0 does nothing to the application, but checks if it's running
100                 return (kill(pid, 0) == 0 || errno != ESRCH);
101             }
102         }
103     }
104     // If the PID wasn't listed in the shmem, assume it is running
105     return true;
106 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
