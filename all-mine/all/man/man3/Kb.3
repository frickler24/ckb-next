.TH "Kb" 3 "Thu May 25 2017" "Version v0.2.8 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Kb \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kb\&.h>\fP
.PP
Inherits \fBQThread\fP\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "void \fBframeUpdate\fP ()"
.br
.ti -1c
.RI "void \fBautoSave\fP ()"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBinfoUpdated\fP ()"
.br
.ti -1c
.RI "void \fBprofileAdded\fP ()"
.br
.ti -1c
.RI "void \fBprofileRenamed\fP ()"
.br
.ti -1c
.RI "void \fBmodeRenamed\fP ()"
.br
.ti -1c
.RI "void \fBprofileChanged\fP ()"
.br
.ti -1c
.RI "void \fBmodeChanged\fP (bool spontaneous)"
.br
.ti -1c
.RI "void \fBfwUpdateProgress\fP (int \fBcurrent\fP, int total)"
.br
.ti -1c
.RI "void \fBfwUpdateFinished\fP (bool succeeded)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyMap::Model\fP \fBmodel\fP () const "
.br
.ti -1c
.RI "bool \fBisKeyboard\fP () const "
.br
.ti -1c
.RI "bool \fBisMouse\fP () const "
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBhwProfile\fP ()"
.br
.ti -1c
.RI "void \fBhwProfile\fP (\fBKbProfile\fP *newHwProfile)"
.br
.ti -1c
.RI "void \fBfwUpdate\fP (const QString &path)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBcurrentProfile\fP ()"
.br
.ti -1c
.RI "const QList< \fBKbProfile\fP * > & \fBprofiles\fP () const "
.br
.ti -1c
.RI "void \fBprofiles\fP (const QList< \fBKbProfile\fP * > &newProfiles)"
.br
.ti -1c
.RI "void \fBappendProfile\fP (\fBKbProfile\fP *\fBnewProfile\fP)"
.br
.ti -1c
.RI "int \fBindexOf\fP (\fBKbProfile\fP *profile)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBfind\fP (const QUuid &id)"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBcurrentMode\fP ()"
.br
.ti -1c
.RI "\fBKbLight\fP * \fBcurrentLight\fP ()"
.br
.ti -1c
.RI "\fBKbBind\fP * \fBcurrentBind\fP ()"
.br
.ti -1c
.RI "\fBKbPerf\fP * \fBcurrentPerf\fP ()"
.br
.ti -1c
.RI "void \fBsetCurrentProfile\fP (\fBKbProfile\fP *profile, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbProfile\fP *profile, \fBKbMode\fP *mode, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbProfile\fP *profile, int index, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbMode\fP *mode, bool spontaneous=true)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBnewProfile\fP ()"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBnewProfile\fP (\fBKbProfile\fP *other)"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBnewMode\fP ()"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBnewMode\fP (\fBKbMode\fP *other)"
.br
.ti -1c
.RI "void \fBload\fP ()"
.br
.ti -1c
.RI "void \fBsave\fP ()"
.br
.ti -1c
.RI "bool \fBneedsSave\fP () const "
.br
.ti -1c
.RI "void \fBhwSave\fP ()"
.br
.ti -1c
.RI "int \fBgetMacroNumber\fP ()"
.br
.RI "\fIFor usage with macro definions, these two params must only be readable\&. So there are no setters\&. \fP"
.ti -1c
.RI "QString \fBgetMacroPath\fP ()"
.br
.RI "\fIgetMacroPath returns the macroPath (e\&.g\&. /dev/input/ckb1/notify), which we have saved in the constructor\&. For usage with macro definions, this param must only be readable\&. So there is no setter\&. \fP"
.ti -1c
.RI "\fB~Kb\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBframeRate\fP ()"
.br
.ti -1c
.RI "static void \fBframeRate\fP (int newFrameRate)"
.br
.ti -1c
.RI "static \fBKeyMap::Layout\fP \fBlayout\fP ()"
.br
.ti -1c
.RI "static void \fBlayout\fP (\fBKeyMap::Layout\fP newLayout)"
.br
.ti -1c
.RI "static bool \fBdither\fP ()"
.br
.ti -1c
.RI "static void \fBdither\fP (bool newDither)"
.br
.ti -1c
.RI "static bool \fBmacroDelay\fP ()"
.br
.ti -1c
.RI "static void \fBmacroDelay\fP (bool flag)"
.br
.RI "\fI\fBKb::macroDelay\fP handles the UI-Element macroBox\&. Sends a command to the keyboard to switch on or off the delay function on very large macros\&. \fP"
.ti -1c
.RI "static bool \fBmouseAccel\fP ()"
.br
.ti -1c
.RI "static void \fBmouseAccel\fP (bool newAccel)"
.br
.ti -1c
.RI "static int \fBscrollSpeed\fP ()"
.br
.ti -1c
.RI "static void \fBscrollSpeed\fP (int newSpeed)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "QString \fBusbModel\fP"
.br
.ti -1c
.RI "QString \fBusbSerial\fP"
.br
.ti -1c
.RI "QString \fBfeatures\fP"
.br
.ti -1c
.RI "QString \fBfirmware\fP"
.br
.ti -1c
.RI "QString \fBpollrate\fP"
.br
.ti -1c
.RI "bool \fBmonochrome\fP"
.br
.ti -1c
.RI "int \fBhwModeCount\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBHWMODE_MAX\fP = 3"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBreadNotify\fP (QString line)"
.br
.ti -1c
.RI "void \fBdeleteHw\fP ()"
.br
.ti -1c
.RI "void \fBdeletePrevious\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKb\fP (\fBQObject\fP *parent, const QString &path)"
.br
.RI "\fI
.PP
.RS 4
is invalid also\&. 
.RE
.PP
\fP"
.ti -1c
.RI "bool \fBisOpen\fP () const "
.br
.ti -1c
.RI "bool \fBmatches\fP (const QString &path, const QString &serial)"
.br
.ti -1c
.RI "void \fBupdateLayout\fP ()"
.br
.ti -1c
.RI "void \fBwriteProfileHeader\fP ()"
.br
.ti -1c
.RI "\fBKeyMap\fP \fBgetKeyMap\fP ()"
.br
.ti -1c
.RI "void \fBrun\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QString \fBdevpath\fP"
.br
.RI "\fIpathVars devpath is the device root path (e\&.g\&. /dev/device/ckb1), cmdpath leads to the daemon input pipe for daemon commands, notifyPath is the standard input monitor for general purpose\&. \fP"
.ti -1c
.RI "QString \fBcmdpath\fP"
.br
.ti -1c
.RI "QString \fBnotifyPath\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fB_currentProfile\fP"
.br
.ti -1c
.RI "QList< \fBKbProfile\fP * > \fB_profiles\fP"
.br
.ti -1c
.RI "\fBKbMode\fP * \fB_currentMode\fP"
.br
.ti -1c
.RI "\fBKeyMap::Model\fP \fB_model\fP"
.br
.ti -1c
.RI "bool \fBiState\fP [\fBKbPerf::HW_I_COUNT\fP]"
.br
.ti -1c
.RI "QString \fBprefsPath\fP"
.br
.ti -1c
.RI "quint64 \fBlastAutoSave\fP"
.br
.ti -1c
.RI "QString \fBfwUpdPath\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fB_hwProfile\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBprevProfile\fP"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBprevMode\fP"
.br
.ti -1c
.RI "QFile \fBcmd\fP"
.br
.ti -1c
.RI "int \fBnotifyNumber\fP"
.br
.RI "\fInotifyNumber is the trailing number in the device path\&. \fP"
.ti -1c
.RI "bool \fB_needsSave\fP"
.br
.ti -1c
.RI "bool \fBhwLoading\fP [\fBHWMODE_MAX\fP+1]"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static QString \fBmacroPath\fP = ''"
.br
.RI "\fImacroPath added for a second thread to read macro input\&. Must be static, because there is only one keyboard but multiple devices\&. \fP"
.ti -1c
.RI "static \fBKeyMap::Layout\fP \fB_layout\fP = \fBKeyMap::NO_LAYOUT\fP"
.br
.ti -1c
.RI "static int \fB_frameRate\fP = 30"
.br
.ti -1c
.RI "static int \fB_scrollSpeed\fP = 0"
.br
.ti -1c
.RI "static bool \fB_dither\fP = false"
.br
.ti -1c
.RI "static bool \fB_mouseAccel\fP = true"
.br
.ti -1c
.RI "static int \fBmacroNumber\fP = -1"
.br
.RI "\fIMacro Number to notify macro definition events\&. As macroPath, macroNumber must be static, because only keyboard may set this value and others (eg mice) needs to read it\&. \fP"
.ti -1c
.RI "static bool \fB_delay\fP = false"
.br
.RI "\fIflag if macro delay hast to be switched on \fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBKbManager\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 11 of file kb\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Kb::~Kb ()"
<
.PP
\fBTodo\fP
.RS 4
I don't think, that notifypaths is used somewhere\&. So why do we have it? If we do not need it, searching for an ununsed notify channel can easy be refactored to a private member function\&. 
.RE
.PP

.PP
Definition at line 159 of file kb\&.cpp\&.
.PP
References activeDevices, isOpen(), macroPath, notifyNumber, notifyPaths, and save()\&.
.PP
.nf
159        {
160     // Save settings first
161     save();
162 
163     // remove the notify channel from the list of notifyPaths\&.
166     notifyPaths\&.remove(macroPath);
167 
168     // Kill notification thread and remove node
169     activeDevices\&.remove(this);
170     if(!isOpen()){
171         terminate();
172         wait(1000);
173         return;
174     }
175     if(notifyNumber > 0)
176         cmd\&.write(QString("idle\nnotifyoff %1\n")\&.arg(notifyNumber)\&.toLatin1());
177     cmd\&.flush();
178     terminate();
179     wait(1000);
180     cmd\&.close();
181 }
.fi
.SS "Kb::Kb (\fBQObject\fP *parent, const QString &path)\fC [private]\fP"
Open cmd in non-blocking mode so that it doesn't lock up if nothing is reading (e\&.g\&. if the daemon crashed and didn't clean up the node)
.PP
Find an available notification node (if none is found, take notify1)
.PP
Again, find an available notification node for macro definition if we handle a keyboard\&. (if none is found, take notify2)
.PP
.RS 4
Block ist used to have QMutexLocker as an auto var\&. 
.RE
.PP
.PP
<
.PP
\fBTodo\fP
.RS 4
Is adding notifyX to the notifypaths neccessary? 
.RE
.PP

.PP
Definition at line 22 of file kb\&.cpp\&.
.PP
References _delay, _dither, _frameRate, _layout, _mouseAccel, _scrollSpeed, activeDevices, cmdpath, features, firmware, KeyMap::getModel(), hwLoading, hwModeCount, infoUpdated(), KeyMap::isISO(), isKeyboard(), iState, KeyMap::K95, macroNumber, macroPath, monochrome, KeyMap::NO_MODEL, notifyNumber, notifyPath, notifyPathMutex, notifyPaths, pollrate, prefsPath, usbModel, and usbSerial\&.
.PP
.nf
22                                            :
23     QThread(parent), features("N/A"), firmware("N/A"), pollrate("N/A"), monochrome(false),
24     devpath(path), cmdpath(path + "/cmd"), notifyPath(path + "/notify1"),
25     _currentProfile(0), _currentMode(0), _model(KeyMap::NO_MODEL),
26     lastAutoSave(QDateTime::currentMSecsSinceEpoch()),
27     _hwProfile(0), prevProfile(0), prevMode(0),
28     cmd(cmdpath), notifyNumber(1), _needsSave(false)
29 {
30     memset(iState, 0, sizeof(iState));
31     memset(hwLoading, 0, sizeof(hwLoading));
32 
33     // Get the features, model, serial number, FW version (if available), and poll rate (if available) from /dev nodes
34     QFile ftpath(path + "/features"), mpath(path + "/model"), spath(path + "/serial"), fwpath(path + "/fwversion"), ppath(path + "/pollrate");
35     if(ftpath\&.open(QIODevice::ReadOnly)){
36         features = ftpath\&.read(1000);
37         features = features\&.trimmed();
38         ftpath\&.close();
39         // Read model from features (first word: vendor, second word: product)
40         QStringList list = features\&.split(" ");
41         if(list\&.length() < 2) {
42             qDebug() << "Kb::Kb() Error in reading features, read" << list\&.length() << "entries, 2 expected\&.";
43             return;
44         }
45         _model = KeyMap::getModel(list[1]);
46         if(_model == KeyMap::NO_MODEL)
47             return;
48     } else
49         // Bail if features aren't readable
50         return;
51     if(features\&.contains("monochrome"))
52         monochrome = true;
53     if(mpath\&.open(QIODevice::ReadOnly)){
54         usbModel = mpath\&.read(100);
55         usbModel = usbModel\&.remove("Corsair")\&.remove("Gaming")\&.remove("Keyboard")\&.remove("Mouse")\&.remove("Bootloader")\&.trimmed();
56         mpath\&.close();
57     }
58     if(usbModel == "")
59         usbModel = "Keyboard";
60     if(spath\&.open(QIODevice::ReadOnly)){
61         usbSerial = spath\&.read(100);
62         usbSerial = usbSerial\&.trimmed()\&.toUpper();
63         spath\&.close();
64     }
65     if(usbSerial == "")
66         usbSerial = "Unknown-" + usbModel;
67     if(features\&.contains("fwversion") && fwpath\&.open(QIODevice::ReadOnly)){
68         firmware = fwpath\&.read(100);
69         firmware = QString::number(firmware\&.trimmed()\&.toInt() / 100\&., 'f', 2);
70         fwpath\&.close();
71     }
72     if(features\&.contains("pollrate") && ppath\&.open(QIODevice::ReadOnly)){
73         pollrate = ppath\&.read(100);
74         pollrate = pollrate\&.trimmed();
75         ppath\&.close();
76     }
77     prefsPath = "Devices/" + usbSerial;
78     qDebug() << "Features =" << features;
79 
80     hwModeCount = (_model == KeyMap::K95) ? 3 : 1;
83     int fd = open(cmdpath\&.toLatin1()\&.constData(), O_WRONLY | O_NONBLOCK);
84     if(!cmd\&.open(fd, QIODevice::WriteOnly, QFileDevice::AutoCloseHandle))
85         return;
86 
88     {
89         QMutexLocker locker(&notifyPathMutex);
90         for (int i = 1; i < 10; i++) {
91             QString notify = QString(path + "/notify%1")\&.arg(i);
92             if(!QFile::exists(notify) && !notifyPaths\&.contains(notify)){
93                 notifyNumber = i;
94                 notifyPath = notify;
95                 break;
96             }
97         }
98         notifyPaths\&.insert(notifyPath);
99     }
100     cmd\&.write(QString("notifyon %1\n")\&.arg(notifyNumber)\&.toLatin1());
101     cmd\&.flush();
102 
105     if (isKeyboard()) {
106         qDebug() << "Keyboard detected, setting macroPath and macroNumber";
107         if (macroPath != "") {
108             qDebug() << "Warning: Redefinition of macroPath\&. Value was" << macroPath;
109         }
110         {   
111             QMutexLocker locker(&notifyPathMutex);
112             int i;
113             for (i = 1; i < 10; i++) {
114                 QString notify = QString(path + "/notify%1")\&.arg(i);
115                 if(!QFile::exists(notify) && !notifyPaths\&.contains(notify)){
116                     macroNumber = i;
117                     break;
118                 }
119             }
120             if (i == 10) {
121                 macroNumber = 2;
122             }
123             macroPath = path;
124             notifyPaths\&.insert(QString(macroPath + "/notify%1")\&.arg(macroNumber)); 
125             qDebug() << "new macroPath =" << macroPath << "and macroNumber =" << macroNumber;
126         }
127     } else {
128         qDebug() << "No Keyboard detected, leaving macroPath as is:" << macroPath << "and macroNumber as" << macroNumber;
129     }
130     // Activate device, apply settings, and ask for hardware profile
131     cmd\&.write(QString("fps %1\n")\&.arg(_frameRate)\&.toLatin1());
132     cmd\&.write(QString("dither %1\n")\&.arg(static_cast<int>(_dither))\&.toLatin1());
133     cmd\&.write(QString("\ndelay %1\n")\&.arg(_delay? "on" : "off")\&.toLatin1());
134 #ifdef Q_OS_MACX
135     // Write ANSI/ISO flag to daemon (OSX only)
136     cmd\&.write("layout ");
137     cmd\&.write(KeyMap::isISO(_layout) ? "iso" : "ansi");
138     // Also OSX only: scroll speed and mouse acceleration
139     cmd\&.write(QString("accel %1\n")\&.arg(QString(_mouseAccel ? "on" : "off"))\&.toLatin1());
140     cmd\&.write(QString("scrollspeed %1\n")\&.arg(_scrollSpeed)\&.toLatin1());
141 #endif
142     cmd\&.write(QString("\nactive\n@%1 get :hwprofileid")\&.arg(notifyNumber)\&.toLatin1());
143     hwLoading[0] = true;
144     for(int i = 0; i < hwModeCount; i++){
145         cmd\&.write(QString(" mode %1 get :hwid")\&.arg(i + 1)\&.toLatin1());
146         hwLoading[i + 1] = true;
147     }
148     // Ask for current indicator and key state
149     cmd\&.write(" get :i :keys\n");
150     cmd\&.flush();
151 
152     emit infoUpdated();
153     activeDevices\&.insert(this);
154 
155     // Start a separate thread to read from the notification node
156     start();
157 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Kb::appendProfile (\fBKbProfile\fP *newProfile)\fC [inline]\fP"

.PP
Definition at line 60 of file kb\&.h\&.
.PP
References _needsSave, and _profiles\&.
.PP
Referenced by KbProfileDialog::on_profileList_itemClicked()\&.
.PP
.nf
60 { _needsSave = true; _profiles\&.append(newProfile); }
.fi
.SS "void Kb::autoSave ()\fC [slot]\fP"

.PP
Definition at line 307 of file kb\&.cpp\&.
.PP
References CkbSettings::isBusy(), lastAutoSave, needsSave(), and save()\&.
.PP
.nf
307                  {
308     quint64 now = QDateTime::currentMSecsSinceEpoch();
309     if(needsSave() && now >= lastAutoSave + 15 * 1000 && !CkbSettings::isBusy()){
310         save();
311         lastAutoSave = now;
312     }
313 }
.fi
.SS "\fBKbBind\fP* Kb::currentBind ()\fC [inline]\fP"

.PP
Definition at line 67 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::bind()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
67 { return !_currentMode ? 0 : _currentMode->bind(); }
.fi
.SS "\fBKbLight\fP* Kb::currentLight ()\fC [inline]\fP"

.PP
Definition at line 66 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::light()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
66 { return !_currentMode ? 0 : _currentMode->light(); }
.fi
.SS "\fBKbMode\fP* Kb::currentMode ()\fC [inline]\fP"

.PP
Definition at line 65 of file kb\&.h\&.
.PP
References _currentMode\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
65 { return _currentMode; }
.fi
.SS "\fBKbPerf\fP* Kb::currentPerf ()\fC [inline]\fP"

.PP
Definition at line 68 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::perf()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
68 { return !_currentMode ? 0 : _currentMode->perf(); }
.fi
.SS "\fBKbProfile\fP* Kb::currentProfile ()\fC [inline]\fP"

.PP
Definition at line 56 of file kb\&.h\&.
.PP
References _currentProfile\&.
.PP
Referenced by KeyAction::keyEvent(), KbWidget::modeChanged(), KbWidget::modeIcon(), KbWidget::modesList_reordered(), KbWidget::on_modesList_currentItemChanged(), KbWidget::on_modesList_customContextMenuRequested(), KbWidget::on_modesList_itemClicked(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemChanged(), KbWidget::profileChanged(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
56 { return _currentProfile; }
.fi
.SS "void Kb::deleteHw ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 459 of file kb\&.cpp\&.
.PP
References _hwProfile\&.
.PP
Referenced by hwProfile()\&.
.PP
.nf
459                  {
460     disconnect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
461     _hwProfile = 0;
462 }
.fi
.SS "void Kb::deletePrevious ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 444 of file kb\&.cpp\&.
.PP
References prevMode\&.
.PP
Referenced by frameUpdate(), and hwSave()\&.
.PP
.nf
444                        {
445     disconnect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
446     prevMode = 0;
447 }
.fi
.SS "static bool Kb::dither ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 33 of file kb\&.h\&.
.PP
References _dither\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_ditherBox_clicked()\&.
.PP
.nf
33 { return _dither; }
.fi
.SS "void Kb::dither (boolnewDither)\fC [static]\fP"

.PP
Definition at line 222 of file kb\&.cpp\&.
.PP
References _dither, activeDevices, and cmd\&.
.PP
.nf
222                              {
223     if(newDither == _dither)
224         return;
225     _dither = newDither;
226     // Update all devices
227     foreach(Kb* kb, activeDevices){
228         kb->cmd\&.write(QString("dither %1\n")\&.arg(static_cast<int>(newDither))\&.toLatin1());
229         kb->cmd\&.flush();
230     }
231 }
.fi
.SS "\fBKbProfile\fP* Kb::find (const QUuid &id)\fC [inline]\fP"

.PP
Definition at line 62 of file kb\&.h\&.
.PP
References _profiles, UsbId::guid, and KbProfile::id()\&.
.PP
Referenced by KbProfileDialog::on_profileList_currentItemChanged(), KbProfileDialog::on_profileList_customContextMenuRequested(), and KbProfileDialog::profileList_reordered()\&.
.PP
.nf
62 { foreach(KbProfile* profile, _profiles) { if(profile->id()\&.guid == id) return profile; } return 0; }
.fi
.SS "static int Kb::frameRate ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 27 of file kb\&.h\&.
.PP
References _frameRate\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_fpsBox_valueChanged()\&.
.PP
.nf
27 { return _frameRate; }
.fi
.SS "void Kb::frameRate (intnewFrameRate)\fC [static]\fP"

.PP
Definition at line 183 of file kb\&.cpp\&.
.PP
References _frameRate, activeDevices, cmd, and KbManager::fps()\&.
.PP
.nf
183                                   {
184     KbManager::fps(newFrameRate);
185     // If the rate has changed, send to all devices
186     if(newFrameRate == _frameRate)
187         return;
188     _frameRate = newFrameRate;
189     foreach(Kb* kb, activeDevices){
190         kb->cmd\&.write(QString("fps %1\n")\&.arg(newFrameRate)\&.toLatin1());
191         kb->cmd\&.flush();
192     }
193 }
.fi
.SS "void Kb::frameUpdate ()\fC [slot]\fP"

.PP
Definition at line 393 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, KbPerf::applyIndicators(), KbMode::bind(), KbLight::close(), deletePrevious(), KbLight::frameUpdate(), KbProfile::indexOf(), KbLight::isStarted(), iState, KbMode::light(), monochrome, notifyNumber, KbLight::open(), KbMode::perf(), prevMode, prevProfile, KbBind::update(), KbPerf::update(), and writeProfileHeader()\&.
.PP
.nf
393                     {
394     // Advance animation frame
395     if(!_currentMode)
396         return;
397     KbLight* light = _currentMode->light();
398     KbBind* bind = _currentMode->bind();
399     KbPerf* perf = _currentMode->perf();
400     if(!light->isStarted()){
401         // Don't do anything until the animations are started
402         light->open();
403         return;
404     }
405 
406     // Stop animations on the previously active mode (if any)
407     bool changed = false;
408     if(prevMode != _currentMode){
409         if(prevMode){
410             prevMode->light()->close();
411             disconnect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
412         }
413         prevMode = _currentMode;
414         connect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
415         changed = true;
416     }
417 
418     // If the profile has changed, update it
419     if(prevProfile != _currentProfile){
420         writeProfileHeader();
421         cmd\&.write(" ");
422         prevProfile = _currentProfile;
423     }
424 
425     // Update current mode
426     int index = _currentProfile->indexOf(_currentMode);
427     // ckb-daemon only has 6 modes: 3 hardware, 3 non-hardware\&. Beyond mode six, switch back to four\&.
428     // e\&.g\&. 1, 2, 3, 4, 5, 6, 4, 5, 6, 4, 5, 6 \&.\&.\&.
429     if(index >= 6)
430         index = 3 + index % 3;
431 
432     // Send lighting/binding to driver
433     cmd\&.write(QString("mode %1 switch ")\&.arg(index + 1)\&.toLatin1());
434     perf->applyIndicators(index, iState);
435     light->frameUpdate(cmd, monochrome);
436     cmd\&.write(QString("\n@%1 ")\&.arg(notifyNumber)\&.toLatin1());
437     bind->update(cmd, changed);
438     cmd\&.write(" ");
439     perf->update(cmd, notifyNumber, changed);
440     cmd\&.write("\n");
441     cmd\&.flush();
442 }
.fi
.SS "void Kb::fwUpdate (const QString &path)"

.PP
Definition at line 383 of file kb\&.cpp\&.
.PP
References fwUpdPath, and notifyNumber\&.
.PP
Referenced by FwUpgradeDialog::on_actionButton_clicked()\&.
.PP
.nf
383                                     {
384     fwUpdPath = path;
385     // Write the active command to ensure it's not ignored
386     cmd\&.write("active");
387     cmd\&.write(QString(" @%1 ")\&.arg(notifyNumber)\&.toLatin1());
388     cmd\&.write("fwupdate ");
389     cmd\&.write(path\&.toLatin1());
390     cmd\&.write("\n");
391 }
.fi
.SS "void Kb::fwUpdateFinished (boolsucceeded)\fC [signal]\fP"

.PP
Definition at line 277 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
278 {
279     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
280     QMetaObject::activate(this, &staticMetaObject, 7, _a);
281 }
.fi
.SS "void Kb::fwUpdateProgress (intcurrent, inttotal)\fC [signal]\fP"

.PP
Definition at line 270 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
271 {
272     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
273     QMetaObject::activate(this, &staticMetaObject, 6, _a);
274 }
.fi
.SS "\fBKeyMap\fP Kb::getKeyMap ()\fC [private]\fP"

.PP
Definition at line 774 of file kb\&.cpp\&.
.PP
References _layout\&.
.PP
Referenced by hwSave(), load(), newMode(), newProfile(), readNotify(), setCurrentProfile(), and updateLayout()\&.
.PP
.nf
774                     {
775     return KeyMap(_model, _layout);
776 }
.fi
.SS "int Kb::getMacroNumber ()\fC [inline]\fP"
getMacroNumber returns the macroNumber, which we have saved in the constructor\&. For usage with macro definions, this param must only be readable\&. So there is no setter\&. 
.PP
\fBReturns:\fP
.RS 4
The Number is returned as int\&. 
.RE
.PP

.PP
Definition at line 97 of file kb\&.h\&.
.PP
References macroNumber\&.
.PP
Referenced by KbBind::getMacroNumber()\&.
.PP
.nf
97 { return macroNumber; }
.fi
.SS "QString Kb::getMacroPath ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
The absolute path as String 
.RE
.PP

.PP
Definition at line 106 of file kb\&.h\&.
.PP
References macroPath\&.
.PP
Referenced by KbBind::getMacroPath()\&.
.PP
.nf
106 { return macroPath; }
.fi
.SS "\fBKbProfile\fP* Kb::hwProfile ()\fC [inline]\fP"

.PP
Definition at line 46 of file kb\&.h\&.
.PP
References _hwProfile\&.
.PP
Referenced by hwSave(), KbWidget::modeIcon(), KbProfileDialog::on_profileList_customContextMenuRequested(), readNotify(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
46 { return _hwProfile; }
.fi
.SS "void Kb::hwProfile (\fBKbProfile\fP *newHwProfile)"

.PP
Definition at line 449 of file kb\&.cpp\&.
.PP
References _hwProfile, and deleteHw()\&.
.PP
.nf
449                                          {
450     if(_hwProfile == newHwProfile)
451         return;
452     if(_hwProfile)
453         disconnect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
454     _hwProfile = newHwProfile;
455     if(_hwProfile)
456         connect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
457 }
.fi
.SS "void Kb::hwSave ()"

.PP
Definition at line 315 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _hwProfile, KbProfile::append(), KbLight::base(), KbLight::close(), deletePrevious(), getKeyMap(), UsbId::guidString(), hwModeCount, UsbId::hwModified, hwProfile(), KbProfile::id(), KbMode::id(), KbMode::light(), KbProfile::modeCount(), KbProfile::modes(), UsbId::modified, UsbId::modifiedString(), monochrome, KbMode::name(), KbMode::perf(), prevMode, KbProfile::setNeedsSave(), KbMode::setNeedsSave(), KbPerf::update(), and writeProfileHeader()\&.
.PP
Referenced by KbWidget::on_hwSaveButton_clicked(), and KbProfileDialog::on_profileList_customContextMenuRequested()\&.
.PP
.nf
315                {
316     if(!_currentProfile)
317         return;
318     // Close active lighting (if any)
319     if(prevMode){
320         prevMode->light()->close();
321         deletePrevious();
322     }
323     hwProfile(_currentProfile);
324     _hwProfile->id()\&.hwModified = _hwProfile->id()\&.modified;
325     _hwProfile->setNeedsSave();
326     // Re-send the current profile from scratch to ensure consistency
327     writeProfileHeader();
328     // Make sure there are enough modes
329     while(_currentProfile->modeCount() < hwModeCount)
330         _currentProfile->append(new KbMode(this, getKeyMap()));
331     // Write only the base colors of each mode, no animations
332     for(int i = 0; i < hwModeCount; i++){
333         KbMode* mode = _currentProfile->modes()[i];
334         cmd\&.write(QString("\nmode %1")\&.arg(i + 1)\&.toLatin1());
335         KbLight* light = mode->light();
336         KbPerf* perf = mode->perf();
337         if(mode == _currentMode)
338             cmd\&.write(" switch");
339         // Write the mode name and ID
340         cmd\&.write(" name ");
341         cmd\&.write(QUrl::toPercentEncoding(mode->name()));
342         cmd\&.write(" id ");
343         cmd\&.write(mode->id()\&.guidString()\&.toLatin1());
344         cmd\&.write(" ");
345         cmd\&.write(mode->id()\&.modifiedString()\&.toLatin1());
346         cmd\&.write(" ");
347         // Write lighting and performance
348         light->base(cmd, true, monochrome);
349         cmd\&.write(" ");
350         perf->update(cmd, true, false);
351         // Update mode ID
352         mode->id()\&.hwModified = mode->id()\&.modified;
353         mode->setNeedsSave();
354     }
355     cmd\&.write("\n");
356 
357     // Save the profile to memory
358     cmd\&.write("hwsave\n");
359     cmd\&.flush();
360 }
.fi
.SS "int Kb::indexOf (\fBKbProfile\fP *profile)\fC [inline]\fP"

.PP
Definition at line 61 of file kb\&.h\&.
.PP
References _profiles\&.
.PP
Referenced by KbProfileDialog::on_profileList_customContextMenuRequested()\&.
.PP
.nf
61 { return _profiles\&.indexOf(profile); }
.fi
.SS "void Kb::infoUpdated ()\fC [signal]\fP"

.PP
Definition at line 233 of file moc_kb\&.cpp\&.
.PP
Referenced by Kb(), load(), and updateLayout()\&.
.PP
.nf
234 {
235     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
236 }
.fi
.SS "bool Kb::isKeyboard () const\fC [inline]\fP"

.PP
Definition at line 23 of file kb\&.h\&.
.PP
References KeyMap::isKeyboard()\&.
.PP
Referenced by Kb(), and KbWidget::KbWidget()\&.
.PP
.nf
23 { return KeyMap::isKeyboard(_model); }
.fi
.SS "bool Kb::isMouse () const\fC [inline]\fP"

.PP
Definition at line 24 of file kb\&.h\&.
.PP
References KeyMap::isMouse()\&.
.PP
Referenced by KbWidget::KbWidget(), and readNotify()\&.
.PP
.nf
24 { return KeyMap::isMouse(_model); }
.fi
.SS "bool Kb::isOpen () const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 147 of file kb\&.h\&.
.PP
Referenced by KbManager::scanKeyboards(), and ~Kb()\&.
.PP
.nf
147 { return cmd\&.isOpen(); }
.fi
.SS "static \fBKeyMap::Layout\fP Kb::layout ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 30 of file kb\&.h\&.
.PP
References _layout\&.
.PP
Referenced by LayoutDialog::LayoutDialog(), SettingsWidget::on_layoutBox_activated(), and SettingsWidget::SettingsWidget()\&.
.PP
.nf
30 { return _layout; }
.fi
.SS "void Kb::layout (\fBKeyMap::Layout\fPnewLayout)\fC [static]\fP"

.PP
Definition at line 195 of file kb\&.cpp\&.
.PP
References _layout, activeDevices, KeyMap::NO_LAYOUT, and updateLayout()\&.
.PP
.nf
195                                      {
196     if(newLayout == KeyMap::NO_LAYOUT || newLayout == _layout)
197         return;
198     _layout = newLayout;
199     // Update all devices
200     foreach(Kb* kb, activeDevices)
201         kb->updateLayout();
202 }
.fi
.SS "void Kb::load ()"

.PP
Definition at line 259 of file kb\&.cpp\&.
.PP
References _needsSave, _profiles, current, getKeyMap(), infoUpdated(), prefsPath, profileAdded(), setCurrentProfile(), and CkbSettings::value()\&.
.PP
Referenced by KbManager::scanKeyboards()\&.
.PP
.nf
259              {
260     if(prefsPath\&.isEmpty())
261         return;
262     _needsSave = false;
263     CkbSettings settings(prefsPath);
264     // Read profiles
265     KbProfile* newCurrentProfile = 0;
266     QString current = settings\&.value("CurrentProfile")\&.toString()\&.trimmed()\&.toUpper();
267     foreach(QString guid, settings\&.value("Profiles")\&.toString()\&.split(" ")){
268         guid = guid\&.trimmed()\&.toUpper();
269         if(guid != ""){
270             KbProfile* profile = new KbProfile(this, getKeyMap(), settings, guid);
271             _profiles\&.append(profile);
272             if(guid == current || !newCurrentProfile)
273                 newCurrentProfile = profile;
274         }
275     }
276     if(newCurrentProfile)
277         setCurrentProfile(newCurrentProfile);
278     else {
279         // If nothing was loaded, load the demo profile
280         QSettings demoSettings(":/txt/demoprofile\&.conf", QSettings::IniFormat, this);
281         CkbSettings cSettings(demoSettings);
282         KbProfile* demo = new KbProfile(this, getKeyMap(), cSettings, "{BA7FC152-2D51-4C26-A7A6-A036CC93D924}");
283         _profiles\&.append(demo);
284         setCurrentProfile(demo);
285     }
286 
287     emit infoUpdated();
288     emit profileAdded();
289 }
.fi
.SS "static bool Kb::macroDelay ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 36 of file kb\&.h\&.
.PP
References _delay\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_delayBox_clicked()\&.
.PP
.nf
36 { return _delay; }
.fi
.SS "void Kb::macroDelay (boolflag)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIflag\fP true: Switch on delay function, else switch off 
.RE
.PP

.PP
Definition at line 805 of file kb\&.cpp\&.
.PP
References _delay, activeDevices, and cmd\&.
.PP
.nf
805                              {
806    _delay = flag;
807 
808    foreach(Kb* kb, activeDevices){
809        kb->cmd\&.write(QString("\ndelay %1\n")\&.arg(flag? "on" : "off")\&.toLatin1());
810    }
811 }
.fi
.SS "bool Kb::matches (const QString &path, const QString &serial)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 161 of file kb\&.h\&.
.PP
References devpath, and usbSerial\&.
.PP
Referenced by KbManager::scanKeyboards()\&.
.PP
.nf
161 { return path\&.trimmed() == devpath\&.trimmed() && usbSerial == serial\&.trimmed()\&.toUpper(); }
.fi
.SS "void Kb::modeChanged (boolspontaneous)\fC [signal]\fP"

.PP
Definition at line 263 of file moc_kb\&.cpp\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
264 {
265     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
266     QMetaObject::activate(this, &staticMetaObject, 5, _a);
267 }
.fi
.SS "\fBKeyMap::Model\fP Kb::model () const\fC [inline]\fP"

.PP
Definition at line 22 of file kb\&.h\&.
.PP
References _model\&.
.PP
.nf
22 { return _model; }
.fi
.SS "void Kb::modeRenamed ()\fC [signal]\fP"

.PP
Definition at line 251 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
252 {
253     QMetaObject::activate(this, &staticMetaObject, 3, Q_NULLPTR);
254 }
.fi
.SS "static bool Kb::mouseAccel ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 39 of file kb\&.h\&.
.PP
References _mouseAccel\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_mAccelBox_clicked()\&.
.PP
.nf
39 { return _mouseAccel; }
.fi
.SS "void Kb::mouseAccel (boolnewAccel)\fC [static]\fP"

.PP
Definition at line 233 of file kb\&.cpp\&.
.PP
References _mouseAccel, activeDevices, and cmd\&.
.PP
.nf
233                                 {
234     if(newAccel == _mouseAccel)
235         return;
236     _mouseAccel = newAccel;
237 #ifdef Q_OS_MACX
238     // Update all devices
239     foreach(Kb* kb, activeDevices){
240         kb->cmd\&.write(QString("accel %1\n")\&.arg(QString(newAccel ? "on" : "off"))\&.toLatin1());
241         kb->cmd\&.flush();
242     }
243 #endif
244 }
.fi
.SS "bool Kb::needsSave () const"

.PP
Definition at line 362 of file kb\&.cpp\&.
.PP
References _needsSave, _profiles, and KbProfile::needsSave()\&.
.PP
Referenced by autoSave()\&.
.PP
.nf
362                          {
363     if(_needsSave)
364         return true;
365     foreach(const KbProfile* profile, _profiles){
366         if(profile->needsSave())
367             return true;
368     }
369     return false;
370 }
.fi
.SS "\fBKbMode\fP* Kb::newMode ()\fC [inline]\fP"

.PP
Definition at line 79 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
Referenced by KbWidget::on_modesList_customContextMenuRequested(), and KbWidget::on_modesList_itemClicked()\&.
.PP
.nf
79 { return new KbMode(this, getKeyMap()); }
.fi
.SS "\fBKbMode\fP* Kb::newMode (\fBKbMode\fP *other)\fC [inline]\fP"

.PP
Definition at line 80 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
.nf
80 { return new KbMode(this, getKeyMap(), *other); }
.fi
.SS "\fBKbProfile\fP* Kb::newProfile ()\fC [inline]\fP"

.PP
Definition at line 77 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
Referenced by KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemClicked(), and readNotify()\&.
.PP
.nf
77 { return new KbProfile(this, getKeyMap()); }
.fi
.SS "\fBKbProfile\fP* Kb::newProfile (\fBKbProfile\fP *other)\fC [inline]\fP"

.PP
Definition at line 78 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
.nf
78 { return new KbProfile(this, getKeyMap(), *other); }
.fi
.SS "void Kb::profileAdded ()\fC [signal]\fP"

.PP
Definition at line 239 of file moc_kb\&.cpp\&.
.PP
Referenced by load(), and readNotify()\&.
.PP
.nf
240 {
241     QMetaObject::activate(this, &staticMetaObject, 1, Q_NULLPTR);
242 }
.fi
.SS "void Kb::profileChanged ()\fC [signal]\fP"

.PP
Definition at line 257 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify(), and setCurrentMode()\&.
.PP
.nf
258 {
259     QMetaObject::activate(this, &staticMetaObject, 4, Q_NULLPTR);
260 }
.fi
.SS "void Kb::profileRenamed ()\fC [signal]\fP"

.PP
Definition at line 245 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
246 {
247     QMetaObject::activate(this, &staticMetaObject, 2, Q_NULLPTR);
248 }
.fi
.SS "const QList<\fBKbProfile\fP*>& Kb::profiles () const\fC [inline]\fP"

.PP
Definition at line 58 of file kb\&.h\&.
.PP
References _profiles\&.
.PP
Referenced by KbWidget::on_profileBox_activated(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::profileList_reordered(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
58 { return _profiles; }
.fi
.SS "void Kb::profiles (const QList< \fBKbProfile\fP * > &newProfiles)\fC [inline]\fP"

.PP
Definition at line 59 of file kb\&.h\&.
.PP
References _needsSave, and _profiles\&.
.PP
.nf
59 { _needsSave = true; _profiles = newProfiles; }
.fi
.SS "void Kb::readNotify (QStringline)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 489 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _hwProfile, _needsSave, _profiles, KbPerf::angleSnap(), KbLight::animKeypress(), KbProfile::append(), KbMode::bind(), KbLight::color(), KbPerf::curDpiIdx(), KbPerf::dpi(), KbPerf::DPI_COUNT, KbPerf::dpiColor(), KbPerf::dpiEnabled(), fwUpdateFinished(), fwUpdateProgress(), fwUpdPath, getKeyMap(), UsbId::guid, hwLoading, HWMODE_MAX, hwModeCount, UsbId::hwModifiedString(), hwProfile(), KbProfile::id(), KbMode::id(), KbProfile::indexOf(), isMouse(), iState, KbBind::keyEvent(), KbPerf::liftHeight(), KbMode::light(), KbProfile::modeCount(), modeRenamed(), KbProfile::modes(), UsbId::modifiedString(), KbProfile::move(), KbProfile::name(), KbMode::name(), newProfile(), notifyNumber, KbMode::perf(), profileAdded(), profileChanged(), profileRenamed(), setCurrentProfile(), KbProfile::setNeedsSave(), KbMode::setNeedsSave(), x, and y\&.
.PP
.nf
489                                {
490     QStringList components = line\&.trimmed()\&.split(" ");
491     if(components\&.count() < 2)
492         return;
493     if(components[0] == "key"){
494         // Key event
495         QString key = components[1];
496         if(key\&.length() < 2)
497             return;
498         QString keyName = key\&.mid(1);
499         bool keyPressed = (key[0] == '+');
500         KbMode* mode = _currentMode;
501         if(mode){
502             mode->light()->animKeypress(keyName, keyPressed);
503             mode->bind()->keyEvent(keyName, keyPressed);
504         }
505     } else if(components[0] == "i"){
506         // Indicator event
507         QString i = components[1];
508         if(i\&.length() < 2)
509             return;
510         QString iName = i\&.mid(1);
511         bool on = (i[0] == '+');
512         if(iName == "num")
513             iState[0] = on;
514         else if(iName == "caps")
515             iState[1] = on;
516         else if(iName == "scroll")
517             iState[2] = on;
518     } else if(components[0] == "hwprofileid"){
519         // Hardware profile ID
520         if(components\&.count() < 3)
521             return;
522         // Find the hardware profile in the list of profiles
523         QString guid = components[1];
524         QString modified = components[2];
525         KbProfile* newProfile = 0;
526         foreach(KbProfile* profile, _profiles){
527             if(profile->id()\&.guid == guid){
528                 newProfile = profile;
529                 break;
530             }
531         }
532         // If it wasn't found, create it
533         if(!newProfile){
534             newProfile = new KbProfile(this, getKeyMap(), guid, modified);
535             hwLoading[0] = true;
536             cmd\&.write(QString("@%1 get :hwprofilename\n")\&.arg(notifyNumber)\&.toLatin1());
537             cmd\&.flush();
538         } else {
539             // If it's been updated, fetch its name
540             if(newProfile->id()\&.hwModifiedString() != modified){
541                 newProfile->id()\&.modifiedString(modified);
542                 newProfile->id()\&.hwModifiedString(modified);
543                 newProfile->setNeedsSave();
544                 if(hwLoading[0]){
545                     cmd\&.write(QString("@%1 get :hwprofilename\n")\&.arg(notifyNumber)\&.toLatin1());
546                     cmd\&.flush();
547                 }
548             } else {
549                 hwLoading[0] = false;
550             }
551         }
552         hwProfile(newProfile);
553         emit profileAdded();
554         if(_hwProfile == _currentProfile)
555             emit profileChanged();
556     } else if(components[0] == "hwprofilename"){
557         // Hardware profile name
558         QString name = QUrl::fromPercentEncoding(components[1]\&.toUtf8());
559         if(!_hwProfile || !hwLoading[0])
560             return;
561         QString oldName = _hwProfile->name();
562         if(!(oldName\&.length() >= name\&.length() && oldName\&.left(name\&.length()) == name)){
563             // Don't change the name if it's a truncated version of what we already have
564             _hwProfile->name(name);
565             emit profileRenamed();
566         }
567     } else if(components[0] == "mode"){
568         // Mode-specific data
569         if(components\&.count() < 4)
570             return;
571         int mode = components[1]\&.toInt() - 1;
572         if(components[2] == "hwid"){
573             if(components\&.count() < 5 || mode >= HWMODE_MAX || !_hwProfile)
574                 return;
575             // Hardware mode ID
576             QString guid = components[3];
577             QString modified = components[4];
578             // Look for this mode in the hardware profile
579             KbMode* hwMode = 0;
580             bool isUpdated = false;
581             foreach(KbMode* kbMode, _hwProfile->modes()){
582                 if(kbMode->id()\&.guid == guid){
583                     hwMode = kbMode;
584                     if(kbMode->id()\&.hwModifiedString() != modified){
585                         // Update modification time
586                         hwMode->id()\&.modifiedString(modified);
587                         hwMode->id()\&.hwModifiedString(modified);
588                         hwMode->setNeedsSave();
589                         isUpdated = true;
590                     } else {
591                         hwLoading[mode + 1] = false;
592                     }
593                     break;
594                 }
595             }
596             // If it wasn't found, add it
597             if(!hwMode){
598                 isUpdated = true;
599                 hwMode = new KbMode(this, getKeyMap(), guid, modified);
600                 _hwProfile->append(hwMode);
601                 // If the hardware profile now contains enough modes to be added to the list, do so
602                 if(!_profiles\&.contains(_hwProfile) && _hwProfile->modeCount() >= hwModeCount){
603                     _profiles\&.append(_hwProfile);
604                     _needsSave = true;
605                     emit profileAdded();
606                     if(!_currentProfile)
607                         setCurrentProfile(_hwProfile);
608                 }
609             }
610             if(hwLoading[mode + 1] && isUpdated){
611                 // If the mode isn't in the right place, move it
612                 int index = _hwProfile->indexOf(hwMode);
613                 if(mode < _hwProfile->modeCount() && index != mode)
614                     _hwProfile->move(index, mode);
615                 // Fetch the updated data
616                 cmd\&.write(QString("@%1 mode %2 get :hwname :hwrgb")\&.arg(notifyNumber)\&.arg(mode + 1)\&.toLatin1());
617                 if(isMouse())
618                     cmd\&.write(" :hwdpi :hwdpisel :hwlift :hwsnap");
619                 cmd\&.write("\n");
620                 cmd\&.flush();
621             }
622         } else if(components[2] == "hwname"){
623             // Mode name - update list
624             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
625                 return;
626             KbMode* hwMode = _hwProfile->modes()[mode];
627             QString name = QUrl::fromPercentEncoding(components[3]\&.toUtf8());
628             QString oldName = hwMode->name();
629             if(!(oldName\&.length() >= name\&.length() && oldName\&.left(name\&.length()) == name)){
630                 // Don't change the name if it's a truncated version of what we already have
631                 hwMode->name(name);
632                 if(_hwProfile == _currentProfile)
633                     emit modeRenamed();
634             }
635         } else if(components[2] == "hwrgb"){
636             // RGB - set mode lighting
637             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
638                 return;
639             KbMode* kbmode = _hwProfile->modes()[mode];
640             KbLight* light = kbmode->light();
641             // Scan the input for colors
642             QColor lightColor = QColor();
643             for(int i = 3; i < components\&.count(); i++){
644                 QString comp = components[i];
645                 if(comp\&.indexOf(":") < 0){
646                     // No ":" - single hex constant
647                     bool ok;
648                     int rgb = comp\&.toInt(&ok, 16);
649                     if(ok)
650                         light->color(QColor::fromRgb((QRgb)rgb));
651                 } else {
652                     // List of keys ("a,b:xxxxxx")\&. Parse color first
653                     QStringList set = comp\&.split(":");
654                     bool ok;
655                     int rgb = set[1]\&.toInt(&ok, 16);
656                     if(ok){
657                         QColor color = QColor::fromRgb((QRgb)rgb);
658                         // Parse keys
659                         QStringList keys = set[0]\&.split(",");
660                         foreach(QString key, keys){
661                             if(key == "light")
662                                 // Extrapolate the Light key to the M-keys and Lock key, since those will be set to black on hwsave
663                                 lightColor = color;
664                             if(key\&.startsWith("dpi") && key\&.length() > 3){
665                                 // DPI levels go to the KbPerf object instead of KbLight
666                                 bool ok = false;
667                                 int index = key\&.mid(3)\&.toInt(&ok);
668                                 if(ok)
669                                     kbmode->perf()->dpiColor(index, color);
670                                 continue;
671                             }
672                             light->color(key, color);
673                         }
674                     }
675                 }
676             }
677             if(lightColor\&.isValid()){
678                 light->color("mr", lightColor);
679                 light->color("m1", lightColor);
680                 light->color("m2", lightColor);
681                 light->color("m3", lightColor);
682                 light->color("lock", lightColor);
683             }
684         } else if(components[2] == "hwdpi"){
685             // DPI settings
686             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
687                 return;
688             KbPerf* perf = _hwProfile->modes()[mode]->perf();
689             // Read the rest of the line as stage:x,y
690             foreach(QString comp, components\&.mid(3)){
691                 QStringList dpi = comp\&.split(':');
692                 if(dpi\&.length() != 2)
693                     continue;
694                 QStringList xy = dpi[1]\&.split(',');
695                 int x, y;
696                 bool off = false;
697                 if(xy\&.length() < 2){
698                     // If the right side only has one parameter, set both X and Y
699                     if(xy[0] == "off")
700                         off = true;
701                     else
702                         x = y = xy[0]\&.toInt();
703                 } else {
704                     x = xy[0]\&.toInt();
705                     y = xy[1]\&.toInt();
706                 }
707                 // Set DPI for this stage
708                 int index = dpi[0]\&.toInt();
709                 if(off){
710                     perf->dpiEnabled(index, false);
711                     // If all DPIs have been disabled, turn them back on
712                     bool allOff = true;
713                     for(int i = 1; i < KbPerf::DPI_COUNT; i++){
714                         if(perf->dpiEnabled(i)){
715                             allOff = false;
716                             break;
717                         }
718                     }
719                     if(allOff){
720                         for(int i = 1; i < KbPerf::DPI_COUNT; i++)
721                             perf->dpiEnabled(i, true);
722                     }
723                 } else {
724                     perf->dpiEnabled(index, true);
725                     perf->dpi(index, QPoint(x, y));
726                 }
727             }
728         } else if(components[2] == "hwdpisel"){
729             // Hardware DPI selection (0\&.\&.\&.5)
730             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
731                 return;
732             KbPerf* perf = _hwProfile->modes()[mode]->perf();
733             int idx = components[3]\&.toInt();
734             if(idx < 1)
735                 idx = 1;
736             if(idx >= KbPerf::DPI_COUNT)
737                 idx = KbPerf::DPI_COUNT - 1;
738             perf->curDpiIdx(idx);
739         } else if(components[2] == "hwlift"){
740             // Mouse lift height (1\&.\&.\&.5)
741             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
742                 return;
743             KbPerf* perf = _hwProfile->modes()[mode]->perf();
744             perf->liftHeight((KbPerf::height)components[3]\&.toInt());
745         } else if(components[3] == "hwsnap"){
746             // Mouse angle snapping ("on" or "off")
747             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
748                 return;
749             KbPerf* perf = _hwProfile->modes()[mode]->perf();
750             perf->angleSnap(components[3] == "on");
751         }
752     } else if(components[0] == "fwupdate"){
753         // Firmware update progress
754         if(components\&.count() < 3)
755             return;
756         // Make sure path is the same
757         if(components[1] != fwUpdPath)
758             return;
759         QString res = components[2];
760         if(res == "invalid" || res == "fail")
761             emit fwUpdateFinished(false);
762         else if(res == "ok")
763             emit fwUpdateFinished(true);
764         else {
765             // "xx/yy" indicates progress
766             if(!res\&.contains("/"))
767                 return;
768             QStringList numbers = res\&.split("/");
769             emit fwUpdateProgress(numbers[0]\&.toInt(), numbers[1]\&.toInt());
770         }
771     }
772 }
.fi
.SS "void Kb::run ()\fC [private]\fP"

.PP
Definition at line 464 of file kb\&.cpp\&.
.PP
References notifyPath, notifyPathMutex, and notifyPaths\&.
.PP
.nf
464             {
465     QFile notify(notifyPath);
466     // Wait a small amount of time for the node to open (100ms)
467     QThread::usleep(100000);
468     if(!notify\&.open(QIODevice::ReadOnly)){
469         // If it's still not open, try again before giving up (1s at a time, 10s total)
470         QThread::usleep(900000);
471         for(int i = 1; i < 10; i++){
472             if(notify\&.open(QIODevice::ReadOnly))
473                 break;
474             QThread::sleep(1);
475         }
476         if(!notify\&.isOpen())
477             return;
478     }
479     // Read data from notification node
480     QByteArray line;
481     while(notify\&.isOpen() && (line = notify\&.readLine())\&.length() > 0){
482         QString text = QString::fromUtf8(line);
483         metaObject()->invokeMethod(this, "readNotify", Qt::QueuedConnection, Q_ARG(QString, text));
484     }
485     QMutexLocker locker(&notifyPathMutex);
486     notifyPaths\&.remove(notifyPath);
487 }
.fi
.SS "void Kb::save ()"

.PP
Definition at line 291 of file kb\&.cpp\&.
.PP
References _currentProfile, _needsSave, _profiles, UsbId::guidString(), KbProfile::id(), prefsPath, KbProfile::save(), and CkbSettings::setValue()\&.
.PP
Referenced by autoSave(), KbWidget::on_hwSaveButton_clicked(), KbManager::scanKeyboards(), and ~Kb()\&.
.PP
.nf
291              {
292     if(prefsPath\&.isEmpty())
293         return;
294     _needsSave = false;
295     CkbSettings settings(prefsPath, true);
296     QString guids, currentGuid;
297     foreach(KbProfile* profile, _profiles){
298         guids\&.append(" " + profile->id()\&.guidString());
299         if(profile == _currentProfile)
300             currentGuid = profile->id()\&.guidString();
301         profile->save(settings);
302     }
303     settings\&.setValue("CurrentProfile", currentGuid);
304     settings\&.setValue("Profiles", guids\&.trimmed());
305 }
.fi
.SS "static int Kb::scrollSpeed ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 42 of file kb\&.h\&.
.PP
References _scrollSpeed\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), ExtraSettingsWidget::on_sAccelBox_clicked(), and ExtraSettingsWidget::on_sSpeedBox_valueChanged()\&.
.PP
.nf
42 { return _scrollSpeed; }
.fi
.SS "void Kb::scrollSpeed (intnewSpeed)\fC [static]\fP"

.PP
Definition at line 246 of file kb\&.cpp\&.
.PP
References _scrollSpeed, activeDevices, and cmd\&.
.PP
.nf
246                                 {
247     if(newSpeed == _scrollSpeed)
248         return;
249     _scrollSpeed = newSpeed;
250 #ifdef Q_OS_MACX
251     // Update all devices
252     foreach(Kb* kb, activeDevices){
253         kb->cmd\&.write(QString("scrollspeed %1\n")\&.arg(newSpeed)\&.toLatin1());
254         kb->cmd\&.flush();
255     }
256 #endif
257 }
.fi
.SS "void Kb::setCurrentMode (\fBKbProfile\fP *profile, \fBKbMode\fP *mode, boolspontaneous = \fCtrue\fP)"

.PP
Definition at line 787 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _needsSave, KbProfile::currentMode(), modeChanged(), and profileChanged()\&.
.PP
Referenced by KeyAction::keyEvent(), KbWidget::on_modesList_currentItemChanged(), KbWidget::on_modesList_customContextMenuRequested(), KbWidget::on_modesList_itemClicked(), and setCurrentProfile()\&.
.PP
.nf
787                                                                          {
788     if(_currentProfile != profile){
789         _currentProfile = profile;
790         _needsSave = true;
791         emit profileChanged();
792     }
793     if(_currentMode != mode || _currentProfile->currentMode() != mode){
794         _currentProfile->currentMode(_currentMode = mode);
795         _needsSave = true;
796         emit modeChanged(spontaneous);
797     }
798 }
.fi
.SS "void Kb::setCurrentMode (\fBKbProfile\fP *profile, intindex, boolspontaneous = \fCtrue\fP)\fC [inline]\fP"

.PP
Definition at line 73 of file kb\&.h\&.
.PP
References KbProfile::modes(), and setCurrentMode()\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
73 { setCurrentMode(profile, profile->modes()[index], spontaneous); }
.fi
.SS "void Kb::setCurrentMode (\fBKbMode\fP *mode, boolspontaneous = \fCtrue\fP)\fC [inline]\fP"

.PP
Definition at line 74 of file kb\&.h\&.
.PP
References _currentProfile, and setCurrentMode()\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
74 { setCurrentMode(_currentProfile, mode, spontaneous); }
.fi
.SS "void Kb::setCurrentProfile (\fBKbProfile\fP *profile, boolspontaneous = \fCtrue\fP)"

.PP
Definition at line 778 of file kb\&.cpp\&.
.PP
References KbProfile::append(), KbProfile::currentMode(), getKeyMap(), hwModeCount, KbProfile::modeCount(), KbProfile::modes(), and setCurrentMode()\&.
.PP
Referenced by load(), KbWidget::on_profileBox_activated(), KbProfileDialog::on_profileList_currentItemChanged(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemClicked(), and readNotify()\&.
.PP
.nf
778                                                               {
779     while(profile->modeCount() < hwModeCount)
780         profile->append(new KbMode(this, getKeyMap()));
781     KbMode* mode = profile->currentMode();
782     if(!mode)
783         profile->currentMode(mode = profile->modes()\&.first());
784     setCurrentMode(profile, mode, spontaneous);
785 }
.fi
.SS "void Kb::updateLayout ()\fC [private]\fP"

.PP
Definition at line 204 of file kb\&.cpp\&.
.PP
References _currentProfile, _hwProfile, _layout, _profiles, KbLight::close(), getKeyMap(), infoUpdated(), KeyMap::isISO(), KbProfile::keyMap(), KbMode::light(), and KbProfile::modes()\&.
.PP
Referenced by layout()\&.
.PP
.nf
204                      {
205 #ifdef Q_OS_MACX
206     // Write ANSI/ISO flag to daemon (OSX only)
207     cmd\&.write("layout ");
208     cmd\&.write(KeyMap::isISO(_layout) ? "iso" : "ansi");
209     cmd\&.write("\n");
210     cmd\&.flush();
211 #endif
212     foreach(KbProfile* profile, _profiles)
213         profile->keyMap(getKeyMap());
214     if(_hwProfile && !_profiles\&.contains(_hwProfile))
215         _hwProfile->keyMap(getKeyMap());
216     // Stop all animations as they'll need to be restarted
217     foreach(KbMode* mode, _currentProfile->modes())
218         mode->light()->close();
219     emit infoUpdated();
220 }
.fi
.SS "void Kb::writeProfileHeader ()\fC [private]\fP"

.PP
Definition at line 372 of file kb\&.cpp\&.
.PP
References _currentProfile, UsbId::guidString(), KbProfile::id(), UsbId::modifiedString(), and KbProfile::name()\&.
.PP
Referenced by frameUpdate(), and hwSave()\&.
.PP
.nf
372                            {
373     cmd\&.write("eraseprofile");
374     // Write the profile name and ID
375     cmd\&.write(" profilename ");
376     cmd\&.write(QUrl::toPercentEncoding(_currentProfile->name()));
377     cmd\&.write(" profileid ");
378     cmd\&.write(_currentProfile->id()\&.guidString()\&.toLatin1());
379     cmd\&.write(" ");
380     cmd\&.write(_currentProfile->id()\&.modifiedString()\&.toLatin1());
381 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBKbManager\fP\fC [friend]\fP"

.PP
Definition at line 142 of file kb\&.h\&.
.SH "Field Documentation"
.PP 
.SS "\fBKbMode\fP* Kb::_currentMode\fC [private]\fP"

.PP
Definition at line 173 of file kb\&.h\&.
.PP
Referenced by currentBind(), currentLight(), currentMode(), currentPerf(), frameUpdate(), hwSave(), readNotify(), and setCurrentMode()\&.
.SS "\fBKbProfile\fP* Kb::_currentProfile\fC [private]\fP"

.PP
Definition at line 171 of file kb\&.h\&.
.PP
Referenced by currentProfile(), frameUpdate(), hwSave(), readNotify(), save(), setCurrentMode(), updateLayout(), and writeProfileHeader()\&.
.SS "bool Kb::_delay = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 204 of file kb\&.h\&.
.PP
Referenced by Kb(), and macroDelay()\&.
.SS "bool Kb::_dither = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 169 of file kb\&.h\&.
.PP
Referenced by dither(), and Kb()\&.
.SS "int Kb::_frameRate = 30\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 168 of file kb\&.h\&.
.PP
Referenced by frameRate(), and Kb()\&.
.SS "\fBKbProfile\fP* Kb::_hwProfile\fC [private]\fP"

.PP
Definition at line 187 of file kb\&.h\&.
.PP
Referenced by deleteHw(), hwProfile(), hwSave(), readNotify(), and updateLayout()\&.
.SS "\fBKeyMap::Layout\fP Kb::_layout = \fBKeyMap::NO_LAYOUT\fP\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 165 of file kb\&.h\&.
.PP
Referenced by getKeyMap(), Kb(), layout(), and updateLayout()\&.
.SS "\fBKeyMap::Model\fP Kb::_model\fC [private]\fP"

.PP
Definition at line 175 of file kb\&.h\&.
.PP
Referenced by model()\&.
.SS "bool Kb::_mouseAccel = true\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 169 of file kb\&.h\&.
.PP
Referenced by Kb(), and mouseAccel()\&.
.SS "bool Kb::_needsSave\fC [private]\fP"

.PP
Definition at line 207 of file kb\&.h\&.
.PP
Referenced by appendProfile(), load(), needsSave(), profiles(), readNotify(), save(), and setCurrentMode()\&.
.SS "QList<\fBKbProfile\fP*> Kb::_profiles\fC [private]\fP"

.PP
Definition at line 172 of file kb\&.h\&.
.PP
Referenced by appendProfile(), find(), indexOf(), load(), needsSave(), profiles(), readNotify(), save(), and updateLayout()\&.
.SS "int Kb::_scrollSpeed = 0\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 168 of file kb\&.h\&.
.PP
Referenced by Kb(), and scrollSpeed()\&.
.SS "QFile Kb::cmd\fC [private]\fP"

.PP
Definition at line 195 of file kb\&.h\&.
.PP
Referenced by dither(), frameRate(), macroDelay(), mouseAccel(), and scrollSpeed()\&.
.SS "QString Kb::cmdpath\fC [private]\fP"

.PP
Definition at line 154 of file kb\&.h\&.
.PP
Referenced by Kb()\&.
.SS "QString Kb::devpath\fC [private]\fP"

.PP
Definition at line 154 of file kb\&.h\&.
.PP
Referenced by matches()\&.
.SS "QString Kb::features"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by MainWindow::checkFwUpdates(), FwUpgradeDialog::exec(), Kb(), KbWidget::KbWidget(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.SS "QString Kb::firmware"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by MainWindow::checkFwUpdates(), KbWidget::devUpdate(), FwUpgradeDialog::FwUpgradeDialog(), Kb(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.SS "QString Kb::fwUpdPath\fC [private]\fP"

.PP
Definition at line 185 of file kb\&.h\&.
.PP
Referenced by fwUpdate(), and readNotify()\&.
.SS "bool Kb::hwLoading[\fBHWMODE_MAX\fP+1]\fC [private]\fP"

.PP
Definition at line 211 of file kb\&.h\&.
.PP
Referenced by Kb(), and readNotify()\&.
.SS "const int Kb::HWMODE_MAX = 3\fC [static]\fP"

.PP
Definition at line 50 of file kb\&.h\&.
.PP
Referenced by KbPerf::applyIndicators(), and readNotify()\&.
.SS "int Kb::hwModeCount"

.PP
Definition at line 49 of file kb\&.h\&.
.PP
Referenced by hwSave(), Kb(), KbWidget::modeIcon(), KbWidget::on_modesList_customContextMenuRequested(), readNotify(), and setCurrentProfile()\&.
.SS "bool Kb::iState[\fBKbPerf::HW_I_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 178 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), Kb(), and readNotify()\&.
.SS "quint64 Kb::lastAutoSave\fC [private]\fP"

.PP
Definition at line 182 of file kb\&.h\&.
.PP
Referenced by autoSave()\&.
.SS "int Kb::macroNumber = -1\fC [static]\fP, \fC [private]\fP"

.PP
.RS 4
is invalid entry\&. 
.RE
.PP

.PP
Definition at line 202 of file kb\&.h\&.
.PP
Referenced by getMacroNumber(), and Kb()\&.
.SS "QString Kb::macroPath = ''\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 158 of file kb\&.h\&.
.PP
Referenced by getMacroPath(), Kb(), and ~Kb()\&.
.SS "bool Kb::monochrome"

.PP
Definition at line 19 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), hwSave(), Kb(), and KbWidget::KbWidget()\&.
.SS "int Kb::notifyNumber\fC [private]\fP"

.PP
Definition at line 198 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), fwUpdate(), Kb(), readNotify(), and ~Kb()\&.
.SS "QString Kb::notifyPath\fC [private]\fP"

.PP
Definition at line 154 of file kb\&.h\&.
.PP
Referenced by Kb(), and run()\&.
.SS "QString Kb::pollrate"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by KbWidget::devUpdate(), and Kb()\&.
.SS "QString Kb::prefsPath\fC [private]\fP"

.PP
Definition at line 181 of file kb\&.h\&.
.PP
Referenced by Kb(), load(), and save()\&.
.SS "\fBKbMode\fP* Kb::prevMode\fC [private]\fP"

.PP
Definition at line 190 of file kb\&.h\&.
.PP
Referenced by deletePrevious(), frameUpdate(), and hwSave()\&.
.SS "\fBKbProfile\fP* Kb::prevProfile\fC [private]\fP"

.PP
Definition at line 189 of file kb\&.h\&.
.PP
Referenced by frameUpdate()\&.
.SS "QString Kb::usbModel"

.PP
Definition at line 16 of file kb\&.h\&.
.PP
Referenced by FwUpgradeDialog::FwUpgradeDialog(), Kb(), KbWidget::name(), and MainWindow::showFwUpdateNotification()\&.
.SS "QString Kb::usbSerial"

.PP
Definition at line 16 of file kb\&.h\&.
.PP
Referenced by KbWidget::devUpdate(), Kb(), and matches()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
