.TH "Kb" 3 "Sat May 27 2017" "Version v0.2.8 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Kb \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kb\&.h>\fP
.PP
Inherits \fBQThread\fP\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "void \fBframeUpdate\fP ()"
.br
.ti -1c
.RI "void \fBautoSave\fP ()"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBinfoUpdated\fP ()"
.br
.ti -1c
.RI "void \fBprofileAdded\fP ()"
.br
.ti -1c
.RI "void \fBprofileRenamed\fP ()"
.br
.ti -1c
.RI "void \fBmodeRenamed\fP ()"
.br
.ti -1c
.RI "void \fBprofileChanged\fP ()"
.br
.ti -1c
.RI "void \fBmodeChanged\fP (bool spontaneous)"
.br
.ti -1c
.RI "void \fBfwUpdateProgress\fP (int \fBcurrent\fP, int total)"
.br
.ti -1c
.RI "void \fBfwUpdateFinished\fP (bool succeeded)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyMap::Model\fP \fBmodel\fP () const "
.br
.ti -1c
.RI "bool \fBisKeyboard\fP () const "
.br
.ti -1c
.RI "bool \fBisMouse\fP () const "
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBhwProfile\fP ()"
.br
.ti -1c
.RI "void \fBhwProfile\fP (\fBKbProfile\fP *newHwProfile)"
.br
.ti -1c
.RI "void \fBfwUpdate\fP (const QString &path)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBcurrentProfile\fP ()"
.br
.ti -1c
.RI "const QList< \fBKbProfile\fP * > & \fBprofiles\fP () const "
.br
.ti -1c
.RI "void \fBprofiles\fP (const QList< \fBKbProfile\fP * > &newProfiles)"
.br
.ti -1c
.RI "void \fBappendProfile\fP (\fBKbProfile\fP *\fBnewProfile\fP)"
.br
.ti -1c
.RI "int \fBindexOf\fP (\fBKbProfile\fP *profile)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBfind\fP (const QUuid &id)"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBcurrentMode\fP ()"
.br
.ti -1c
.RI "\fBKbLight\fP * \fBcurrentLight\fP ()"
.br
.ti -1c
.RI "\fBKbBind\fP * \fBcurrentBind\fP ()"
.br
.ti -1c
.RI "\fBKbPerf\fP * \fBcurrentPerf\fP ()"
.br
.ti -1c
.RI "void \fBsetCurrentProfile\fP (\fBKbProfile\fP *profile, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbProfile\fP *profile, \fBKbMode\fP *mode, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbProfile\fP *profile, int index, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbMode\fP *mode, bool spontaneous=true)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBnewProfile\fP ()"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBnewProfile\fP (\fBKbProfile\fP *other)"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBnewMode\fP ()"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBnewMode\fP (\fBKbMode\fP *other)"
.br
.ti -1c
.RI "void \fBload\fP ()"
.br
.ti -1c
.RI "void \fBsave\fP ()"
.br
.ti -1c
.RI "bool \fBneedsSave\fP () const "
.br
.ti -1c
.RI "void \fBhwSave\fP ()"
.br
.ti -1c
.RI "int \fBgetMacroNumber\fP ()"
.br
.RI "\fIFor usage with macro definions, these two params must only be readable\&. So there are no setters\&. \fP"
.ti -1c
.RI "QString \fBgetMacroPath\fP ()"
.br
.RI "\fIgetMacroPath returns the macroPath (e\&.g\&. /dev/input/ckb1/notify), which we have saved in the constructor\&. For usage with macro definions, this param must only be readable\&. So there is no setter\&. \fP"
.ti -1c
.RI "\fB~Kb\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBframeRate\fP ()"
.br
.ti -1c
.RI "static void \fBframeRate\fP (int newFrameRate)"
.br
.ti -1c
.RI "static \fBKeyMap::Layout\fP \fBlayout\fP ()"
.br
.ti -1c
.RI "static void \fBlayout\fP (\fBKeyMap::Layout\fP newLayout)"
.br
.ti -1c
.RI "static bool \fBdither\fP ()"
.br
.ti -1c
.RI "static void \fBdither\fP (bool newDither)"
.br
.ti -1c
.RI "static bool \fBmacroDelay\fP ()"
.br
.ti -1c
.RI "static void \fBmacroDelay\fP (bool flag)"
.br
.RI "\fI\fBKb::macroDelay\fP handles the UI-Element macroBox\&. Sends a command to the keyboard to switch on or off the delay function on very large macros\&. \fP"
.ti -1c
.RI "static bool \fBmouseAccel\fP ()"
.br
.ti -1c
.RI "static void \fBmouseAccel\fP (bool newAccel)"
.br
.ti -1c
.RI "static int \fBscrollSpeed\fP ()"
.br
.ti -1c
.RI "static void \fBscrollSpeed\fP (int newSpeed)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "QString \fBusbModel\fP"
.br
.ti -1c
.RI "QString \fBusbSerial\fP"
.br
.ti -1c
.RI "QString \fBfeatures\fP"
.br
.ti -1c
.RI "QString \fBfirmware\fP"
.br
.ti -1c
.RI "QString \fBpollrate\fP"
.br
.ti -1c
.RI "bool \fBmonochrome\fP"
.br
.ti -1c
.RI "int \fBhwModeCount\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBHWMODE_MAX\fP = 3"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBreadNotify\fP (QString line)"
.br
.ti -1c
.RI "void \fBdeleteHw\fP ()"
.br
.ti -1c
.RI "void \fBdeletePrevious\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKb\fP (\fBQObject\fP *parent, const QString &path)"
.br
.RI "\fI
.PP
.RS 4
is invalid also\&. 
.RE
.PP
\fP"
.ti -1c
.RI "bool \fBisOpen\fP () const "
.br
.ti -1c
.RI "bool \fBmatches\fP (const QString &path, const QString &serial)"
.br
.ti -1c
.RI "void \fBupdateLayout\fP ()"
.br
.ti -1c
.RI "void \fBwriteProfileHeader\fP ()"
.br
.ti -1c
.RI "\fBKeyMap\fP \fBgetKeyMap\fP ()"
.br
.ti -1c
.RI "void \fBrun\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QString \fBdevpath\fP"
.br
.RI "\fIpathVars devpath is the device root path (e\&.g\&. /dev/device/ckb1), cmdpath leads to the daemon input pipe for daemon commands, notifyPath is the standard input monitor for general purpose\&. \fP"
.ti -1c
.RI "QString \fBcmdpath\fP"
.br
.ti -1c
.RI "QString \fBnotifyPath\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fB_currentProfile\fP"
.br
.ti -1c
.RI "QList< \fBKbProfile\fP * > \fB_profiles\fP"
.br
.ti -1c
.RI "\fBKbMode\fP * \fB_currentMode\fP"
.br
.ti -1c
.RI "\fBKeyMap::Model\fP \fB_model\fP"
.br
.ti -1c
.RI "bool \fBiState\fP [\fBKbPerf::HW_I_COUNT\fP]"
.br
.ti -1c
.RI "QString \fBprefsPath\fP"
.br
.ti -1c
.RI "quint64 \fBlastAutoSave\fP"
.br
.ti -1c
.RI "QString \fBfwUpdPath\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fB_hwProfile\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBprevProfile\fP"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBprevMode\fP"
.br
.ti -1c
.RI "QFile \fBcmd\fP"
.br
.ti -1c
.RI "int \fBnotifyNumber\fP"
.br
.RI "\fInotifyNumber is the trailing number in the device path\&. \fP"
.ti -1c
.RI "bool \fB_needsSave\fP"
.br
.ti -1c
.RI "bool \fBhwLoading\fP [\fBHWMODE_MAX\fP+1]"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static QString \fBmacroPath\fP = ''"
.br
.RI "\fImacroPath added for a second thread to read macro input\&. Must be static, because there is only one keyboard but multiple devices\&. \fP"
.ti -1c
.RI "static \fBKeyMap::Layout\fP \fB_layout\fP = \fBKeyMap::NO_LAYOUT\fP"
.br
.ti -1c
.RI "static int \fB_frameRate\fP = 30"
.br
.ti -1c
.RI "static int \fB_scrollSpeed\fP = 0"
.br
.ti -1c
.RI "static bool \fB_dither\fP = false"
.br
.ti -1c
.RI "static bool \fB_mouseAccel\fP = true"
.br
.ti -1c
.RI "static int \fBmacroNumber\fP = -1"
.br
.RI "\fIMacro Number to notify macro definition events\&. As macroPath, macroNumber must be static, because only keyboard may set this value and others (eg mice) needs to read it\&. \fP"
.ti -1c
.RI "static bool \fB_delay\fP = false"
.br
.RI "\fIflag if macro delay hast to be switched on \fP"
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBKbManager\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 11 of file kb\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Kb::~Kb ()"
<
.PP
\fBTodo\fP
.RS 4
I don't think, that notifypaths is used somewhere\&. So why do we have it? If we do not need it, searching for an ununsed notify channel can easy be refactored to a private member function\&. 
.RE
.PP

.PP
Definition at line 192 of file kb\&.cpp\&.
.PP
References activeDevices, isOpen(), macroPath, notifyNumber, notifyPaths, and save()\&.
.PP
.nf
192        {
193     // Save settings first
194     save();
195 
196     // remove the notify channel from the list of notifyPaths\&.
199     notifyPaths\&.remove(macroPath);
200 
201     // Kill notification thread and remove node
202     activeDevices\&.remove(this);
203     if(!isOpen()){
204         terminate();
205         wait(1000);
206         return;
207     }
208     if(notifyNumber > 0)
209         cmd\&.write(QString("idle\nnotifyoff %1\n")\&.arg(notifyNumber)\&.toLatin1());
210     cmd\&.flush();
211     terminate();
212     wait(1000);
213     cmd\&.close();
214 }
.fi
.SS "Kb::Kb (\fBQObject\fP *parent, const QString &path)\fC [private]\fP"
< Firmware Info is now current fw-number:vendor:model Look for special entries (newest models)
.PP
< perhaps we have found something, perhaps not\&.
.PP
< If nothing found in the special firmware search, try here\&.
.PP
Last chance gone to get a valid firmware information\&.
.PP
Handle inputs
.PP
< This is the normal case if we have a new daemon and a running device
.PP
< That means we have an older daemon which does not write three infos into the file
.PP
Open cmd in non-blocking mode so that it doesn't lock up if nothing is reading (e\&.g\&. if the daemon crashed and didn't clean up the node)
.PP
Find an available notification node (if none is found, take notify1)
.PP
Again, find an available notification node for macro definition if we handle a keyboard\&. (if none is found, take notify2)
.PP
.RS 4
Block ist used to have QMutexLocker as an auto var\&. 
.RE
.PP
.PP
<
.PP
\fBTodo\fP
.RS 4
Is adding notifyX to the notifypaths neccessary? 
.RE
.PP

.PP
Definition at line 23 of file kb\&.cpp\&.
.PP
References _delay, _dither, _frameRate, _layout, _model, _mouseAccel, _scrollSpeed, activeDevices, cmdpath, features, firmware, KeyMap::getModel(), hwLoading, hwModeCount, infoUpdated(), KeyMap::isISO(), isKeyboard(), iState, KeyMap::K95, macroNumber, macroPath, monochrome, KeyMap::NO_MODEL, notifyNumber, notifyPath, notifyPathMutex, notifyPaths, pollrate, prefsPath, usbModel, and usbSerial\&.
.PP
.nf
23                                            :
24     QThread(parent), features("N/A"), firmware("N/A"), pollrate("N/A"), monochrome(false),
25     devpath(path), cmdpath(path + "/cmd"), notifyPath(path + "/notify1"),
26     _currentProfile(0), _currentMode(0), _model(KeyMap::NO_MODEL),
27     lastAutoSave(QDateTime::currentMSecsSinceEpoch()),
28     _hwProfile(0), prevProfile(0), prevMode(0),
29     cmd(cmdpath), notifyNumber(1), _needsSave(false)
30 {
31     memset(iState, 0, sizeof(iState));
32     memset(hwLoading, 0, sizeof(hwLoading));
33 
34     // Get the features, model, serial number, FW version (if available), and poll rate (if available) from /dev nodes
35     QFile ftpath(path + "/features"), mpath(path + "/model"), spath(path + "/serial"), fwpath(path + "/fwversion"), ppath(path + "/pollrate");
36     if(fwpath\&.open(QIODevice::ReadOnly)){
37         QString fwString = fwpath\&.read(1000);
38         fwString = fwString\&.trimmed();
39         fwpath\&.close();
40         QStringList list = fwString\&.split(":");
41         if(list\&.length() == 3) {    
42             bool okVendor, okProduct;
44             const uint vendor = list[1]\&.toUInt(&okVendor, 16);
45             const uint product = list[2]\&.toUInt(&okProduct, 16);
46             if (okVendor && okProduct) _model = KeyMap::getModel(vendor, product);    
47             qInfo() << "first look for special firmware returned" << _model;
48         } else qWarning() << "Expected 3 entries in file" << fwpath\&.fileName() << "but reading" << list\&.length();
49     }
50     if(ftpath\&.open(QIODevice::ReadOnly)){
51         features = ftpath\&.read(1000);
52         features = features\&.trimmed();
53         ftpath\&.close();
54         // Read model from features (first word: vendor, second word: product)
55         QStringList list = features\&.split(" ");
56         if(list\&.length() < 2) {
57             qDebug() << "Kb::Kb() Error in reading features, read" << list\&.length() << "entries, 2 expected\&.";
58             return;
59         }
60         if (_model == KeyMap::NO_MODEL) {   
61             _model = KeyMap::getModel(list[1]);
62         }
64         if (_model == KeyMap::NO_MODEL) {
65             qCritical() << "Neither firmware-special-search nor feature file analysis resulted in valid firmware information\&.";
66             return;
67         }
68     } else
69         // Bail if features aren't readable
70         return;
71     if(features\&.contains("monochrome"))
72         monochrome = true;
73     if(mpath\&.open(QIODevice::ReadOnly)){
74         usbModel = mpath\&.read(100);
75         usbModel = usbModel\&.remove("Corsair")\&.remove("Gaming")\&.remove("Keyboard")\&.remove("Mouse")\&.remove("Bootloader")\&.trimmed();
76         mpath\&.close();
77     }
78     if(usbModel == "")
79         usbModel = "Keyboard";
80     if(spath\&.open(QIODevice::ReadOnly)){
81         usbSerial = spath\&.read(100);
82         usbSerial = usbSerial\&.trimmed()\&.toUpper();
83         spath\&.close();
84     }
85     if(usbSerial == "")
86         usbSerial = "Unknown-" + usbModel;
87     if(features\&.contains("fwversion") && fwpath\&.open(QIODevice::ReadOnly)){
88         QString firmwareString = fwpath\&.read(100);
89         fwpath\&.close();
90 
92         QStringList firmwareList = firmwareString\&.remove("\n")\&.split(":");
93         switch (firmwareList\&.length()) {
94         case 3: 
95             qInfo() << "Reading 3 entries from fwversion file, VID=" << firmwareList\&.at(1) << ", PID=" << firmwareList\&.at(2);
96         case 1: 
97             firmware = QString::number(firmwareList\&.at(0)\&.trimmed()\&.toInt() / 100\&., 'f', 2);
98             qInfo() << "Firmware version read from ckb-daemon in fwversion file is" << firmwareList\&.at(0);
99             break;
100         default:
101             qCritical() << "Firware version file is invalid\&. Number of entries is" << firmwareList\&.length();
102             break;
103         }
104     }
105     if(features\&.contains("pollrate") && ppath\&.open(QIODevice::ReadOnly)){
106         pollrate = ppath\&.read(100);
107         pollrate = pollrate\&.trimmed();
108         ppath\&.close();
109     }
110     prefsPath = "Devices/" + usbSerial;
111     qDebug() << "Features =" << features;
112 
113     hwModeCount = (_model == KeyMap::K95) ? 3 : 1;
116     int fd = open(cmdpath\&.toLatin1()\&.constData(), O_WRONLY | O_NONBLOCK);
117     if(!cmd\&.open(fd, QIODevice::WriteOnly, QFileDevice::AutoCloseHandle))
118         return;
119 
121     {
122         QMutexLocker locker(&notifyPathMutex);
123         for (int i = 1; i < 10; i++) {
124             QString notify = QString(path + "/notify%1")\&.arg(i);
125             if(!QFile::exists(notify) && !notifyPaths\&.contains(notify)){
126                 notifyNumber = i;
127                 notifyPath = notify;
128                 break;
129             }
130         }
131         notifyPaths\&.insert(notifyPath);
132     }
133     cmd\&.write(QString("notifyon %1\n")\&.arg(notifyNumber)\&.toLatin1());
134     cmd\&.flush();
135 
138     if (isKeyboard()) {
139         qDebug() << "Keyboard detected, setting macroPath and macroNumber";
140         if (macroPath != "") {
141             qDebug() << "Warning: Redefinition of macroPath\&. Value was" << macroPath;
142         }
143         {   
144             QMutexLocker locker(&notifyPathMutex);
145             int i;
146             for (i = 1; i < 10; i++) {
147                 QString notify = QString(path + "/notify%1")\&.arg(i);
148                 if(!QFile::exists(notify) && !notifyPaths\&.contains(notify)){
149                     macroNumber = i;
150                     break;
151                 }
152             }
153             if (i == 10) {
154                 macroNumber = 2;
155             }
156             macroPath = path;
157             notifyPaths\&.insert(QString(macroPath + "/notify%1")\&.arg(macroNumber)); 
158             qDebug() << "new macroPath =" << macroPath << "and macroNumber =" << macroNumber;
159         }
160     } else {
161         qDebug() << "No Keyboard detected, leaving macroPath as is:" << macroPath << "and macroNumber as" << macroNumber;
162     }
163     // Activate device, apply settings, and ask for hardware profile
164     cmd\&.write(QString("fps %1\n")\&.arg(_frameRate)\&.toLatin1());
165     cmd\&.write(QString("dither %1\n")\&.arg(static_cast<int>(_dither))\&.toLatin1());
166     cmd\&.write(QString("\ndelay %1\n")\&.arg(_delay? "on" : "off")\&.toLatin1());
167 #ifdef Q_OS_MACX
168     // Write ANSI/ISO flag to daemon (OSX only)
169     cmd\&.write("layout ");
170     cmd\&.write(KeyMap::isISO(_layout) ? "iso" : "ansi");
171     // Also OSX only: scroll speed and mouse acceleration
172     cmd\&.write(QString("accel %1\n")\&.arg(QString(_mouseAccel ? "on" : "off"))\&.toLatin1());
173     cmd\&.write(QString("scrollspeed %1\n")\&.arg(_scrollSpeed)\&.toLatin1());
174 #endif
175     cmd\&.write(QString("\nactive\n@%1 get :hwprofileid")\&.arg(notifyNumber)\&.toLatin1());
176     hwLoading[0] = true;
177     for(int i = 0; i < hwModeCount; i++){
178         cmd\&.write(QString(" mode %1 get :hwid")\&.arg(i + 1)\&.toLatin1());
179         hwLoading[i + 1] = true;
180     }
181     // Ask for current indicator and key state
182     cmd\&.write(" get :i :keys\n");
183     cmd\&.flush();
184 
185     emit infoUpdated();
186     activeDevices\&.insert(this);
187 
188     // Start a separate thread to read from the notification node
189     start();
190 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Kb::appendProfile (\fBKbProfile\fP *newProfile)\fC [inline]\fP"

.PP
Definition at line 60 of file kb\&.h\&.
.PP
References _needsSave, and _profiles\&.
.PP
Referenced by KbProfileDialog::on_profileList_itemClicked()\&.
.PP
.nf
60 { _needsSave = true; _profiles\&.append(newProfile); }
.fi
.SS "void Kb::autoSave ()\fC [slot]\fP"

.PP
Definition at line 340 of file kb\&.cpp\&.
.PP
References CkbSettings::isBusy(), lastAutoSave, needsSave(), and save()\&.
.PP
.nf
340                  {
341     quint64 now = QDateTime::currentMSecsSinceEpoch();
342     if(needsSave() && now >= lastAutoSave + 15 * 1000 && !CkbSettings::isBusy()){
343         save();
344         lastAutoSave = now;
345     }
346 }
.fi
.SS "\fBKbBind\fP* Kb::currentBind ()\fC [inline]\fP"

.PP
Definition at line 67 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::bind()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
67 { return !_currentMode ? 0 : _currentMode->bind(); }
.fi
.SS "\fBKbLight\fP* Kb::currentLight ()\fC [inline]\fP"

.PP
Definition at line 66 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::light()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
66 { return !_currentMode ? 0 : _currentMode->light(); }
.fi
.SS "\fBKbMode\fP* Kb::currentMode ()\fC [inline]\fP"

.PP
Definition at line 65 of file kb\&.h\&.
.PP
References _currentMode\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
65 { return _currentMode; }
.fi
.SS "\fBKbPerf\fP* Kb::currentPerf ()\fC [inline]\fP"

.PP
Definition at line 68 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::perf()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
68 { return !_currentMode ? 0 : _currentMode->perf(); }
.fi
.SS "\fBKbProfile\fP* Kb::currentProfile ()\fC [inline]\fP"

.PP
Definition at line 56 of file kb\&.h\&.
.PP
References _currentProfile\&.
.PP
Referenced by KeyAction::keyEvent(), KbWidget::modeChanged(), KbWidget::modeIcon(), KbWidget::modesList_reordered(), KbWidget::on_modesList_currentItemChanged(), KbWidget::on_modesList_customContextMenuRequested(), KbWidget::on_modesList_itemClicked(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemChanged(), KbWidget::profileChanged(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
56 { return _currentProfile; }
.fi
.SS "void Kb::deleteHw ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 492 of file kb\&.cpp\&.
.PP
References _hwProfile\&.
.PP
Referenced by hwProfile()\&.
.PP
.nf
492                  {
493     disconnect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
494     _hwProfile = 0;
495 }
.fi
.SS "void Kb::deletePrevious ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 477 of file kb\&.cpp\&.
.PP
References prevMode\&.
.PP
Referenced by frameUpdate(), and hwSave()\&.
.PP
.nf
477                        {
478     disconnect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
479     prevMode = 0;
480 }
.fi
.SS "static bool Kb::dither ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 33 of file kb\&.h\&.
.PP
References _dither\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_ditherBox_clicked()\&.
.PP
.nf
33 { return _dither; }
.fi
.SS "void Kb::dither (boolnewDither)\fC [static]\fP"

.PP
Definition at line 255 of file kb\&.cpp\&.
.PP
References _dither, activeDevices, and cmd\&.
.PP
.nf
255                              {
256     if(newDither == _dither)
257         return;
258     _dither = newDither;
259     // Update all devices
260     foreach(Kb* kb, activeDevices){
261         kb->cmd\&.write(QString("dither %1\n")\&.arg(static_cast<int>(newDither))\&.toLatin1());
262         kb->cmd\&.flush();
263     }
264 }
.fi
.SS "\fBKbProfile\fP* Kb::find (const QUuid &id)\fC [inline]\fP"

.PP
Definition at line 62 of file kb\&.h\&.
.PP
References _profiles, UsbId::guid, and KbProfile::id()\&.
.PP
Referenced by KbProfileDialog::on_profileList_currentItemChanged(), KbProfileDialog::on_profileList_customContextMenuRequested(), and KbProfileDialog::profileList_reordered()\&.
.PP
.nf
62 { foreach(KbProfile* profile, _profiles) { if(profile->id()\&.guid == id) return profile; } return 0; }
.fi
.SS "static int Kb::frameRate ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 27 of file kb\&.h\&.
.PP
References _frameRate\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_fpsBox_valueChanged()\&.
.PP
.nf
27 { return _frameRate; }
.fi
.SS "void Kb::frameRate (intnewFrameRate)\fC [static]\fP"

.PP
Definition at line 216 of file kb\&.cpp\&.
.PP
References _frameRate, activeDevices, cmd, and KbManager::fps()\&.
.PP
.nf
216                                   {
217     KbManager::fps(newFrameRate);
218     // If the rate has changed, send to all devices
219     if(newFrameRate == _frameRate)
220         return;
221     _frameRate = newFrameRate;
222     foreach(Kb* kb, activeDevices){
223         kb->cmd\&.write(QString("fps %1\n")\&.arg(newFrameRate)\&.toLatin1());
224         kb->cmd\&.flush();
225     }
226 }
.fi
.SS "void Kb::frameUpdate ()\fC [slot]\fP"

.PP
Definition at line 426 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, KbPerf::applyIndicators(), KbMode::bind(), KbLight::close(), deletePrevious(), KbLight::frameUpdate(), KbProfile::indexOf(), KbLight::isStarted(), iState, KbMode::light(), monochrome, notifyNumber, KbLight::open(), KbMode::perf(), prevMode, prevProfile, KbBind::update(), KbPerf::update(), and writeProfileHeader()\&.
.PP
.nf
426                     {
427     // Advance animation frame
428     if(!_currentMode)
429         return;
430     KbLight* light = _currentMode->light();
431     KbBind* bind = _currentMode->bind();
432     KbPerf* perf = _currentMode->perf();
433     if(!light->isStarted()){
434         // Don't do anything until the animations are started
435         light->open();
436         return;
437     }
438 
439     // Stop animations on the previously active mode (if any)
440     bool changed = false;
441     if(prevMode != _currentMode){
442         if(prevMode){
443             prevMode->light()->close();
444             disconnect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
445         }
446         prevMode = _currentMode;
447         connect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
448         changed = true;
449     }
450 
451     // If the profile has changed, update it
452     if(prevProfile != _currentProfile){
453         writeProfileHeader();
454         cmd\&.write(" ");
455         prevProfile = _currentProfile;
456     }
457 
458     // Update current mode
459     int index = _currentProfile->indexOf(_currentMode);
460     // ckb-daemon only has 6 modes: 3 hardware, 3 non-hardware\&. Beyond mode six, switch back to four\&.
461     // e\&.g\&. 1, 2, 3, 4, 5, 6, 4, 5, 6, 4, 5, 6 \&.\&.\&.
462     if(index >= 6)
463         index = 3 + index % 3;
464 
465     // Send lighting/binding to driver
466     cmd\&.write(QString("mode %1 switch ")\&.arg(index + 1)\&.toLatin1());
467     perf->applyIndicators(index, iState);
468     light->frameUpdate(cmd, monochrome);
469     cmd\&.write(QString("\n@%1 ")\&.arg(notifyNumber)\&.toLatin1());
470     bind->update(cmd, changed);
471     cmd\&.write(" ");
472     perf->update(cmd, notifyNumber, changed);
473     cmd\&.write("\n");
474     cmd\&.flush();
475 }
.fi
.SS "void Kb::fwUpdate (const QString &path)"

.PP
Definition at line 416 of file kb\&.cpp\&.
.PP
References fwUpdPath, and notifyNumber\&.
.PP
Referenced by FwUpgradeDialog::on_actionButton_clicked()\&.
.PP
.nf
416                                     {
417     fwUpdPath = path;
418     // Write the active command to ensure it's not ignored
419     cmd\&.write("active");
420     cmd\&.write(QString(" @%1 ")\&.arg(notifyNumber)\&.toLatin1());
421     cmd\&.write("fwupdate ");
422     cmd\&.write(path\&.toLatin1());
423     cmd\&.write("\n");
424 }
.fi
.SS "void Kb::fwUpdateFinished (boolsucceeded)\fC [signal]\fP"

.PP
Definition at line 277 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
278 {
279     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
280     QMetaObject::activate(this, &staticMetaObject, 7, _a);
281 }
.fi
.SS "void Kb::fwUpdateProgress (intcurrent, inttotal)\fC [signal]\fP"

.PP
Definition at line 270 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
271 {
272     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
273     QMetaObject::activate(this, &staticMetaObject, 6, _a);
274 }
.fi
.SS "\fBKeyMap\fP Kb::getKeyMap ()\fC [private]\fP"

.PP
Definition at line 807 of file kb\&.cpp\&.
.PP
References _layout\&.
.PP
Referenced by hwSave(), load(), newMode(), newProfile(), readNotify(), setCurrentProfile(), and updateLayout()\&.
.PP
.nf
807                     {
808     return KeyMap(_model, _layout);
809 }
.fi
.SS "int Kb::getMacroNumber ()\fC [inline]\fP"
getMacroNumber returns the macroNumber, which we have saved in the constructor\&. For usage with macro definions, this param must only be readable\&. So there is no setter\&. 
.PP
\fBReturns:\fP
.RS 4
The Number is returned as int\&. 
.RE
.PP

.PP
Definition at line 97 of file kb\&.h\&.
.PP
References macroNumber\&.
.PP
Referenced by KbBind::getMacroNumber()\&.
.PP
.nf
97 { return macroNumber; }
.fi
.SS "QString Kb::getMacroPath ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
The absolute path as String 
.RE
.PP

.PP
Definition at line 106 of file kb\&.h\&.
.PP
References macroPath\&.
.PP
Referenced by KbBind::getMacroPath()\&.
.PP
.nf
106 { return macroPath; }
.fi
.SS "\fBKbProfile\fP* Kb::hwProfile ()\fC [inline]\fP"

.PP
Definition at line 46 of file kb\&.h\&.
.PP
References _hwProfile\&.
.PP
Referenced by hwSave(), KbWidget::modeIcon(), KbProfileDialog::on_profileList_customContextMenuRequested(), readNotify(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
46 { return _hwProfile; }
.fi
.SS "void Kb::hwProfile (\fBKbProfile\fP *newHwProfile)"

.PP
Definition at line 482 of file kb\&.cpp\&.
.PP
References _hwProfile, and deleteHw()\&.
.PP
.nf
482                                          {
483     if(_hwProfile == newHwProfile)
484         return;
485     if(_hwProfile)
486         disconnect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
487     _hwProfile = newHwProfile;
488     if(_hwProfile)
489         connect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
490 }
.fi
.SS "void Kb::hwSave ()"

.PP
Definition at line 348 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _hwProfile, KbProfile::append(), KbLight::base(), KbLight::close(), deletePrevious(), getKeyMap(), UsbId::guidString(), hwModeCount, UsbId::hwModified, hwProfile(), KbProfile::id(), KbMode::id(), KbMode::light(), KbProfile::modeCount(), KbProfile::modes(), UsbId::modified, UsbId::modifiedString(), monochrome, KbMode::name(), KbMode::perf(), prevMode, KbProfile::setNeedsSave(), KbMode::setNeedsSave(), KbPerf::update(), and writeProfileHeader()\&.
.PP
Referenced by KbWidget::on_hwSaveButton_clicked(), and KbProfileDialog::on_profileList_customContextMenuRequested()\&.
.PP
.nf
348                {
349     if(!_currentProfile)
350         return;
351     // Close active lighting (if any)
352     if(prevMode){
353         prevMode->light()->close();
354         deletePrevious();
355     }
356     hwProfile(_currentProfile);
357     _hwProfile->id()\&.hwModified = _hwProfile->id()\&.modified;
358     _hwProfile->setNeedsSave();
359     // Re-send the current profile from scratch to ensure consistency
360     writeProfileHeader();
361     // Make sure there are enough modes
362     while(_currentProfile->modeCount() < hwModeCount)
363         _currentProfile->append(new KbMode(this, getKeyMap()));
364     // Write only the base colors of each mode, no animations
365     for(int i = 0; i < hwModeCount; i++){
366         KbMode* mode = _currentProfile->modes()[i];
367         cmd\&.write(QString("\nmode %1")\&.arg(i + 1)\&.toLatin1());
368         KbLight* light = mode->light();
369         KbPerf* perf = mode->perf();
370         if(mode == _currentMode)
371             cmd\&.write(" switch");
372         // Write the mode name and ID
373         cmd\&.write(" name ");
374         cmd\&.write(QUrl::toPercentEncoding(mode->name()));
375         cmd\&.write(" id ");
376         cmd\&.write(mode->id()\&.guidString()\&.toLatin1());
377         cmd\&.write(" ");
378         cmd\&.write(mode->id()\&.modifiedString()\&.toLatin1());
379         cmd\&.write(" ");
380         // Write lighting and performance
381         light->base(cmd, true, monochrome);
382         cmd\&.write(" ");
383         perf->update(cmd, true, false);
384         // Update mode ID
385         mode->id()\&.hwModified = mode->id()\&.modified;
386         mode->setNeedsSave();
387     }
388     cmd\&.write("\n");
389 
390     // Save the profile to memory
391     cmd\&.write("hwsave\n");
392     cmd\&.flush();
393 }
.fi
.SS "int Kb::indexOf (\fBKbProfile\fP *profile)\fC [inline]\fP"

.PP
Definition at line 61 of file kb\&.h\&.
.PP
References _profiles\&.
.PP
Referenced by KbProfileDialog::on_profileList_customContextMenuRequested()\&.
.PP
.nf
61 { return _profiles\&.indexOf(profile); }
.fi
.SS "void Kb::infoUpdated ()\fC [signal]\fP"

.PP
Definition at line 233 of file moc_kb\&.cpp\&.
.PP
Referenced by Kb(), load(), and updateLayout()\&.
.PP
.nf
234 {
235     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
236 }
.fi
.SS "bool Kb::isKeyboard () const\fC [inline]\fP"

.PP
Definition at line 23 of file kb\&.h\&.
.PP
References KeyMap::isKeyboard()\&.
.PP
Referenced by Kb(), and KbWidget::KbWidget()\&.
.PP
.nf
23 { return KeyMap::isKeyboard(_model); }
.fi
.SS "bool Kb::isMouse () const\fC [inline]\fP"

.PP
Definition at line 24 of file kb\&.h\&.
.PP
References KeyMap::isMouse()\&.
.PP
Referenced by KbWidget::KbWidget(), and readNotify()\&.
.PP
.nf
24 { return KeyMap::isMouse(_model); }
.fi
.SS "bool Kb::isOpen () const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 147 of file kb\&.h\&.
.PP
Referenced by KbManager::scanKeyboards(), and ~Kb()\&.
.PP
.nf
147 { return cmd\&.isOpen(); }
.fi
.SS "static \fBKeyMap::Layout\fP Kb::layout ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 30 of file kb\&.h\&.
.PP
References _layout\&.
.PP
Referenced by LayoutDialog::LayoutDialog(), SettingsWidget::on_layoutBox_activated(), and SettingsWidget::SettingsWidget()\&.
.PP
.nf
30 { return _layout; }
.fi
.SS "void Kb::layout (\fBKeyMap::Layout\fPnewLayout)\fC [static]\fP"

.PP
Definition at line 228 of file kb\&.cpp\&.
.PP
References _layout, activeDevices, KeyMap::NO_LAYOUT, and updateLayout()\&.
.PP
.nf
228                                      {
229     if(newLayout == KeyMap::NO_LAYOUT || newLayout == _layout)
230         return;
231     _layout = newLayout;
232     // Update all devices
233     foreach(Kb* kb, activeDevices)
234         kb->updateLayout();
235 }
.fi
.SS "void Kb::load ()"

.PP
Definition at line 292 of file kb\&.cpp\&.
.PP
References _needsSave, _profiles, current, getKeyMap(), infoUpdated(), prefsPath, profileAdded(), setCurrentProfile(), and CkbSettings::value()\&.
.PP
Referenced by KbManager::scanKeyboards()\&.
.PP
.nf
292              {
293     if(prefsPath\&.isEmpty())
294         return;
295     _needsSave = false;
296     CkbSettings settings(prefsPath);
297     // Read profiles
298     KbProfile* newCurrentProfile = 0;
299     QString current = settings\&.value("CurrentProfile")\&.toString()\&.trimmed()\&.toUpper();
300     foreach(QString guid, settings\&.value("Profiles")\&.toString()\&.split(" ")){
301         guid = guid\&.trimmed()\&.toUpper();
302         if(guid != ""){
303             KbProfile* profile = new KbProfile(this, getKeyMap(), settings, guid);
304             _profiles\&.append(profile);
305             if(guid == current || !newCurrentProfile)
306                 newCurrentProfile = profile;
307         }
308     }
309     if(newCurrentProfile)
310         setCurrentProfile(newCurrentProfile);
311     else {
312         // If nothing was loaded, load the demo profile
313         QSettings demoSettings(":/txt/demoprofile\&.conf", QSettings::IniFormat, this);
314         CkbSettings cSettings(demoSettings);
315         KbProfile* demo = new KbProfile(this, getKeyMap(), cSettings, "{BA7FC152-2D51-4C26-A7A6-A036CC93D924}");
316         _profiles\&.append(demo);
317         setCurrentProfile(demo);
318     }
319 
320     emit infoUpdated();
321     emit profileAdded();
322 }
.fi
.SS "static bool Kb::macroDelay ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 36 of file kb\&.h\&.
.PP
References _delay\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_delayBox_clicked()\&.
.PP
.nf
36 { return _delay; }
.fi
.SS "void Kb::macroDelay (boolflag)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIflag\fP true: Switch on delay function, else switch off 
.RE
.PP

.PP
Definition at line 838 of file kb\&.cpp\&.
.PP
References _delay, activeDevices, and cmd\&.
.PP
.nf
838                              {
839    _delay = flag;
840 
841    foreach(Kb* kb, activeDevices){
842        kb->cmd\&.write(QString("\ndelay %1\n")\&.arg(flag? "on" : "off")\&.toLatin1());
843    }
844 }
.fi
.SS "bool Kb::matches (const QString &path, const QString &serial)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 161 of file kb\&.h\&.
.PP
References devpath, and usbSerial\&.
.PP
Referenced by KbManager::scanKeyboards()\&.
.PP
.nf
161 { return path\&.trimmed() == devpath\&.trimmed() && usbSerial == serial\&.trimmed()\&.toUpper(); }
.fi
.SS "void Kb::modeChanged (boolspontaneous)\fC [signal]\fP"

.PP
Definition at line 263 of file moc_kb\&.cpp\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
264 {
265     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
266     QMetaObject::activate(this, &staticMetaObject, 5, _a);
267 }
.fi
.SS "\fBKeyMap::Model\fP Kb::model () const\fC [inline]\fP"

.PP
Definition at line 22 of file kb\&.h\&.
.PP
References _model\&.
.PP
.nf
22 { return _model; }
.fi
.SS "void Kb::modeRenamed ()\fC [signal]\fP"

.PP
Definition at line 251 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
252 {
253     QMetaObject::activate(this, &staticMetaObject, 3, Q_NULLPTR);
254 }
.fi
.SS "static bool Kb::mouseAccel ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 39 of file kb\&.h\&.
.PP
References _mouseAccel\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_mAccelBox_clicked()\&.
.PP
.nf
39 { return _mouseAccel; }
.fi
.SS "void Kb::mouseAccel (boolnewAccel)\fC [static]\fP"

.PP
Definition at line 266 of file kb\&.cpp\&.
.PP
References _mouseAccel, activeDevices, and cmd\&.
.PP
.nf
266                                 {
267     if(newAccel == _mouseAccel)
268         return;
269     _mouseAccel = newAccel;
270 #ifdef Q_OS_MACX
271     // Update all devices
272     foreach(Kb* kb, activeDevices){
273         kb->cmd\&.write(QString("accel %1\n")\&.arg(QString(newAccel ? "on" : "off"))\&.toLatin1());
274         kb->cmd\&.flush();
275     }
276 #endif
277 }
.fi
.SS "bool Kb::needsSave () const"

.PP
Definition at line 395 of file kb\&.cpp\&.
.PP
References _needsSave, _profiles, and KbProfile::needsSave()\&.
.PP
Referenced by autoSave()\&.
.PP
.nf
395                          {
396     if(_needsSave)
397         return true;
398     foreach(const KbProfile* profile, _profiles){
399         if(profile->needsSave())
400             return true;
401     }
402     return false;
403 }
.fi
.SS "\fBKbMode\fP* Kb::newMode ()\fC [inline]\fP"

.PP
Definition at line 79 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
Referenced by KbWidget::on_modesList_customContextMenuRequested(), and KbWidget::on_modesList_itemClicked()\&.
.PP
.nf
79 { return new KbMode(this, getKeyMap()); }
.fi
.SS "\fBKbMode\fP* Kb::newMode (\fBKbMode\fP *other)\fC [inline]\fP"

.PP
Definition at line 80 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
.nf
80 { return new KbMode(this, getKeyMap(), *other); }
.fi
.SS "\fBKbProfile\fP* Kb::newProfile ()\fC [inline]\fP"

.PP
Definition at line 77 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
Referenced by KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemClicked(), and readNotify()\&.
.PP
.nf
77 { return new KbProfile(this, getKeyMap()); }
.fi
.SS "\fBKbProfile\fP* Kb::newProfile (\fBKbProfile\fP *other)\fC [inline]\fP"

.PP
Definition at line 78 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
.nf
78 { return new KbProfile(this, getKeyMap(), *other); }
.fi
.SS "void Kb::profileAdded ()\fC [signal]\fP"

.PP
Definition at line 239 of file moc_kb\&.cpp\&.
.PP
Referenced by load(), and readNotify()\&.
.PP
.nf
240 {
241     QMetaObject::activate(this, &staticMetaObject, 1, Q_NULLPTR);
242 }
.fi
.SS "void Kb::profileChanged ()\fC [signal]\fP"

.PP
Definition at line 257 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify(), and setCurrentMode()\&.
.PP
.nf
258 {
259     QMetaObject::activate(this, &staticMetaObject, 4, Q_NULLPTR);
260 }
.fi
.SS "void Kb::profileRenamed ()\fC [signal]\fP"

.PP
Definition at line 245 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
246 {
247     QMetaObject::activate(this, &staticMetaObject, 2, Q_NULLPTR);
248 }
.fi
.SS "const QList<\fBKbProfile\fP*>& Kb::profiles () const\fC [inline]\fP"

.PP
Definition at line 58 of file kb\&.h\&.
.PP
References _profiles\&.
.PP
Referenced by KbWidget::on_profileBox_activated(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::profileList_reordered(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
58 { return _profiles; }
.fi
.SS "void Kb::profiles (const QList< \fBKbProfile\fP * > &newProfiles)\fC [inline]\fP"

.PP
Definition at line 59 of file kb\&.h\&.
.PP
References _needsSave, and _profiles\&.
.PP
.nf
59 { _needsSave = true; _profiles = newProfiles; }
.fi
.SS "void Kb::readNotify (QStringline)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 522 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _hwProfile, _needsSave, _profiles, KbPerf::angleSnap(), KbLight::animKeypress(), KbProfile::append(), KbMode::bind(), KbLight::color(), KbPerf::curDpiIdx(), KbPerf::dpi(), KbPerf::DPI_COUNT, KbPerf::dpiColor(), KbPerf::dpiEnabled(), fwUpdateFinished(), fwUpdateProgress(), fwUpdPath, getKeyMap(), UsbId::guid, hwLoading, HWMODE_MAX, hwModeCount, UsbId::hwModifiedString(), hwProfile(), KbProfile::id(), KbMode::id(), KbProfile::indexOf(), isMouse(), iState, KbBind::keyEvent(), KbPerf::liftHeight(), KbMode::light(), KbProfile::modeCount(), modeRenamed(), KbProfile::modes(), UsbId::modifiedString(), KbProfile::move(), KbProfile::name(), KbMode::name(), newProfile(), notifyNumber, KbMode::perf(), profileAdded(), profileChanged(), profileRenamed(), setCurrentProfile(), KbProfile::setNeedsSave(), KbMode::setNeedsSave(), x, and y\&.
.PP
.nf
522                                {
523     QStringList components = line\&.trimmed()\&.split(" ");
524     if(components\&.count() < 2)
525         return;
526     if(components[0] == "key"){
527         // Key event
528         QString key = components[1];
529         if(key\&.length() < 2)
530             return;
531         QString keyName = key\&.mid(1);
532         bool keyPressed = (key[0] == '+');
533         KbMode* mode = _currentMode;
534         if(mode){
535             mode->light()->animKeypress(keyName, keyPressed);
536             mode->bind()->keyEvent(keyName, keyPressed);
537         }
538     } else if(components[0] == "i"){
539         // Indicator event
540         QString i = components[1];
541         if(i\&.length() < 2)
542             return;
543         QString iName = i\&.mid(1);
544         bool on = (i[0] == '+');
545         if(iName == "num")
546             iState[0] = on;
547         else if(iName == "caps")
548             iState[1] = on;
549         else if(iName == "scroll")
550             iState[2] = on;
551     } else if(components[0] == "hwprofileid"){
552         // Hardware profile ID
553         if(components\&.count() < 3)
554             return;
555         // Find the hardware profile in the list of profiles
556         QString guid = components[1];
557         QString modified = components[2];
558         KbProfile* newProfile = 0;
559         foreach(KbProfile* profile, _profiles){
560             if(profile->id()\&.guid == guid){
561                 newProfile = profile;
562                 break;
563             }
564         }
565         // If it wasn't found, create it
566         if(!newProfile){
567             newProfile = new KbProfile(this, getKeyMap(), guid, modified);
568             hwLoading[0] = true;
569             cmd\&.write(QString("@%1 get :hwprofilename\n")\&.arg(notifyNumber)\&.toLatin1());
570             cmd\&.flush();
571         } else {
572             // If it's been updated, fetch its name
573             if(newProfile->id()\&.hwModifiedString() != modified){
574                 newProfile->id()\&.modifiedString(modified);
575                 newProfile->id()\&.hwModifiedString(modified);
576                 newProfile->setNeedsSave();
577                 if(hwLoading[0]){
578                     cmd\&.write(QString("@%1 get :hwprofilename\n")\&.arg(notifyNumber)\&.toLatin1());
579                     cmd\&.flush();
580                 }
581             } else {
582                 hwLoading[0] = false;
583             }
584         }
585         hwProfile(newProfile);
586         emit profileAdded();
587         if(_hwProfile == _currentProfile)
588             emit profileChanged();
589     } else if(components[0] == "hwprofilename"){
590         // Hardware profile name
591         QString name = QUrl::fromPercentEncoding(components[1]\&.toUtf8());
592         if(!_hwProfile || !hwLoading[0])
593             return;
594         QString oldName = _hwProfile->name();
595         if(!(oldName\&.length() >= name\&.length() && oldName\&.left(name\&.length()) == name)){
596             // Don't change the name if it's a truncated version of what we already have
597             _hwProfile->name(name);
598             emit profileRenamed();
599         }
600     } else if(components[0] == "mode"){
601         // Mode-specific data
602         if(components\&.count() < 4)
603             return;
604         int mode = components[1]\&.toInt() - 1;
605         if(components[2] == "hwid"){
606             if(components\&.count() < 5 || mode >= HWMODE_MAX || !_hwProfile)
607                 return;
608             // Hardware mode ID
609             QString guid = components[3];
610             QString modified = components[4];
611             // Look for this mode in the hardware profile
612             KbMode* hwMode = 0;
613             bool isUpdated = false;
614             foreach(KbMode* kbMode, _hwProfile->modes()){
615                 if(kbMode->id()\&.guid == guid){
616                     hwMode = kbMode;
617                     if(kbMode->id()\&.hwModifiedString() != modified){
618                         // Update modification time
619                         hwMode->id()\&.modifiedString(modified);
620                         hwMode->id()\&.hwModifiedString(modified);
621                         hwMode->setNeedsSave();
622                         isUpdated = true;
623                     } else {
624                         hwLoading[mode + 1] = false;
625                     }
626                     break;
627                 }
628             }
629             // If it wasn't found, add it
630             if(!hwMode){
631                 isUpdated = true;
632                 hwMode = new KbMode(this, getKeyMap(), guid, modified);
633                 _hwProfile->append(hwMode);
634                 // If the hardware profile now contains enough modes to be added to the list, do so
635                 if(!_profiles\&.contains(_hwProfile) && _hwProfile->modeCount() >= hwModeCount){
636                     _profiles\&.append(_hwProfile);
637                     _needsSave = true;
638                     emit profileAdded();
639                     if(!_currentProfile)
640                         setCurrentProfile(_hwProfile);
641                 }
642             }
643             if(hwLoading[mode + 1] && isUpdated){
644                 // If the mode isn't in the right place, move it
645                 int index = _hwProfile->indexOf(hwMode);
646                 if(mode < _hwProfile->modeCount() && index != mode)
647                     _hwProfile->move(index, mode);
648                 // Fetch the updated data
649                 cmd\&.write(QString("@%1 mode %2 get :hwname :hwrgb")\&.arg(notifyNumber)\&.arg(mode + 1)\&.toLatin1());
650                 if(isMouse())
651                     cmd\&.write(" :hwdpi :hwdpisel :hwlift :hwsnap");
652                 cmd\&.write("\n");
653                 cmd\&.flush();
654             }
655         } else if(components[2] == "hwname"){
656             // Mode name - update list
657             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
658                 return;
659             KbMode* hwMode = _hwProfile->modes()[mode];
660             QString name = QUrl::fromPercentEncoding(components[3]\&.toUtf8());
661             QString oldName = hwMode->name();
662             if(!(oldName\&.length() >= name\&.length() && oldName\&.left(name\&.length()) == name)){
663                 // Don't change the name if it's a truncated version of what we already have
664                 hwMode->name(name);
665                 if(_hwProfile == _currentProfile)
666                     emit modeRenamed();
667             }
668         } else if(components[2] == "hwrgb"){
669             // RGB - set mode lighting
670             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
671                 return;
672             KbMode* kbmode = _hwProfile->modes()[mode];
673             KbLight* light = kbmode->light();
674             // Scan the input for colors
675             QColor lightColor = QColor();
676             for(int i = 3; i < components\&.count(); i++){
677                 QString comp = components[i];
678                 if(comp\&.indexOf(":") < 0){
679                     // No ":" - single hex constant
680                     bool ok;
681                     int rgb = comp\&.toInt(&ok, 16);
682                     if(ok)
683                         light->color(QColor::fromRgb((QRgb)rgb));
684                 } else {
685                     // List of keys ("a,b:xxxxxx")\&. Parse color first
686                     QStringList set = comp\&.split(":");
687                     bool ok;
688                     int rgb = set[1]\&.toInt(&ok, 16);
689                     if(ok){
690                         QColor color = QColor::fromRgb((QRgb)rgb);
691                         // Parse keys
692                         QStringList keys = set[0]\&.split(",");
693                         foreach(QString key, keys){
694                             if(key == "light")
695                                 // Extrapolate the Light key to the M-keys and Lock key, since those will be set to black on hwsave
696                                 lightColor = color;
697                             if(key\&.startsWith("dpi") && key\&.length() > 3){
698                                 // DPI levels go to the KbPerf object instead of KbLight
699                                 bool ok = false;
700                                 int index = key\&.mid(3)\&.toInt(&ok);
701                                 if(ok)
702                                     kbmode->perf()->dpiColor(index, color);
703                                 continue;
704                             }
705                             light->color(key, color);
706                         }
707                     }
708                 }
709             }
710             if(lightColor\&.isValid()){
711                 light->color("mr", lightColor);
712                 light->color("m1", lightColor);
713                 light->color("m2", lightColor);
714                 light->color("m3", lightColor);
715                 light->color("lock", lightColor);
716             }
717         } else if(components[2] == "hwdpi"){
718             // DPI settings
719             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
720                 return;
721             KbPerf* perf = _hwProfile->modes()[mode]->perf();
722             // Read the rest of the line as stage:x,y
723             foreach(QString comp, components\&.mid(3)){
724                 QStringList dpi = comp\&.split(':');
725                 if(dpi\&.length() != 2)
726                     continue;
727                 QStringList xy = dpi[1]\&.split(',');
728                 int x, y;
729                 bool off = false;
730                 if(xy\&.length() < 2){
731                     // If the right side only has one parameter, set both X and Y
732                     if(xy[0] == "off")
733                         off = true;
734                     else
735                         x = y = xy[0]\&.toInt();
736                 } else {
737                     x = xy[0]\&.toInt();
738                     y = xy[1]\&.toInt();
739                 }
740                 // Set DPI for this stage
741                 int index = dpi[0]\&.toInt();
742                 if(off){
743                     perf->dpiEnabled(index, false);
744                     // If all DPIs have been disabled, turn them back on
745                     bool allOff = true;
746                     for(int i = 1; i < KbPerf::DPI_COUNT; i++){
747                         if(perf->dpiEnabled(i)){
748                             allOff = false;
749                             break;
750                         }
751                     }
752                     if(allOff){
753                         for(int i = 1; i < KbPerf::DPI_COUNT; i++)
754                             perf->dpiEnabled(i, true);
755                     }
756                 } else {
757                     perf->dpiEnabled(index, true);
758                     perf->dpi(index, QPoint(x, y));
759                 }
760             }
761         } else if(components[2] == "hwdpisel"){
762             // Hardware DPI selection (0\&.\&.\&.5)
763             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
764                 return;
765             KbPerf* perf = _hwProfile->modes()[mode]->perf();
766             int idx = components[3]\&.toInt();
767             if(idx < 1)
768                 idx = 1;
769             if(idx >= KbPerf::DPI_COUNT)
770                 idx = KbPerf::DPI_COUNT - 1;
771             perf->curDpiIdx(idx);
772         } else if(components[2] == "hwlift"){
773             // Mouse lift height (1\&.\&.\&.5)
774             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
775                 return;
776             KbPerf* perf = _hwProfile->modes()[mode]->perf();
777             perf->liftHeight((KbPerf::height)components[3]\&.toInt());
778         } else if(components[3] == "hwsnap"){
779             // Mouse angle snapping ("on" or "off")
780             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
781                 return;
782             KbPerf* perf = _hwProfile->modes()[mode]->perf();
783             perf->angleSnap(components[3] == "on");
784         }
785     } else if(components[0] == "fwupdate"){
786         // Firmware update progress
787         if(components\&.count() < 3)
788             return;
789         // Make sure path is the same
790         if(components[1] != fwUpdPath)
791             return;
792         QString res = components[2];
793         if(res == "invalid" || res == "fail")
794             emit fwUpdateFinished(false);
795         else if(res == "ok")
796             emit fwUpdateFinished(true);
797         else {
798             // "xx/yy" indicates progress
799             if(!res\&.contains("/"))
800                 return;
801             QStringList numbers = res\&.split("/");
802             emit fwUpdateProgress(numbers[0]\&.toInt(), numbers[1]\&.toInt());
803         }
804     }
805 }
.fi
.SS "void Kb::run ()\fC [private]\fP"

.PP
Definition at line 497 of file kb\&.cpp\&.
.PP
References notifyPath, notifyPathMutex, and notifyPaths\&.
.PP
.nf
497             {
498     QFile notify(notifyPath);
499     // Wait a small amount of time for the node to open (100ms)
500     QThread::usleep(100000);
501     if(!notify\&.open(QIODevice::ReadOnly)){
502         // If it's still not open, try again before giving up (1s at a time, 10s total)
503         QThread::usleep(900000);
504         for(int i = 1; i < 10; i++){
505             if(notify\&.open(QIODevice::ReadOnly))
506                 break;
507             QThread::sleep(1);
508         }
509         if(!notify\&.isOpen())
510             return;
511     }
512     // Read data from notification node
513     QByteArray line;
514     while(notify\&.isOpen() && (line = notify\&.readLine())\&.length() > 0){
515         QString text = QString::fromUtf8(line);
516         metaObject()->invokeMethod(this, "readNotify", Qt::QueuedConnection, Q_ARG(QString, text));
517     }
518     QMutexLocker locker(&notifyPathMutex);
519     notifyPaths\&.remove(notifyPath);
520 }
.fi
.SS "void Kb::save ()"

.PP
Definition at line 324 of file kb\&.cpp\&.
.PP
References _currentProfile, _needsSave, _profiles, UsbId::guidString(), KbProfile::id(), prefsPath, KbProfile::save(), and CkbSettings::setValue()\&.
.PP
Referenced by autoSave(), KbWidget::on_hwSaveButton_clicked(), KbManager::scanKeyboards(), and ~Kb()\&.
.PP
.nf
324              {
325     if(prefsPath\&.isEmpty())
326         return;
327     _needsSave = false;
328     CkbSettings settings(prefsPath, true);
329     QString guids, currentGuid;
330     foreach(KbProfile* profile, _profiles){
331         guids\&.append(" " + profile->id()\&.guidString());
332         if(profile == _currentProfile)
333             currentGuid = profile->id()\&.guidString();
334         profile->save(settings);
335     }
336     settings\&.setValue("CurrentProfile", currentGuid);
337     settings\&.setValue("Profiles", guids\&.trimmed());
338 }
.fi
.SS "static int Kb::scrollSpeed ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 42 of file kb\&.h\&.
.PP
References _scrollSpeed\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), ExtraSettingsWidget::on_sAccelBox_clicked(), and ExtraSettingsWidget::on_sSpeedBox_valueChanged()\&.
.PP
.nf
42 { return _scrollSpeed; }
.fi
.SS "void Kb::scrollSpeed (intnewSpeed)\fC [static]\fP"

.PP
Definition at line 279 of file kb\&.cpp\&.
.PP
References _scrollSpeed, activeDevices, and cmd\&.
.PP
.nf
279                                 {
280     if(newSpeed == _scrollSpeed)
281         return;
282     _scrollSpeed = newSpeed;
283 #ifdef Q_OS_MACX
284     // Update all devices
285     foreach(Kb* kb, activeDevices){
286         kb->cmd\&.write(QString("scrollspeed %1\n")\&.arg(newSpeed)\&.toLatin1());
287         kb->cmd\&.flush();
288     }
289 #endif
290 }
.fi
.SS "void Kb::setCurrentMode (\fBKbProfile\fP *profile, \fBKbMode\fP *mode, boolspontaneous = \fCtrue\fP)"

.PP
Definition at line 820 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _needsSave, KbProfile::currentMode(), modeChanged(), and profileChanged()\&.
.PP
Referenced by KeyAction::keyEvent(), KbWidget::on_modesList_currentItemChanged(), KbWidget::on_modesList_customContextMenuRequested(), KbWidget::on_modesList_itemClicked(), and setCurrentProfile()\&.
.PP
.nf
820                                                                          {
821     if(_currentProfile != profile){
822         _currentProfile = profile;
823         _needsSave = true;
824         emit profileChanged();
825     }
826     if(_currentMode != mode || _currentProfile->currentMode() != mode){
827         _currentProfile->currentMode(_currentMode = mode);
828         _needsSave = true;
829         emit modeChanged(spontaneous);
830     }
831 }
.fi
.SS "void Kb::setCurrentMode (\fBKbProfile\fP *profile, intindex, boolspontaneous = \fCtrue\fP)\fC [inline]\fP"

.PP
Definition at line 73 of file kb\&.h\&.
.PP
References KbProfile::modes(), and setCurrentMode()\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
73 { setCurrentMode(profile, profile->modes()[index], spontaneous); }
.fi
.SS "void Kb::setCurrentMode (\fBKbMode\fP *mode, boolspontaneous = \fCtrue\fP)\fC [inline]\fP"

.PP
Definition at line 74 of file kb\&.h\&.
.PP
References _currentProfile, and setCurrentMode()\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
74 { setCurrentMode(_currentProfile, mode, spontaneous); }
.fi
.SS "void Kb::setCurrentProfile (\fBKbProfile\fP *profile, boolspontaneous = \fCtrue\fP)"

.PP
Definition at line 811 of file kb\&.cpp\&.
.PP
References KbProfile::append(), KbProfile::currentMode(), getKeyMap(), hwModeCount, KbProfile::modeCount(), KbProfile::modes(), and setCurrentMode()\&.
.PP
Referenced by load(), KbWidget::on_profileBox_activated(), KbProfileDialog::on_profileList_currentItemChanged(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemClicked(), and readNotify()\&.
.PP
.nf
811                                                               {
812     while(profile->modeCount() < hwModeCount)
813         profile->append(new KbMode(this, getKeyMap()));
814     KbMode* mode = profile->currentMode();
815     if(!mode)
816         profile->currentMode(mode = profile->modes()\&.first());
817     setCurrentMode(profile, mode, spontaneous);
818 }
.fi
.SS "void Kb::updateLayout ()\fC [private]\fP"

.PP
Definition at line 237 of file kb\&.cpp\&.
.PP
References _currentProfile, _hwProfile, _layout, _profiles, KbLight::close(), getKeyMap(), infoUpdated(), KeyMap::isISO(), KbProfile::keyMap(), KbMode::light(), and KbProfile::modes()\&.
.PP
Referenced by layout()\&.
.PP
.nf
237                      {
238 #ifdef Q_OS_MACX
239     // Write ANSI/ISO flag to daemon (OSX only)
240     cmd\&.write("layout ");
241     cmd\&.write(KeyMap::isISO(_layout) ? "iso" : "ansi");
242     cmd\&.write("\n");
243     cmd\&.flush();
244 #endif
245     foreach(KbProfile* profile, _profiles)
246         profile->keyMap(getKeyMap());
247     if(_hwProfile && !_profiles\&.contains(_hwProfile))
248         _hwProfile->keyMap(getKeyMap());
249     // Stop all animations as they'll need to be restarted
250     foreach(KbMode* mode, _currentProfile->modes())
251         mode->light()->close();
252     emit infoUpdated();
253 }
.fi
.SS "void Kb::writeProfileHeader ()\fC [private]\fP"

.PP
Definition at line 405 of file kb\&.cpp\&.
.PP
References _currentProfile, UsbId::guidString(), KbProfile::id(), UsbId::modifiedString(), and KbProfile::name()\&.
.PP
Referenced by frameUpdate(), and hwSave()\&.
.PP
.nf
405                            {
406     cmd\&.write("eraseprofile");
407     // Write the profile name and ID
408     cmd\&.write(" profilename ");
409     cmd\&.write(QUrl::toPercentEncoding(_currentProfile->name()));
410     cmd\&.write(" profileid ");
411     cmd\&.write(_currentProfile->id()\&.guidString()\&.toLatin1());
412     cmd\&.write(" ");
413     cmd\&.write(_currentProfile->id()\&.modifiedString()\&.toLatin1());
414 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBKbManager\fP\fC [friend]\fP"

.PP
Definition at line 142 of file kb\&.h\&.
.SH "Field Documentation"
.PP 
.SS "\fBKbMode\fP* Kb::_currentMode\fC [private]\fP"

.PP
Definition at line 173 of file kb\&.h\&.
.PP
Referenced by currentBind(), currentLight(), currentMode(), currentPerf(), frameUpdate(), hwSave(), readNotify(), and setCurrentMode()\&.
.SS "\fBKbProfile\fP* Kb::_currentProfile\fC [private]\fP"

.PP
Definition at line 171 of file kb\&.h\&.
.PP
Referenced by currentProfile(), frameUpdate(), hwSave(), readNotify(), save(), setCurrentMode(), updateLayout(), and writeProfileHeader()\&.
.SS "bool Kb::_delay = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 204 of file kb\&.h\&.
.PP
Referenced by Kb(), and macroDelay()\&.
.SS "bool Kb::_dither = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 169 of file kb\&.h\&.
.PP
Referenced by dither(), and Kb()\&.
.SS "int Kb::_frameRate = 30\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 168 of file kb\&.h\&.
.PP
Referenced by frameRate(), and Kb()\&.
.SS "\fBKbProfile\fP* Kb::_hwProfile\fC [private]\fP"

.PP
Definition at line 187 of file kb\&.h\&.
.PP
Referenced by deleteHw(), hwProfile(), hwSave(), readNotify(), and updateLayout()\&.
.SS "\fBKeyMap::Layout\fP Kb::_layout = \fBKeyMap::NO_LAYOUT\fP\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 165 of file kb\&.h\&.
.PP
Referenced by getKeyMap(), Kb(), layout(), and updateLayout()\&.
.SS "\fBKeyMap::Model\fP Kb::_model\fC [private]\fP"

.PP
Definition at line 175 of file kb\&.h\&.
.PP
Referenced by Kb(), and model()\&.
.SS "bool Kb::_mouseAccel = true\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 169 of file kb\&.h\&.
.PP
Referenced by Kb(), and mouseAccel()\&.
.SS "bool Kb::_needsSave\fC [private]\fP"

.PP
Definition at line 207 of file kb\&.h\&.
.PP
Referenced by appendProfile(), load(), needsSave(), profiles(), readNotify(), save(), and setCurrentMode()\&.
.SS "QList<\fBKbProfile\fP*> Kb::_profiles\fC [private]\fP"

.PP
Definition at line 172 of file kb\&.h\&.
.PP
Referenced by appendProfile(), find(), indexOf(), load(), needsSave(), profiles(), readNotify(), save(), and updateLayout()\&.
.SS "int Kb::_scrollSpeed = 0\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 168 of file kb\&.h\&.
.PP
Referenced by Kb(), and scrollSpeed()\&.
.SS "QFile Kb::cmd\fC [private]\fP"

.PP
Definition at line 195 of file kb\&.h\&.
.PP
Referenced by dither(), frameRate(), macroDelay(), mouseAccel(), and scrollSpeed()\&.
.SS "QString Kb::cmdpath\fC [private]\fP"

.PP
Definition at line 154 of file kb\&.h\&.
.PP
Referenced by Kb()\&.
.SS "QString Kb::devpath\fC [private]\fP"

.PP
Definition at line 154 of file kb\&.h\&.
.PP
Referenced by matches()\&.
.SS "QString Kb::features"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by MainWindow::checkFwUpdates(), FwUpgradeDialog::exec(), Kb(), KbWidget::KbWidget(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.SS "QString Kb::firmware"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by MainWindow::checkFwUpdates(), KbWidget::devUpdate(), FwUpgradeDialog::FwUpgradeDialog(), Kb(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.SS "QString Kb::fwUpdPath\fC [private]\fP"

.PP
Definition at line 185 of file kb\&.h\&.
.PP
Referenced by fwUpdate(), and readNotify()\&.
.SS "bool Kb::hwLoading[\fBHWMODE_MAX\fP+1]\fC [private]\fP"

.PP
Definition at line 211 of file kb\&.h\&.
.PP
Referenced by Kb(), and readNotify()\&.
.SS "const int Kb::HWMODE_MAX = 3\fC [static]\fP"

.PP
Definition at line 50 of file kb\&.h\&.
.PP
Referenced by KbPerf::applyIndicators(), and readNotify()\&.
.SS "int Kb::hwModeCount"

.PP
Definition at line 49 of file kb\&.h\&.
.PP
Referenced by hwSave(), Kb(), KbWidget::modeIcon(), KbWidget::on_modesList_customContextMenuRequested(), readNotify(), and setCurrentProfile()\&.
.SS "bool Kb::iState[\fBKbPerf::HW_I_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 178 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), Kb(), and readNotify()\&.
.SS "quint64 Kb::lastAutoSave\fC [private]\fP"

.PP
Definition at line 182 of file kb\&.h\&.
.PP
Referenced by autoSave()\&.
.SS "int Kb::macroNumber = -1\fC [static]\fP, \fC [private]\fP"

.PP
.RS 4
is invalid entry\&. 
.RE
.PP

.PP
Definition at line 202 of file kb\&.h\&.
.PP
Referenced by getMacroNumber(), and Kb()\&.
.SS "QString Kb::macroPath = ''\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 158 of file kb\&.h\&.
.PP
Referenced by getMacroPath(), Kb(), and ~Kb()\&.
.SS "bool Kb::monochrome"

.PP
Definition at line 19 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), hwSave(), Kb(), and KbWidget::KbWidget()\&.
.SS "int Kb::notifyNumber\fC [private]\fP"

.PP
Definition at line 198 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), fwUpdate(), Kb(), readNotify(), and ~Kb()\&.
.SS "QString Kb::notifyPath\fC [private]\fP"

.PP
Definition at line 154 of file kb\&.h\&.
.PP
Referenced by Kb(), and run()\&.
.SS "QString Kb::pollrate"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by KbWidget::devUpdate(), and Kb()\&.
.SS "QString Kb::prefsPath\fC [private]\fP"

.PP
Definition at line 181 of file kb\&.h\&.
.PP
Referenced by Kb(), load(), and save()\&.
.SS "\fBKbMode\fP* Kb::prevMode\fC [private]\fP"

.PP
Definition at line 190 of file kb\&.h\&.
.PP
Referenced by deletePrevious(), frameUpdate(), and hwSave()\&.
.SS "\fBKbProfile\fP* Kb::prevProfile\fC [private]\fP"

.PP
Definition at line 189 of file kb\&.h\&.
.PP
Referenced by frameUpdate()\&.
.SS "QString Kb::usbModel"

.PP
Definition at line 16 of file kb\&.h\&.
.PP
Referenced by FwUpgradeDialog::FwUpgradeDialog(), Kb(), KbWidget::name(), and MainWindow::showFwUpdateNotification()\&.
.SS "QString Kb::usbSerial"

.PP
Definition at line 16 of file kb\&.h\&.
.PP
Referenced by KbWidget::devUpdate(), Kb(), and matches()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
