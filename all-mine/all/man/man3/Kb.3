.TH "Kb" 3 "Tue May 16 2017" "Version beta-v0.2.7 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Kb \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kb\&.h>\fP
.PP
Inherits \fBQThread\fP\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "void \fBframeUpdate\fP ()"
.br
.ti -1c
.RI "void \fBautoSave\fP ()"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBinfoUpdated\fP ()"
.br
.ti -1c
.RI "void \fBprofileAdded\fP ()"
.br
.ti -1c
.RI "void \fBprofileRenamed\fP ()"
.br
.ti -1c
.RI "void \fBmodeRenamed\fP ()"
.br
.ti -1c
.RI "void \fBprofileChanged\fP ()"
.br
.ti -1c
.RI "void \fBmodeChanged\fP (bool spontaneous)"
.br
.ti -1c
.RI "void \fBfwUpdateProgress\fP (int \fBcurrent\fP, int total)"
.br
.ti -1c
.RI "void \fBfwUpdateFinished\fP (bool succeeded)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyMap::Model\fP \fBmodel\fP () const "
.br
.ti -1c
.RI "bool \fBisKeyboard\fP () const "
.br
.ti -1c
.RI "bool \fBisMouse\fP () const "
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBhwProfile\fP ()"
.br
.ti -1c
.RI "void \fBhwProfile\fP (\fBKbProfile\fP *newHwProfile)"
.br
.ti -1c
.RI "void \fBfwUpdate\fP (const QString &path)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBcurrentProfile\fP ()"
.br
.ti -1c
.RI "const QList< \fBKbProfile\fP * > & \fBprofiles\fP () const "
.br
.ti -1c
.RI "void \fBprofiles\fP (const QList< \fBKbProfile\fP * > &newProfiles)"
.br
.ti -1c
.RI "void \fBappendProfile\fP (\fBKbProfile\fP *\fBnewProfile\fP)"
.br
.ti -1c
.RI "int \fBindexOf\fP (\fBKbProfile\fP *profile)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBfind\fP (const QUuid &id)"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBcurrentMode\fP ()"
.br
.ti -1c
.RI "\fBKbLight\fP * \fBcurrentLight\fP ()"
.br
.ti -1c
.RI "\fBKbBind\fP * \fBcurrentBind\fP ()"
.br
.ti -1c
.RI "\fBKbPerf\fP * \fBcurrentPerf\fP ()"
.br
.ti -1c
.RI "void \fBsetCurrentProfile\fP (\fBKbProfile\fP *profile, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbProfile\fP *profile, \fBKbMode\fP *mode, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbProfile\fP *profile, int index, bool spontaneous=true)"
.br
.ti -1c
.RI "void \fBsetCurrentMode\fP (\fBKbMode\fP *mode, bool spontaneous=true)"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBnewProfile\fP ()"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBnewProfile\fP (\fBKbProfile\fP *other)"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBnewMode\fP ()"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBnewMode\fP (\fBKbMode\fP *other)"
.br
.ti -1c
.RI "void \fBload\fP ()"
.br
.ti -1c
.RI "void \fBsave\fP ()"
.br
.ti -1c
.RI "bool \fBneedsSave\fP () const "
.br
.ti -1c
.RI "void \fBhwSave\fP ()"
.br
.ti -1c
.RI "int \fBgetMacroNumber\fP ()"
.br
.RI "\fIFor usage with macro definions, these two params must only be readable\&. So there are no setters\&. \fP"
.ti -1c
.RI "QString \fBgetMacroPath\fP ()"
.br
.RI "\fIgetMacroPath returns the macroPath (e\&.g\&. /dev/input/ckb1/notify), which we have saved in the constructor\&. For usage with macro definions, this param must only be readable\&. So there is no setter\&. \fP"
.ti -1c
.RI "\fB~Kb\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBframeRate\fP ()"
.br
.ti -1c
.RI "static void \fBframeRate\fP (int newFrameRate)"
.br
.ti -1c
.RI "static \fBKeyMap::Layout\fP \fBlayout\fP ()"
.br
.ti -1c
.RI "static void \fBlayout\fP (\fBKeyMap::Layout\fP newLayout)"
.br
.ti -1c
.RI "static bool \fBdither\fP ()"
.br
.ti -1c
.RI "static void \fBdither\fP (bool newDither)"
.br
.ti -1c
.RI "static bool \fBmacroDelay\fP ()"
.br
.ti -1c
.RI "static void \fBmacroDelay\fP (bool flag)"
.br
.RI "\fI\fBKb::macroDelay\fP handles the UI-Element macroBox\&. Sends a command to the keyboard to switch on or off the delay function on very large macros\&. \fP"
.ti -1c
.RI "static bool \fBmouseAccel\fP ()"
.br
.ti -1c
.RI "static void \fBmouseAccel\fP (bool newAccel)"
.br
.ti -1c
.RI "static int \fBscrollSpeed\fP ()"
.br
.ti -1c
.RI "static void \fBscrollSpeed\fP (int newSpeed)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "QString \fBusbModel\fP"
.br
.ti -1c
.RI "QString \fBusbSerial\fP"
.br
.ti -1c
.RI "QString \fBfeatures\fP"
.br
.ti -1c
.RI "QString \fBfirmware\fP"
.br
.ti -1c
.RI "QString \fBpollrate\fP"
.br
.ti -1c
.RI "bool \fBmonochrome\fP"
.br
.ti -1c
.RI "int \fBhwModeCount\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBHWMODE_MAX\fP = 3"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBreadNotify\fP (QString line)"
.br
.ti -1c
.RI "void \fBdeleteHw\fP ()"
.br
.ti -1c
.RI "void \fBdeletePrevious\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKb\fP (\fBQObject\fP *parent, const QString &path)"
.br
.ti -1c
.RI "bool \fBisOpen\fP () const "
.br
.ti -1c
.RI "bool \fBmatches\fP (const QString &path, const QString &serial)"
.br
.ti -1c
.RI "void \fBupdateLayout\fP ()"
.br
.ti -1c
.RI "void \fBwriteProfileHeader\fP ()"
.br
.ti -1c
.RI "\fBKeyMap\fP \fBgetKeyMap\fP ()"
.br
.ti -1c
.RI "void \fBrun\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QString \fBdevpath\fP"
.br
.RI "\fIpathVars devpath is the device root path (e\&.g\&. /dev/device/ckb1), cmdpath leads to the daemon input pipe for daemon commands, notifyPath is the standard input monitor for general purpose, macroPath added for a second thread to read macro input\&. \fP"
.ti -1c
.RI "QString \fBcmdpath\fP"
.br
.ti -1c
.RI "QString \fBnotifyPath\fP"
.br
.ti -1c
.RI "QString \fBmacroPath\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fB_currentProfile\fP"
.br
.ti -1c
.RI "QList< \fBKbProfile\fP * > \fB_profiles\fP"
.br
.ti -1c
.RI "\fBKbMode\fP * \fB_currentMode\fP"
.br
.ti -1c
.RI "\fBKeyMap::Model\fP \fB_model\fP"
.br
.ti -1c
.RI "bool \fBiState\fP [\fBKbPerf::HW_I_COUNT\fP]"
.br
.ti -1c
.RI "QString \fBprefsPath\fP"
.br
.ti -1c
.RI "quint64 \fBlastAutoSave\fP"
.br
.ti -1c
.RI "QString \fBfwUpdPath\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fB_hwProfile\fP"
.br
.ti -1c
.RI "\fBKbProfile\fP * \fBprevProfile\fP"
.br
.ti -1c
.RI "\fBKbMode\fP * \fBprevMode\fP"
.br
.ti -1c
.RI "QFile \fBcmd\fP"
.br
.ti -1c
.RI "int \fBnotifyNumber\fP"
.br
.RI "\fInotifyNumber is the trailing number in the device path\&. \fP"
.ti -1c
.RI "int \fBmacroNumber\fP"
.br
.ti -1c
.RI "bool \fB_needsSave\fP"
.br
.ti -1c
.RI "bool \fBhwLoading\fP [\fBHWMODE_MAX\fP+1]"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBKeyMap::Layout\fP \fB_layout\fP = \fBKeyMap::NO_LAYOUT\fP"
.br
.ti -1c
.RI "static int \fB_frameRate\fP = 30"
.br
.ti -1c
.RI "static int \fB_scrollSpeed\fP = 0"
.br
.ti -1c
.RI "static bool \fB_dither\fP = false"
.br
.ti -1c
.RI "static bool \fB_mouseAccel\fP = true"
.br
.ti -1c
.RI "static bool \fB_delay\fP = false"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBKbManager\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 11 of file kb\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Kb::~Kb ()"
<
.PP
\fBTodo\fP
.RS 4
I don't think, that notifypaths is used somewhere\&. So why do we have it? If we do not need it, searching for an ununsed notify channel can easy be refactored to a private member function\&. 
.RE
.PP

.PP
Definition at line 181 of file kb\&.cpp\&.
.PP
References activeDevices, isOpen(), macroPath, notifyNumber, notifyPaths, and save()\&.
.PP
.nf
181        {
182     // Save settings first
183     save();
184 
185     // remove the notify channel from the list of notifyPaths\&.
188     notifyPaths\&.remove(macroPath);
189 
190     // Kill notification thread and remove node
191     activeDevices\&.remove(this);
192     if(!isOpen()){
193         terminate();
194         wait(1000);
195         return;
196     }
197     if(notifyNumber > 0)
198         cmd\&.write(QString("idle\nnotifyoff %1\n")\&.arg(notifyNumber)\&.toLatin1());
199     cmd\&.flush();
200     terminate();
201     wait(1000);
202     cmd\&.close();
203 }
.fi
.SS "Kb::Kb (\fBQObject\fP *parent, const QString &path)\fC [private]\fP"
< Firmware Info is now current fw-number:vendor:model Look for special entries (newest models)
.PP
< perhaps we have found something, perhaps not\&.
.PP
< If nothing found in the special firmware search, try here\&.
.PP
Last chance gone to get a valid firmware information\&.
.PP
Handle inputs
.PP
< This is the normal case if we have a new daemon and a running device
.PP
< That means we have an older daemon which does not write three infos into the file
.PP
<
.PP
\fBTodo\fP
.RS 4
Is adding notify2 to the notifypaths neccessary? 
.RE
.PP

.PP
Definition at line 27 of file kb\&.cpp\&.
.PP
References _delay, _dither, _frameRate, _layout, _model, _mouseAccel, _scrollSpeed, activeDevices, cmdpath, features, firmware, KeyMap::getModel(), hwLoading, hwModeCount, infoUpdated(), KeyMap::isISO(), iState, KeyMap::K95, macroNumber, macroPath, monochrome, KeyMap::NO_MODEL, notifyNumber, notifyPath, notifyPathMutex, notifyPaths, pollrate, prefsPath, usbModel, and usbSerial\&.
.PP
.nf
27                                            :
28     QThread(parent), features("N/A"), firmware("N/A"), pollrate("N/A"), monochrome(false),
29     devpath(path), cmdpath(path + "/cmd"), notifyPath(path + "/notify1"), macroPath(path + "/notify2"),
30     _currentProfile(0), _currentMode(0), _model(KeyMap::NO_MODEL),
31     lastAutoSave(QDateTime::currentMSecsSinceEpoch()),
32     _hwProfile(0), prevProfile(0), prevMode(0),
33     cmd(cmdpath), notifyNumber(1), macroNumber(2), _needsSave(false)
34 {
35     memset(iState, 0, sizeof(iState));
36     memset(hwLoading, 0, sizeof(hwLoading));
37 
38     // Get the features, model, serial number, FW version (if available), and poll rate (if available) from /dev nodes
39     QFile ftpath(path + "/features"), mpath(path + "/model"), spath(path + "/serial"), fwpath(path + "/fwversion"), ppath(path + "/pollrate");
40     if(fwpath\&.open(QIODevice::ReadOnly)){
41         QString fwString = fwpath\&.read(1000);
42         fwString = fwString\&.trimmed();
43         fwpath\&.close();
44         QStringList list = fwString\&.split(":");
45         if(list\&.length() == 3) {    
46             bool okVendor, okProduct;
48             const uint vendor = list[1]\&.toUInt(&okVendor, 16);
49             const uint product = list[2]\&.toUInt(&okProduct, 16);
50             if (okVendor && okProduct) _model = KeyMap::getModel(vendor, product);    
51             qInfo() << "First look for special firmware returned" << _model;
52         } else qWarning() << "Expected 3 entries in file" << fwpath\&.fileName() << "but reading" << list\&.length();
53     }
54     if(ftpath\&.open(QIODevice::ReadOnly)){
55         features = ftpath\&.read(1000);
56         features = features\&.trimmed();
57         ftpath\&.close();
58         // Read model from features (first word: vendor, second word: product)
59         QStringList list = features\&.split(" ");
60         if(list\&.length() < 2)
61             return;
62         if (_model == KeyMap::NO_MODEL) {   
63             _model = KeyMap::getModel(list[1]);
64         }
66         if (_model == KeyMap::NO_MODEL) {
67             qCritical() << "Neither firmware-special-search nor feature file analysis resulted in valid firmware information\&.";
68             return;
69         }
70     } else
71         // Bail if features aren't readable
72         return;
73     if(features\&.contains("monochrome"))
74         monochrome = true;
75     if(mpath\&.open(QIODevice::ReadOnly)){
76         usbModel = mpath\&.read(100);
77         usbModel = usbModel\&.remove("Corsair")\&.remove("Gaming")\&.remove("Keyboard")\&.remove("Mouse")\&.remove("Bootloader")\&.trimmed();
78         mpath\&.close();
79     }
80     if(usbModel == "")
81         usbModel = "Keyboard";
82     if(spath\&.open(QIODevice::ReadOnly)){
83         usbSerial = spath\&.read(100);
84         usbSerial = usbSerial\&.trimmed()\&.toUpper();
85         spath\&.close();
86     }
87     if(usbSerial == "")
88         usbSerial = "Unknown-" + usbModel;
89     if(features\&.contains("fwversion") && fwpath\&.open(QIODevice::ReadOnly)){
90         QString firmwareString = fwpath\&.read(100);
91         fwpath\&.close();
92 
94         QStringList firmwareList = firmwareString\&.remove("\n")\&.split(":");
95         switch (firmwareList\&.length()) {
96         case 3: 
97             qInfo() << "Reading 3 entries from fwversion file, VID=" << firmwareList\&.at(1) << ", PID=" << firmwareList\&.at(2);
98         case 1: 
99             firmware = QString::number(firmwareList\&.at(0)\&.trimmed()\&.toInt() / 100\&., 'f', 2);
100             qInfo() << "Firmware version read from ckb-daemon in fwversion file is" << firmwareList\&.at(0);
101             break;
102         default:
103             qCritical() << "Firware version file is invalid\&. Number of entries is" << firmwareList\&.length();
104             break;
105         }
106     }
107     if(features\&.contains("pollrate") && ppath\&.open(QIODevice::ReadOnly)){
108         pollrate = ppath\&.read(100);
109         pollrate = pollrate\&.trimmed();
110         ppath\&.close();
111     }
112 
113     prefsPath = "Devices/" + usbSerial;
114 
115     hwModeCount = (_model == KeyMap::K95) ? 3 : 1;
116     // Open cmd in non-blocking mode so that it doesn't lock up if nothing is reading
117     // (e\&.g\&. if the daemon crashed and didn't clean up the node)
118     int fd = open(cmdpath\&.toLatin1()\&.constData(), O_WRONLY | O_NONBLOCK);
119     if(!cmd\&.open(fd, QIODevice::WriteOnly, QFileDevice::AutoCloseHandle))
120         return;
121 
122     // Find an available notification node (if none is found, take notify1)
123     {
124         QMutexLocker locker(&notifyPathMutex);
125         for(int i = 1; i < 10; i++){
126             QString notify = QString(path + "/notify%1")\&.arg(i);
127             if(!QFile::exists(notify) && !notifyPaths\&.contains(notify)){
128                 notifyNumber = i;
129                 notifyPath = notify;
130                 break;
131             }
132         }
133         notifyPaths\&.insert(notifyPath);
134     }
135     cmd\&.write(QString("notifyon %1\n")\&.arg(notifyNumber)\&.toLatin1());
136     cmd\&.flush();
137 
138     // Again, find an available notification node for macro definition
139     // (if none is found, take notify2)
140     {
141         QMutexLocker locker(&notifyPathMutex);
142         for(int i = 1; i < 10; i++){
143             QString notify = QString(path + "/notify%1")\&.arg(i);
144             if(!QFile::exists(notify) && !notifyPaths\&.contains(notify)){
145                 macroNumber = i;
146                 macroPath = notify;
147                 break;
148             }
149         }
150         notifyPaths\&.insert(notifyPath); 
151     }
152     // Activate device, apply settings, and ask for hardware profile
153     cmd\&.write(QString("fps %1\n")\&.arg(_frameRate)\&.toLatin1());
154     cmd\&.write(QString("dither %1\n")\&.arg(static_cast<int>(_dither))\&.toLatin1());
155     cmd\&.write(QString("\ndelay %1\n")\&.arg(_delay? "on" : "off")\&.toLatin1());
156 #ifdef Q_OS_MACX
157     // Write ANSI/ISO flag to daemon (OSX only)
158     cmd\&.write("layout ");
159     cmd\&.write(KeyMap::isISO(_layout) ? "iso" : "ansi");
160     // Also OSX only: scroll speed and mouse acceleration
161     cmd\&.write(QString("accel %1\n")\&.arg(QString(_mouseAccel ? "on" : "off"))\&.toLatin1());
162     cmd\&.write(QString("scrollspeed %1\n")\&.arg(_scrollSpeed)\&.toLatin1());
163 #endif
164     cmd\&.write(QString("\nactive\n@%1 get :hwprofileid")\&.arg(notifyNumber)\&.toLatin1());
165     hwLoading[0] = true;
166     for(int i = 0; i < hwModeCount; i++){
167         cmd\&.write(QString(" mode %1 get :hwid")\&.arg(i + 1)\&.toLatin1());
168         hwLoading[i + 1] = true;
169     }
170     // Ask for current indicator and key state
171     cmd\&.write(" get :i :keys\n");
172     cmd\&.flush();
173 
174     emit infoUpdated();
175     activeDevices\&.insert(this);
176 
177     // Start a separate thread to read from the notification node
178     start();
179 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Kb::appendProfile (\fBKbProfile\fP *newProfile)\fC [inline]\fP"

.PP
Definition at line 60 of file kb\&.h\&.
.PP
References _needsSave, and _profiles\&.
.PP
Referenced by KbProfileDialog::on_profileList_itemClicked()\&.
.PP
.nf
60 { _needsSave = true; _profiles\&.append(newProfile); }
.fi
.SS "void Kb::autoSave ()\fC [slot]\fP"

.PP
Definition at line 329 of file kb\&.cpp\&.
.PP
References CkbSettings::isBusy(), lastAutoSave, needsSave(), and save()\&.
.PP
.nf
329                  {
330     quint64 now = QDateTime::currentMSecsSinceEpoch();
331     if(needsSave() && now >= lastAutoSave + 15 * 1000 && !CkbSettings::isBusy()){
332         save();
333         lastAutoSave = now;
334     }
335 }
.fi
.SS "\fBKbBind\fP* Kb::currentBind ()\fC [inline]\fP"

.PP
Definition at line 67 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::bind()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
67 { return !_currentMode ? 0 : _currentMode->bind(); }
.fi
.SS "\fBKbLight\fP* Kb::currentLight ()\fC [inline]\fP"

.PP
Definition at line 66 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::light()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
66 { return !_currentMode ? 0 : _currentMode->light(); }
.fi
.SS "\fBKbMode\fP* Kb::currentMode ()\fC [inline]\fP"

.PP
Definition at line 65 of file kb\&.h\&.
.PP
References _currentMode\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
65 { return _currentMode; }
.fi
.SS "\fBKbPerf\fP* Kb::currentPerf ()\fC [inline]\fP"

.PP
Definition at line 68 of file kb\&.h\&.
.PP
References _currentMode, and KbMode::perf()\&.
.PP
Referenced by KbWidget::modeChanged()\&.
.PP
.nf
68 { return !_currentMode ? 0 : _currentMode->perf(); }
.fi
.SS "\fBKbProfile\fP* Kb::currentProfile ()\fC [inline]\fP"

.PP
Definition at line 56 of file kb\&.h\&.
.PP
References _currentProfile\&.
.PP
Referenced by KeyAction::keyEvent(), KbWidget::modeChanged(), KbWidget::modeIcon(), KbWidget::modesList_reordered(), KbWidget::on_modesList_currentItemChanged(), KbWidget::on_modesList_customContextMenuRequested(), KbWidget::on_modesList_itemClicked(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemChanged(), KbWidget::profileChanged(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
56 { return _currentProfile; }
.fi
.SS "void Kb::deleteHw ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 481 of file kb\&.cpp\&.
.PP
References _hwProfile\&.
.PP
Referenced by hwProfile()\&.
.PP
.nf
481                  {
482     disconnect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
483     _hwProfile = 0;
484 }
.fi
.SS "void Kb::deletePrevious ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 466 of file kb\&.cpp\&.
.PP
References prevMode\&.
.PP
Referenced by frameUpdate(), and hwSave()\&.
.PP
.nf
466                        {
467     disconnect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
468     prevMode = 0;
469 }
.fi
.SS "static bool Kb::dither ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 33 of file kb\&.h\&.
.PP
References _dither\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_ditherBox_clicked()\&.
.PP
.nf
33 { return _dither; }
.fi
.SS "void Kb::dither (boolnewDither)\fC [static]\fP"

.PP
Definition at line 244 of file kb\&.cpp\&.
.PP
References _dither, activeDevices, and cmd\&.
.PP
.nf
244                              {
245     if(newDither == _dither)
246         return;
247     _dither = newDither;
248     // Update all devices
249     foreach(Kb* kb, activeDevices){
250         kb->cmd\&.write(QString("dither %1\n")\&.arg(static_cast<int>(newDither))\&.toLatin1());
251         kb->cmd\&.flush();
252     }
253 }
.fi
.SS "\fBKbProfile\fP* Kb::find (const QUuid &id)\fC [inline]\fP"

.PP
Definition at line 62 of file kb\&.h\&.
.PP
References _profiles, UsbId::guid, and KbProfile::id()\&.
.PP
Referenced by KbProfileDialog::on_profileList_currentItemChanged(), KbProfileDialog::on_profileList_customContextMenuRequested(), and KbProfileDialog::profileList_reordered()\&.
.PP
.nf
62 { foreach(KbProfile* profile, _profiles) { if(profile->id()\&.guid == id) return profile; } return 0; }
.fi
.SS "static int Kb::frameRate ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 27 of file kb\&.h\&.
.PP
References _frameRate\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_fpsBox_valueChanged()\&.
.PP
.nf
27 { return _frameRate; }
.fi
.SS "void Kb::frameRate (intnewFrameRate)\fC [static]\fP"

.PP
Definition at line 205 of file kb\&.cpp\&.
.PP
References _frameRate, activeDevices, cmd, and KbManager::fps()\&.
.PP
.nf
205                                   {
206     KbManager::fps(newFrameRate);
207     // If the rate has changed, send to all devices
208     if(newFrameRate == _frameRate)
209         return;
210     _frameRate = newFrameRate;
211     foreach(Kb* kb, activeDevices){
212         kb->cmd\&.write(QString("fps %1\n")\&.arg(newFrameRate)\&.toLatin1());
213         kb->cmd\&.flush();
214     }
215 }
.fi
.SS "void Kb::frameUpdate ()\fC [slot]\fP"

.PP
Definition at line 415 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, KbPerf::applyIndicators(), KbMode::bind(), KbLight::close(), deletePrevious(), KbLight::frameUpdate(), KbProfile::indexOf(), KbLight::isStarted(), iState, KbMode::light(), monochrome, notifyNumber, KbLight::open(), KbMode::perf(), prevMode, prevProfile, KbBind::update(), KbPerf::update(), and writeProfileHeader()\&.
.PP
.nf
415                     {
416     // Advance animation frame
417     if(!_currentMode)
418         return;
419     KbLight* light = _currentMode->light();
420     KbBind* bind = _currentMode->bind();
421     KbPerf* perf = _currentMode->perf();
422     if(!light->isStarted()){
423         // Don't do anything until the animations are started
424         light->open();
425         return;
426     }
427 
428     // Stop animations on the previously active mode (if any)
429     bool changed = false;
430     if(prevMode != _currentMode){
431         if(prevMode){
432             prevMode->light()->close();
433             disconnect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
434         }
435         prevMode = _currentMode;
436         connect(prevMode, SIGNAL(destroyed()), this, SLOT(deletePrevious()));
437         changed = true;
438     }
439 
440     // If the profile has changed, update it
441     if(prevProfile != _currentProfile){
442         writeProfileHeader();
443         cmd\&.write(" ");
444         prevProfile = _currentProfile;
445     }
446 
447     // Update current mode
448     int index = _currentProfile->indexOf(_currentMode);
449     // ckb-daemon only has 6 modes: 3 hardware, 3 non-hardware\&. Beyond mode six, switch back to four\&.
450     // e\&.g\&. 1, 2, 3, 4, 5, 6, 4, 5, 6, 4, 5, 6 \&.\&.\&.
451     if(index >= 6)
452         index = 3 + index % 3;
453 
454     // Send lighting/binding to driver
455     cmd\&.write(QString("mode %1 switch ")\&.arg(index + 1)\&.toLatin1());
456     perf->applyIndicators(index, iState);
457     light->frameUpdate(cmd, monochrome);
458     cmd\&.write(QString("\n@%1 ")\&.arg(notifyNumber)\&.toLatin1());
459     bind->update(cmd, changed);
460     cmd\&.write(" ");
461     perf->update(cmd, changed);
462     cmd\&.write("\n");
463     cmd\&.flush();
464 }
.fi
.SS "void Kb::fwUpdate (const QString &path)"

.PP
Definition at line 405 of file kb\&.cpp\&.
.PP
References fwUpdPath, and notifyNumber\&.
.PP
Referenced by FwUpgradeDialog::on_actionButton_clicked()\&.
.PP
.nf
405                                     {
406     fwUpdPath = path;
407     // Write the active command to ensure it's not ignored
408     cmd\&.write("active");
409     cmd\&.write(QString(" @%1 ")\&.arg(notifyNumber)\&.toLatin1());
410     cmd\&.write("fwupdate ");
411     cmd\&.write(path\&.toLatin1());
412     cmd\&.write("\n");
413 }
.fi
.SS "void Kb::fwUpdateFinished (boolsucceeded)\fC [signal]\fP"

.PP
Definition at line 277 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
278 {
279     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
280     QMetaObject::activate(this, &staticMetaObject, 7, _a);
281 }
.fi
.SS "void Kb::fwUpdateProgress (intcurrent, inttotal)\fC [signal]\fP"

.PP
Definition at line 270 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
271 {
272     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
273     QMetaObject::activate(this, &staticMetaObject, 6, _a);
274 }
.fi
.SS "\fBKeyMap\fP Kb::getKeyMap ()\fC [private]\fP"

.PP
Definition at line 796 of file kb\&.cpp\&.
.PP
References _layout\&.
.PP
Referenced by hwSave(), load(), newMode(), newProfile(), readNotify(), setCurrentProfile(), and updateLayout()\&.
.PP
.nf
796                     {
797     return KeyMap(_model, _layout);
798 }
.fi
.SS "int Kb::getMacroNumber ()\fC [inline]\fP"
getMacroNumber returns the macroNumber, which we have saved in the constructor\&. For usage with macro definions, this param must only be readable\&. So there is no setter\&. 
.PP
\fBReturns:\fP
.RS 4
The Number is returned as int\&. 
.RE
.PP

.PP
Definition at line 97 of file kb\&.h\&.
.PP
References macroNumber\&.
.PP
Referenced by KbBind::getMacroNumber()\&.
.PP
.nf
97 { return macroNumber; }
.fi
.SS "QString Kb::getMacroPath ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
The absolute path as String 
.RE
.PP

.PP
Definition at line 106 of file kb\&.h\&.
.PP
References macroPath\&.
.PP
Referenced by KbBind::getMacroPath()\&.
.PP
.nf
106 { return macroPath; }
.fi
.SS "\fBKbProfile\fP* Kb::hwProfile ()\fC [inline]\fP"

.PP
Definition at line 46 of file kb\&.h\&.
.PP
References _hwProfile\&.
.PP
Referenced by hwSave(), KbWidget::modeIcon(), KbProfileDialog::on_profileList_customContextMenuRequested(), readNotify(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
46 { return _hwProfile; }
.fi
.SS "void Kb::hwProfile (\fBKbProfile\fP *newHwProfile)"

.PP
Definition at line 471 of file kb\&.cpp\&.
.PP
References _hwProfile, and deleteHw()\&.
.PP
.nf
471                                          {
472     if(_hwProfile == newHwProfile)
473         return;
474     if(_hwProfile)
475         disconnect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
476     _hwProfile = newHwProfile;
477     if(_hwProfile)
478         connect(_hwProfile, SIGNAL(destroyed()), this, SLOT(deleteHw()));
479 }
.fi
.SS "void Kb::hwSave ()"

.PP
Definition at line 337 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _hwProfile, KbProfile::append(), KbLight::base(), KbLight::close(), deletePrevious(), getKeyMap(), UsbId::guidString(), hwModeCount, UsbId::hwModified, hwProfile(), KbProfile::id(), KbMode::id(), KbMode::light(), KbProfile::modeCount(), KbProfile::modes(), UsbId::modified, UsbId::modifiedString(), monochrome, KbMode::name(), KbMode::perf(), prevMode, KbProfile::setNeedsSave(), KbMode::setNeedsSave(), KbPerf::update(), and writeProfileHeader()\&.
.PP
Referenced by KbWidget::on_hwSaveButton_clicked(), and KbProfileDialog::on_profileList_customContextMenuRequested()\&.
.PP
.nf
337                {
338     if(!_currentProfile)
339         return;
340     // Close active lighting (if any)
341     if(prevMode){
342         prevMode->light()->close();
343         deletePrevious();
344     }
345     hwProfile(_currentProfile);
346     _hwProfile->id()\&.hwModified = _hwProfile->id()\&.modified;
347     _hwProfile->setNeedsSave();
348     // Re-send the current profile from scratch to ensure consistency
349     writeProfileHeader();
350     // Make sure there are enough modes
351     while(_currentProfile->modeCount() < hwModeCount)
352         _currentProfile->append(new KbMode(this, getKeyMap()));
353     // Write only the base colors of each mode, no animations
354     for(int i = 0; i < hwModeCount; i++){
355         KbMode* mode = _currentProfile->modes()[i];
356         cmd\&.write(QString("\nmode %1")\&.arg(i + 1)\&.toLatin1());
357         KbLight* light = mode->light();
358         KbPerf* perf = mode->perf();
359         if(mode == _currentMode)
360             cmd\&.write(" switch");
361         // Write the mode name and ID
362         cmd\&.write(" name ");
363         cmd\&.write(QUrl::toPercentEncoding(mode->name()));
364         cmd\&.write(" id ");
365         cmd\&.write(mode->id()\&.guidString()\&.toLatin1());
366         cmd\&.write(" ");
367         cmd\&.write(mode->id()\&.modifiedString()\&.toLatin1());
368         cmd\&.write(" ");
369         // Write lighting and performance
370         light->base(cmd, true, monochrome);
371         cmd\&.write(" ");
372         perf->update(cmd, true, false);
373         // Update mode ID
374         mode->id()\&.hwModified = mode->id()\&.modified;
375         mode->setNeedsSave();
376     }
377     cmd\&.write("\n");
378 
379     // Save the profile to memory
380     cmd\&.write("hwsave\n");
381     cmd\&.flush();
382 }
.fi
.SS "int Kb::indexOf (\fBKbProfile\fP *profile)\fC [inline]\fP"

.PP
Definition at line 61 of file kb\&.h\&.
.PP
References _profiles\&.
.PP
Referenced by KbProfileDialog::on_profileList_customContextMenuRequested()\&.
.PP
.nf
61 { return _profiles\&.indexOf(profile); }
.fi
.SS "void Kb::infoUpdated ()\fC [signal]\fP"

.PP
Definition at line 233 of file moc_kb\&.cpp\&.
.PP
Referenced by Kb(), load(), and updateLayout()\&.
.PP
.nf
234 {
235     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
236 }
.fi
.SS "bool Kb::isKeyboard () const\fC [inline]\fP"

.PP
Definition at line 23 of file kb\&.h\&.
.PP
References KeyMap::isKeyboard()\&.
.PP
Referenced by KbWidget::KbWidget()\&.
.PP
.nf
23 { return KeyMap::isKeyboard(_model); }
.fi
.SS "bool Kb::isMouse () const\fC [inline]\fP"

.PP
Definition at line 24 of file kb\&.h\&.
.PP
References KeyMap::isMouse()\&.
.PP
Referenced by KbWidget::KbWidget(), and readNotify()\&.
.PP
.nf
24 { return KeyMap::isMouse(_model); }
.fi
.SS "bool Kb::isOpen () const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 147 of file kb\&.h\&.
.PP
Referenced by KbManager::scanKeyboards(), and ~Kb()\&.
.PP
.nf
147 { return cmd\&.isOpen(); }
.fi
.SS "static \fBKeyMap::Layout\fP Kb::layout ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 30 of file kb\&.h\&.
.PP
References _layout\&.
.PP
Referenced by LayoutDialog::LayoutDialog(), SettingsWidget::on_layoutBox_activated(), and SettingsWidget::SettingsWidget()\&.
.PP
.nf
30 { return _layout; }
.fi
.SS "void Kb::layout (\fBKeyMap::Layout\fPnewLayout)\fC [static]\fP"

.PP
Definition at line 217 of file kb\&.cpp\&.
.PP
References _layout, activeDevices, KeyMap::NO_LAYOUT, and updateLayout()\&.
.PP
.nf
217                                      {
218     if(newLayout == KeyMap::NO_LAYOUT || newLayout == _layout)
219         return;
220     _layout = newLayout;
221     // Update all devices
222     foreach(Kb* kb, activeDevices)
223         kb->updateLayout();
224 }
.fi
.SS "void Kb::load ()"

.PP
Definition at line 281 of file kb\&.cpp\&.
.PP
References _needsSave, _profiles, current, getKeyMap(), infoUpdated(), prefsPath, profileAdded(), setCurrentProfile(), and CkbSettings::value()\&.
.PP
Referenced by KbManager::scanKeyboards()\&.
.PP
.nf
281              {
282     if(prefsPath\&.isEmpty())
283         return;
284     _needsSave = false;
285     CkbSettings settings(prefsPath);
286     // Read profiles
287     KbProfile* newCurrentProfile = 0;
288     QString current = settings\&.value("CurrentProfile")\&.toString()\&.trimmed()\&.toUpper();
289     foreach(QString guid, settings\&.value("Profiles")\&.toString()\&.split(" ")){
290         guid = guid\&.trimmed()\&.toUpper();
291         if(guid != ""){
292             KbProfile* profile = new KbProfile(this, getKeyMap(), settings, guid);
293             _profiles\&.append(profile);
294             if(guid == current || !newCurrentProfile)
295                 newCurrentProfile = profile;
296         }
297     }
298     if(newCurrentProfile)
299         setCurrentProfile(newCurrentProfile);
300     else {
301         // If nothing was loaded, load the demo profile
302         QSettings demoSettings(":/txt/demoprofile\&.conf", QSettings::IniFormat, this);
303         CkbSettings cSettings(demoSettings);
304         KbProfile* demo = new KbProfile(this, getKeyMap(), cSettings, "{BA7FC152-2D51-4C26-A7A6-A036CC93D924}");
305         _profiles\&.append(demo);
306         setCurrentProfile(demo);
307     }
308 
309     emit infoUpdated();
310     emit profileAdded();
311 }
.fi
.SS "static bool Kb::macroDelay ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 36 of file kb\&.h\&.
.PP
References _delay\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_delayBox_clicked()\&.
.PP
.nf
36 { return _delay; }
.fi
.SS "void Kb::macroDelay (boolflag)\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIflag\fP true: Switch on delay function, else switch off 
.RE
.PP

.PP
Definition at line 827 of file kb\&.cpp\&.
.PP
References _delay, activeDevices, and cmd\&.
.PP
.nf
827                              {
828    _delay = flag;
829 
830    foreach(Kb* kb, activeDevices){
831        kb->cmd\&.write(QString("\ndelay %1\n")\&.arg(flag? "on" : "off")\&.toLatin1());
832    }
833 }
.fi
.SS "bool Kb::matches (const QString &path, const QString &serial)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 157 of file kb\&.h\&.
.PP
References devpath, and usbSerial\&.
.PP
Referenced by KbManager::scanKeyboards()\&.
.PP
.nf
157 { return path\&.trimmed() == devpath\&.trimmed() && usbSerial == serial\&.trimmed()\&.toUpper(); }
.fi
.SS "void Kb::modeChanged (boolspontaneous)\fC [signal]\fP"

.PP
Definition at line 263 of file moc_kb\&.cpp\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
264 {
265     void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
266     QMetaObject::activate(this, &staticMetaObject, 5, _a);
267 }
.fi
.SS "\fBKeyMap::Model\fP Kb::model () const\fC [inline]\fP"

.PP
Definition at line 22 of file kb\&.h\&.
.PP
References _model\&.
.PP
.nf
22 { return _model; }
.fi
.SS "void Kb::modeRenamed ()\fC [signal]\fP"

.PP
Definition at line 251 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
252 {
253     QMetaObject::activate(this, &staticMetaObject, 3, Q_NULLPTR);
254 }
.fi
.SS "static bool Kb::mouseAccel ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 39 of file kb\&.h\&.
.PP
References _mouseAccel\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), and ExtraSettingsWidget::on_mAccelBox_clicked()\&.
.PP
.nf
39 { return _mouseAccel; }
.fi
.SS "void Kb::mouseAccel (boolnewAccel)\fC [static]\fP"

.PP
Definition at line 255 of file kb\&.cpp\&.
.PP
References _mouseAccel, activeDevices, and cmd\&.
.PP
.nf
255                                 {
256     if(newAccel == _mouseAccel)
257         return;
258     _mouseAccel = newAccel;
259 #ifdef Q_OS_MACX
260     // Update all devices
261     foreach(Kb* kb, activeDevices){
262         kb->cmd\&.write(QString("accel %1\n")\&.arg(QString(newAccel ? "on" : "off"))\&.toLatin1());
263         kb->cmd\&.flush();
264     }
265 #endif
266 }
.fi
.SS "bool Kb::needsSave () const"

.PP
Definition at line 384 of file kb\&.cpp\&.
.PP
References _needsSave, _profiles, and KbProfile::needsSave()\&.
.PP
Referenced by autoSave()\&.
.PP
.nf
384                          {
385     if(_needsSave)
386         return true;
387     foreach(const KbProfile* profile, _profiles){
388         if(profile->needsSave())
389             return true;
390     }
391     return false;
392 }
.fi
.SS "\fBKbMode\fP* Kb::newMode ()\fC [inline]\fP"

.PP
Definition at line 79 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
Referenced by KbWidget::on_modesList_customContextMenuRequested(), and KbWidget::on_modesList_itemClicked()\&.
.PP
.nf
79 { return new KbMode(this, getKeyMap()); }
.fi
.SS "\fBKbMode\fP* Kb::newMode (\fBKbMode\fP *other)\fC [inline]\fP"

.PP
Definition at line 80 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
.nf
80 { return new KbMode(this, getKeyMap(), *other); }
.fi
.SS "\fBKbProfile\fP* Kb::newProfile ()\fC [inline]\fP"

.PP
Definition at line 77 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
Referenced by KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemClicked(), and readNotify()\&.
.PP
.nf
77 { return new KbProfile(this, getKeyMap()); }
.fi
.SS "\fBKbProfile\fP* Kb::newProfile (\fBKbProfile\fP *other)\fC [inline]\fP"

.PP
Definition at line 78 of file kb\&.h\&.
.PP
References getKeyMap()\&.
.PP
.nf
78 { return new KbProfile(this, getKeyMap(), *other); }
.fi
.SS "void Kb::profileAdded ()\fC [signal]\fP"

.PP
Definition at line 239 of file moc_kb\&.cpp\&.
.PP
Referenced by load(), and readNotify()\&.
.PP
.nf
240 {
241     QMetaObject::activate(this, &staticMetaObject, 1, Q_NULLPTR);
242 }
.fi
.SS "void Kb::profileChanged ()\fC [signal]\fP"

.PP
Definition at line 257 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify(), and setCurrentMode()\&.
.PP
.nf
258 {
259     QMetaObject::activate(this, &staticMetaObject, 4, Q_NULLPTR);
260 }
.fi
.SS "void Kb::profileRenamed ()\fC [signal]\fP"

.PP
Definition at line 245 of file moc_kb\&.cpp\&.
.PP
Referenced by readNotify()\&.
.PP
.nf
246 {
247     QMetaObject::activate(this, &staticMetaObject, 2, Q_NULLPTR);
248 }
.fi
.SS "const QList<\fBKbProfile\fP*>& Kb::profiles () const\fC [inline]\fP"

.PP
Definition at line 58 of file kb\&.h\&.
.PP
References _profiles\&.
.PP
Referenced by KbWidget::on_profileBox_activated(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::profileList_reordered(), KbProfileDialog::repopulate(), and KbWidget::updateProfileList()\&.
.PP
.nf
58 { return _profiles; }
.fi
.SS "void Kb::profiles (const QList< \fBKbProfile\fP * > &newProfiles)\fC [inline]\fP"

.PP
Definition at line 59 of file kb\&.h\&.
.PP
References _needsSave, and _profiles\&.
.PP
.nf
59 { _needsSave = true; _profiles = newProfiles; }
.fi
.SS "void Kb::readNotify (QStringline)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 511 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _hwProfile, _needsSave, _profiles, KbPerf::angleSnap(), KbLight::animKeypress(), KbProfile::append(), KbMode::bind(), KbLight::color(), KbPerf::curDpiIdx(), KbPerf::dpi(), KbPerf::DPI_COUNT, KbPerf::dpiColor(), KbPerf::dpiEnabled(), fwUpdateFinished(), fwUpdateProgress(), fwUpdPath, getKeyMap(), UsbId::guid, hwLoading, HWMODE_MAX, hwModeCount, UsbId::hwModifiedString(), hwProfile(), KbProfile::id(), KbMode::id(), KbProfile::indexOf(), isMouse(), iState, KbBind::keyEvent(), KbPerf::liftHeight(), KbMode::light(), KbProfile::modeCount(), modeRenamed(), KbProfile::modes(), UsbId::modifiedString(), KbProfile::move(), KbProfile::name(), KbMode::name(), newProfile(), notifyNumber, KbMode::perf(), profileAdded(), profileChanged(), profileRenamed(), setCurrentProfile(), KbProfile::setNeedsSave(), KbMode::setNeedsSave(), x, and y\&.
.PP
.nf
511                                {
512     QStringList components = line\&.trimmed()\&.split(" ");
513     if(components\&.count() < 2)
514         return;
515     if(components[0] == "key"){
516         // Key event
517         QString key = components[1];
518         if(key\&.length() < 2)
519             return;
520         QString keyName = key\&.mid(1);
521         bool keyPressed = (key[0] == '+');
522         KbMode* mode = _currentMode;
523         if(mode){
524             mode->light()->animKeypress(keyName, keyPressed);
525             mode->bind()->keyEvent(keyName, keyPressed);
526         }
527     } else if(components[0] == "i"){
528         // Indicator event
529         QString i = components[1];
530         if(i\&.length() < 2)
531             return;
532         QString iName = i\&.mid(1);
533         bool on = (i[0] == '+');
534         if(iName == "num")
535             iState[0] = on;
536         else if(iName == "caps")
537             iState[1] = on;
538         else if(iName == "scroll")
539             iState[2] = on;
540     } else if(components[0] == "hwprofileid"){
541         // Hardware profile ID
542         if(components\&.count() < 3)
543             return;
544         // Find the hardware profile in the list of profiles
545         QString guid = components[1];
546         QString modified = components[2];
547         KbProfile* newProfile = 0;
548         foreach(KbProfile* profile, _profiles){
549             if(profile->id()\&.guid == guid){
550                 newProfile = profile;
551                 break;
552             }
553         }
554         // If it wasn't found, create it
555         if(!newProfile){
556             newProfile = new KbProfile(this, getKeyMap(), guid, modified);
557             hwLoading[0] = true;
558             cmd\&.write(QString("@%1 get :hwprofilename\n")\&.arg(notifyNumber)\&.toLatin1());
559             cmd\&.flush();
560         } else {
561             // If it's been updated, fetch its name
562             if(newProfile->id()\&.hwModifiedString() != modified){
563                 newProfile->id()\&.modifiedString(modified);
564                 newProfile->id()\&.hwModifiedString(modified);
565                 newProfile->setNeedsSave();
566                 if(hwLoading[0]){
567                     cmd\&.write(QString("@%1 get :hwprofilename\n")\&.arg(notifyNumber)\&.toLatin1());
568                     cmd\&.flush();
569                 }
570             } else {
571                 hwLoading[0] = false;
572             }
573         }
574         hwProfile(newProfile);
575         emit profileAdded();
576         if(_hwProfile == _currentProfile)
577             emit profileChanged();
578     } else if(components[0] == "hwprofilename"){
579         // Hardware profile name
580         QString name = QUrl::fromPercentEncoding(components[1]\&.toUtf8());
581         if(!_hwProfile || !hwLoading[0])
582             return;
583         QString oldName = _hwProfile->name();
584         if(!(oldName\&.length() >= name\&.length() && oldName\&.left(name\&.length()) == name)){
585             // Don't change the name if it's a truncated version of what we already have
586             _hwProfile->name(name);
587             emit profileRenamed();
588         }
589     } else if(components[0] == "mode"){
590         // Mode-specific data
591         if(components\&.count() < 4)
592             return;
593         int mode = components[1]\&.toInt() - 1;
594         if(components[2] == "hwid"){
595             if(components\&.count() < 5 || mode >= HWMODE_MAX || !_hwProfile)
596                 return;
597             // Hardware mode ID
598             QString guid = components[3];
599             QString modified = components[4];
600             // Look for this mode in the hardware profile
601             KbMode* hwMode = 0;
602             bool isUpdated = false;
603             foreach(KbMode* kbMode, _hwProfile->modes()){
604                 if(kbMode->id()\&.guid == guid){
605                     hwMode = kbMode;
606                     if(kbMode->id()\&.hwModifiedString() != modified){
607                         // Update modification time
608                         hwMode->id()\&.modifiedString(modified);
609                         hwMode->id()\&.hwModifiedString(modified);
610                         hwMode->setNeedsSave();
611                         isUpdated = true;
612                     } else {
613                         hwLoading[mode + 1] = false;
614                     }
615                     break;
616                 }
617             }
618             // If it wasn't found, add it
619             if(!hwMode){
620                 isUpdated = true;
621                 hwMode = new KbMode(this, getKeyMap(), guid, modified);
622                 _hwProfile->append(hwMode);
623                 // If the hardware profile now contains enough modes to be added to the list, do so
624                 if(!_profiles\&.contains(_hwProfile) && _hwProfile->modeCount() >= hwModeCount){
625                     _profiles\&.append(_hwProfile);
626                     _needsSave = true;
627                     emit profileAdded();
628                     if(!_currentProfile)
629                         setCurrentProfile(_hwProfile);
630                 }
631             }
632             if(hwLoading[mode + 1] && isUpdated){
633                 // If the mode isn't in the right place, move it
634                 int index = _hwProfile->indexOf(hwMode);
635                 if(mode < _hwProfile->modeCount() && index != mode)
636                     _hwProfile->move(index, mode);
637                 // Fetch the updated data
638                 cmd\&.write(QString("@%1 mode %2 get :hwname :hwrgb")\&.arg(notifyNumber)\&.arg(mode + 1)\&.toLatin1());
639                 if(isMouse())
640                     cmd\&.write(" :hwdpi :hwdpisel :hwlift :hwsnap");
641                 cmd\&.write("\n");
642                 cmd\&.flush();
643             }
644         } else if(components[2] == "hwname"){
645             // Mode name - update list
646             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
647                 return;
648             KbMode* hwMode = _hwProfile->modes()[mode];
649             QString name = QUrl::fromPercentEncoding(components[3]\&.toUtf8());
650             QString oldName = hwMode->name();
651             if(!(oldName\&.length() >= name\&.length() && oldName\&.left(name\&.length()) == name)){
652                 // Don't change the name if it's a truncated version of what we already have
653                 hwMode->name(name);
654                 if(_hwProfile == _currentProfile)
655                     emit modeRenamed();
656             }
657         } else if(components[2] == "hwrgb"){
658             // RGB - set mode lighting
659             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
660                 return;
661             KbMode* kbmode = _hwProfile->modes()[mode];
662             KbLight* light = kbmode->light();
663             // Scan the input for colors
664             QColor lightColor = QColor();
665             for(int i = 3; i < components\&.count(); i++){
666                 QString comp = components[i];
667                 if(comp\&.indexOf(":") < 0){
668                     // No ":" - single hex constant
669                     bool ok;
670                     int rgb = comp\&.toInt(&ok, 16);
671                     if(ok)
672                         light->color(QColor::fromRgb((QRgb)rgb));
673                 } else {
674                     // List of keys ("a,b:xxxxxx")\&. Parse color first
675                     QStringList set = comp\&.split(":");
676                     bool ok;
677                     int rgb = set[1]\&.toInt(&ok, 16);
678                     if(ok){
679                         QColor color = QColor::fromRgb((QRgb)rgb);
680                         // Parse keys
681                         QStringList keys = set[0]\&.split(",");
682                         foreach(QString key, keys){
683                             if(key == "light")
684                                 // Extrapolate the Light key to the M-keys and Lock key, since those will be set to black on hwsave
685                                 lightColor = color;
686                             if(key\&.startsWith("dpi") && key\&.length() > 3){
687                                 // DPI levels go to the KbPerf object instead of KbLight
688                                 bool ok = false;
689                                 int index = key\&.mid(3)\&.toInt(&ok);
690                                 if(ok)
691                                     kbmode->perf()->dpiColor(index, color);
692                                 continue;
693                             }
694                             light->color(key, color);
695                         }
696                     }
697                 }
698             }
699             if(lightColor\&.isValid()){
700                 light->color("mr", lightColor);
701                 light->color("m1", lightColor);
702                 light->color("m2", lightColor);
703                 light->color("m3", lightColor);
704                 light->color("lock", lightColor);
705             }
706         } else if(components[2] == "hwdpi"){
707             // DPI settings
708             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
709                 return;
710             KbPerf* perf = _hwProfile->modes()[mode]->perf();
711             // Read the rest of the line as stage:x,y
712             foreach(QString comp, components\&.mid(3)){
713                 QStringList dpi = comp\&.split(':');
714                 if(dpi\&.length() != 2)
715                     continue;
716                 QStringList xy = dpi[1]\&.split(',');
717                 int x, y;
718                 bool off = false;
719                 if(xy\&.length() < 2){
720                     // If the right side only has one parameter, set both X and Y
721                     if(xy[0] == "off")
722                         off = true;
723                     else
724                         x = y = xy[0]\&.toInt();
725                 } else {
726                     x = xy[0]\&.toInt();
727                     y = xy[1]\&.toInt();
728                 }
729                 // Set DPI for this stage
730                 int index = dpi[0]\&.toInt();
731                 if(off){
732                     perf->dpiEnabled(index, false);
733                     // If all DPIs have been disabled, turn them back on
734                     bool allOff = true;
735                     for(int i = 1; i < KbPerf::DPI_COUNT; i++){
736                         if(perf->dpiEnabled(i)){
737                             allOff = false;
738                             break;
739                         }
740                     }
741                     if(allOff){
742                         for(int i = 1; i < KbPerf::DPI_COUNT; i++)
743                             perf->dpiEnabled(i, true);
744                     }
745                 } else {
746                     perf->dpiEnabled(index, true);
747                     perf->dpi(index, QPoint(x, y));
748                 }
749             }
750         } else if(components[2] == "hwdpisel"){
751             // Hardware DPI selection (0\&.\&.\&.5)
752             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
753                 return;
754             KbPerf* perf = _hwProfile->modes()[mode]->perf();
755             int idx = components[3]\&.toInt();
756             if(idx < 1)
757                 idx = 1;
758             if(idx >= KbPerf::DPI_COUNT)
759                 idx = KbPerf::DPI_COUNT - 1;
760             perf->curDpiIdx(idx);
761         } else if(components[2] == "hwlift"){
762             // Mouse lift height (1\&.\&.\&.5)
763             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
764                 return;
765             KbPerf* perf = _hwProfile->modes()[mode]->perf();
766             perf->liftHeight((KbPerf::height)components[3]\&.toInt());
767         } else if(components[3] == "hwsnap"){
768             // Mouse angle snapping ("on" or "off")
769             if(!_hwProfile || _hwProfile->modeCount() <= mode || mode >= HWMODE_MAX || !hwLoading[mode + 1])
770                 return;
771             KbPerf* perf = _hwProfile->modes()[mode]->perf();
772             perf->angleSnap(components[3] == "on");
773         }
774     } else if(components[0] == "fwupdate"){
775         // Firmware update progress
776         if(components\&.count() < 3)
777             return;
778         // Make sure path is the same
779         if(components[1] != fwUpdPath)
780             return;
781         QString res = components[2];
782         if(res == "invalid" || res == "fail")
783             emit fwUpdateFinished(false);
784         else if(res == "ok")
785             emit fwUpdateFinished(true);
786         else {
787             // "xx/yy" indicates progress
788             if(!res\&.contains("/"))
789                 return;
790             QStringList numbers = res\&.split("/");
791             emit fwUpdateProgress(numbers[0]\&.toInt(), numbers[1]\&.toInt());
792         }
793     }
794 }
.fi
.SS "void Kb::run ()\fC [private]\fP"

.PP
Definition at line 486 of file kb\&.cpp\&.
.PP
References notifyPath, notifyPathMutex, and notifyPaths\&.
.PP
.nf
486             {
487     QFile notify(notifyPath);
488     // Wait a small amount of time for the node to open (100ms)
489     QThread::usleep(100000);
490     if(!notify\&.open(QIODevice::ReadOnly)){
491         // If it's still not open, try again before giving up (1s at a time, 10s total)
492         QThread::usleep(900000);
493         for(int i = 1; i < 10; i++){
494             if(notify\&.open(QIODevice::ReadOnly))
495                 break;
496             QThread::sleep(1);
497         }
498         if(!notify\&.isOpen())
499             return;
500     }
501     // Read data from notification node
502     QByteArray line;
503     while(notify\&.isOpen() && (line = notify\&.readLine())\&.length() > 0){
504         QString text = QString::fromUtf8(line);
505         metaObject()->invokeMethod(this, "readNotify", Qt::QueuedConnection, Q_ARG(QString, text));
506     }
507     QMutexLocker locker(&notifyPathMutex);
508     notifyPaths\&.remove(notifyPath);
509 }
.fi
.SS "void Kb::save ()"

.PP
Definition at line 313 of file kb\&.cpp\&.
.PP
References _currentProfile, _needsSave, _profiles, UsbId::guidString(), KbProfile::id(), prefsPath, KbProfile::save(), and CkbSettings::setValue()\&.
.PP
Referenced by autoSave(), KbWidget::on_hwSaveButton_clicked(), KbManager::scanKeyboards(), and ~Kb()\&.
.PP
.nf
313              {
314     if(prefsPath\&.isEmpty())
315         return;
316     _needsSave = false;
317     CkbSettings settings(prefsPath, true);
318     QString guids, currentGuid;
319     foreach(KbProfile* profile, _profiles){
320         guids\&.append(" " + profile->id()\&.guidString());
321         if(profile == _currentProfile)
322             currentGuid = profile->id()\&.guidString();
323         profile->save(settings);
324     }
325     settings\&.setValue("CurrentProfile", currentGuid);
326     settings\&.setValue("Profiles", guids\&.trimmed());
327 }
.fi
.SS "static int Kb::scrollSpeed ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 42 of file kb\&.h\&.
.PP
References _scrollSpeed\&.
.PP
Referenced by ExtraSettingsWidget::ExtraSettingsWidget(), ExtraSettingsWidget::on_sAccelBox_clicked(), and ExtraSettingsWidget::on_sSpeedBox_valueChanged()\&.
.PP
.nf
42 { return _scrollSpeed; }
.fi
.SS "void Kb::scrollSpeed (intnewSpeed)\fC [static]\fP"

.PP
Definition at line 268 of file kb\&.cpp\&.
.PP
References _scrollSpeed, activeDevices, and cmd\&.
.PP
.nf
268                                 {
269     if(newSpeed == _scrollSpeed)
270         return;
271     _scrollSpeed = newSpeed;
272 #ifdef Q_OS_MACX
273     // Update all devices
274     foreach(Kb* kb, activeDevices){
275         kb->cmd\&.write(QString("scrollspeed %1\n")\&.arg(newSpeed)\&.toLatin1());
276         kb->cmd\&.flush();
277     }
278 #endif
279 }
.fi
.SS "void Kb::setCurrentMode (\fBKbProfile\fP *profile, \fBKbMode\fP *mode, boolspontaneous = \fCtrue\fP)"

.PP
Definition at line 809 of file kb\&.cpp\&.
.PP
References _currentMode, _currentProfile, _needsSave, KbProfile::currentMode(), modeChanged(), and profileChanged()\&.
.PP
Referenced by KeyAction::keyEvent(), KbWidget::on_modesList_currentItemChanged(), KbWidget::on_modesList_customContextMenuRequested(), KbWidget::on_modesList_itemClicked(), and setCurrentProfile()\&.
.PP
.nf
809                                                                          {
810     if(_currentProfile != profile){
811         _currentProfile = profile;
812         _needsSave = true;
813         emit profileChanged();
814     }
815     if(_currentMode != mode || _currentProfile->currentMode() != mode){
816         _currentProfile->currentMode(_currentMode = mode);
817         _needsSave = true;
818         emit modeChanged(spontaneous);
819     }
820 }
.fi
.SS "void Kb::setCurrentMode (\fBKbProfile\fP *profile, intindex, boolspontaneous = \fCtrue\fP)\fC [inline]\fP"

.PP
Definition at line 73 of file kb\&.h\&.
.PP
References KbProfile::modes(), and setCurrentMode()\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
73 { setCurrentMode(profile, profile->modes()[index], spontaneous); }
.fi
.SS "void Kb::setCurrentMode (\fBKbMode\fP *mode, boolspontaneous = \fCtrue\fP)\fC [inline]\fP"

.PP
Definition at line 74 of file kb\&.h\&.
.PP
References _currentProfile, and setCurrentMode()\&.
.PP
Referenced by setCurrentMode()\&.
.PP
.nf
74 { setCurrentMode(_currentProfile, mode, spontaneous); }
.fi
.SS "void Kb::setCurrentProfile (\fBKbProfile\fP *profile, boolspontaneous = \fCtrue\fP)"

.PP
Definition at line 800 of file kb\&.cpp\&.
.PP
References KbProfile::append(), KbProfile::currentMode(), getKeyMap(), hwModeCount, KbProfile::modeCount(), KbProfile::modes(), and setCurrentMode()\&.
.PP
Referenced by load(), KbWidget::on_profileBox_activated(), KbProfileDialog::on_profileList_currentItemChanged(), KbProfileDialog::on_profileList_customContextMenuRequested(), KbProfileDialog::on_profileList_itemClicked(), and readNotify()\&.
.PP
.nf
800                                                               {
801     while(profile->modeCount() < hwModeCount)
802         profile->append(new KbMode(this, getKeyMap()));
803     KbMode* mode = profile->currentMode();
804     if(!mode)
805         profile->currentMode(mode = profile->modes()\&.first());
806     setCurrentMode(profile, mode, spontaneous);
807 }
.fi
.SS "void Kb::updateLayout ()\fC [private]\fP"

.PP
Definition at line 226 of file kb\&.cpp\&.
.PP
References _currentProfile, _hwProfile, _layout, _profiles, KbLight::close(), getKeyMap(), infoUpdated(), KeyMap::isISO(), KbProfile::keyMap(), KbMode::light(), and KbProfile::modes()\&.
.PP
Referenced by layout()\&.
.PP
.nf
226                      {
227 #ifdef Q_OS_MACX
228     // Write ANSI/ISO flag to daemon (OSX only)
229     cmd\&.write("layout ");
230     cmd\&.write(KeyMap::isISO(_layout) ? "iso" : "ansi");
231     cmd\&.write("\n");
232     cmd\&.flush();
233 #endif
234     foreach(KbProfile* profile, _profiles)
235         profile->keyMap(getKeyMap());
236     if(_hwProfile && !_profiles\&.contains(_hwProfile))
237         _hwProfile->keyMap(getKeyMap());
238     // Stop all animations as they'll need to be restarted
239     foreach(KbMode* mode, _currentProfile->modes())
240         mode->light()->close();
241     emit infoUpdated();
242 }
.fi
.SS "void Kb::writeProfileHeader ()\fC [private]\fP"

.PP
Definition at line 394 of file kb\&.cpp\&.
.PP
References _currentProfile, UsbId::guidString(), KbProfile::id(), UsbId::modifiedString(), and KbProfile::name()\&.
.PP
Referenced by frameUpdate(), and hwSave()\&.
.PP
.nf
394                            {
395     cmd\&.write("eraseprofile");
396     // Write the profile name and ID
397     cmd\&.write(" profilename ");
398     cmd\&.write(QUrl::toPercentEncoding(_currentProfile->name()));
399     cmd\&.write(" profileid ");
400     cmd\&.write(_currentProfile->id()\&.guidString()\&.toLatin1());
401     cmd\&.write(" ");
402     cmd\&.write(_currentProfile->id()\&.modifiedString()\&.toLatin1());
403 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBKbManager\fP\fC [friend]\fP"

.PP
Definition at line 142 of file kb\&.h\&.
.SH "Field Documentation"
.PP 
.SS "\fBKbMode\fP* Kb::_currentMode\fC [private]\fP"

.PP
Definition at line 169 of file kb\&.h\&.
.PP
Referenced by currentBind(), currentLight(), currentMode(), currentPerf(), frameUpdate(), hwSave(), readNotify(), and setCurrentMode()\&.
.SS "\fBKbProfile\fP* Kb::_currentProfile\fC [private]\fP"

.PP
Definition at line 167 of file kb\&.h\&.
.PP
Referenced by currentProfile(), frameUpdate(), hwSave(), readNotify(), save(), setCurrentMode(), updateLayout(), and writeProfileHeader()\&.
.SS "bool Kb::_delay = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 198 of file kb\&.h\&.
.PP
Referenced by Kb(), and macroDelay()\&.
.SS "bool Kb::_dither = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 165 of file kb\&.h\&.
.PP
Referenced by dither(), and Kb()\&.
.SS "int Kb::_frameRate = 30\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 164 of file kb\&.h\&.
.PP
Referenced by frameRate(), and Kb()\&.
.SS "\fBKbProfile\fP* Kb::_hwProfile\fC [private]\fP"

.PP
Definition at line 183 of file kb\&.h\&.
.PP
Referenced by deleteHw(), hwProfile(), hwSave(), readNotify(), and updateLayout()\&.
.SS "\fBKeyMap::Layout\fP Kb::_layout = \fBKeyMap::NO_LAYOUT\fP\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 161 of file kb\&.h\&.
.PP
Referenced by getKeyMap(), Kb(), layout(), and updateLayout()\&.
.SS "\fBKeyMap::Model\fP Kb::_model\fC [private]\fP"

.PP
Definition at line 171 of file kb\&.h\&.
.PP
Referenced by Kb(), and model()\&.
.SS "bool Kb::_mouseAccel = true\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 165 of file kb\&.h\&.
.PP
Referenced by Kb(), and mouseAccel()\&.
.SS "bool Kb::_needsSave\fC [private]\fP"

.PP
Definition at line 201 of file kb\&.h\&.
.PP
Referenced by appendProfile(), load(), needsSave(), profiles(), readNotify(), save(), and setCurrentMode()\&.
.SS "QList<\fBKbProfile\fP*> Kb::_profiles\fC [private]\fP"

.PP
Definition at line 168 of file kb\&.h\&.
.PP
Referenced by appendProfile(), find(), indexOf(), load(), needsSave(), profiles(), readNotify(), save(), and updateLayout()\&.
.SS "int Kb::_scrollSpeed = 0\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 164 of file kb\&.h\&.
.PP
Referenced by Kb(), and scrollSpeed()\&.
.SS "QFile Kb::cmd\fC [private]\fP"

.PP
Definition at line 191 of file kb\&.h\&.
.PP
Referenced by dither(), frameRate(), macroDelay(), mouseAccel(), and scrollSpeed()\&.
.SS "QString Kb::cmdpath\fC [private]\fP"

.PP
Definition at line 155 of file kb\&.h\&.
.PP
Referenced by Kb()\&.
.SS "QString Kb::devpath\fC [private]\fP"

.PP
Definition at line 155 of file kb\&.h\&.
.PP
Referenced by matches()\&.
.SS "QString Kb::features"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by MainWindow::checkFwUpdates(), FwUpgradeDialog::exec(), Kb(), KbWidget::KbWidget(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.SS "QString Kb::firmware"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by MainWindow::checkFwUpdates(), KbWidget::devUpdate(), FwUpgradeDialog::FwUpgradeDialog(), Kb(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.SS "QString Kb::fwUpdPath\fC [private]\fP"

.PP
Definition at line 181 of file kb\&.h\&.
.PP
Referenced by fwUpdate(), and readNotify()\&.
.SS "bool Kb::hwLoading[\fBHWMODE_MAX\fP+1]\fC [private]\fP"

.PP
Definition at line 205 of file kb\&.h\&.
.PP
Referenced by Kb(), and readNotify()\&.
.SS "const int Kb::HWMODE_MAX = 3\fC [static]\fP"

.PP
Definition at line 50 of file kb\&.h\&.
.PP
Referenced by KbPerf::applyIndicators(), and readNotify()\&.
.SS "int Kb::hwModeCount"

.PP
Definition at line 49 of file kb\&.h\&.
.PP
Referenced by hwSave(), Kb(), KbWidget::modeIcon(), KbWidget::on_modesList_customContextMenuRequested(), readNotify(), and setCurrentProfile()\&.
.SS "bool Kb::iState[\fBKbPerf::HW_I_COUNT\fP]\fC [private]\fP"

.PP
Definition at line 174 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), Kb(), and readNotify()\&.
.SS "quint64 Kb::lastAutoSave\fC [private]\fP"

.PP
Definition at line 178 of file kb\&.h\&.
.PP
Referenced by autoSave()\&.
.SS "int Kb::macroNumber\fC [private]\fP"

.PP
Definition at line 196 of file kb\&.h\&.
.PP
Referenced by getMacroNumber(), and Kb()\&.
.SS "QString Kb::macroPath\fC [private]\fP"

.PP
Definition at line 155 of file kb\&.h\&.
.PP
Referenced by getMacroPath(), Kb(), and ~Kb()\&.
.SS "bool Kb::monochrome"

.PP
Definition at line 19 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), hwSave(), Kb(), and KbWidget::KbWidget()\&.
.SS "int Kb::notifyNumber\fC [private]\fP"

.PP
Definition at line 194 of file kb\&.h\&.
.PP
Referenced by frameUpdate(), fwUpdate(), Kb(), readNotify(), and ~Kb()\&.
.SS "QString Kb::notifyPath\fC [private]\fP"

.PP
Definition at line 155 of file kb\&.h\&.
.PP
Referenced by Kb(), and run()\&.
.SS "QString Kb::pollrate"

.PP
Definition at line 18 of file kb\&.h\&.
.PP
Referenced by KbWidget::devUpdate(), and Kb()\&.
.SS "QString Kb::prefsPath\fC [private]\fP"

.PP
Definition at line 177 of file kb\&.h\&.
.PP
Referenced by Kb(), load(), and save()\&.
.SS "\fBKbMode\fP* Kb::prevMode\fC [private]\fP"

.PP
Definition at line 186 of file kb\&.h\&.
.PP
Referenced by deletePrevious(), frameUpdate(), and hwSave()\&.
.SS "\fBKbProfile\fP* Kb::prevProfile\fC [private]\fP"

.PP
Definition at line 185 of file kb\&.h\&.
.PP
Referenced by frameUpdate()\&.
.SS "QString Kb::usbModel"

.PP
Definition at line 16 of file kb\&.h\&.
.PP
Referenced by FwUpgradeDialog::FwUpgradeDialog(), Kb(), KbWidget::name(), and MainWindow::showFwUpdateNotification()\&.
.SS "QString Kb::usbSerial"

.PP
Definition at line 16 of file kb\&.h\&.
.PP
Referenced by KbWidget::devUpdate(), Kb(), and matches()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
