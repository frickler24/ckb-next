.TH "QuaZIODevice" 3 "Mon May 22 2017" "Version beta-v0.2.7 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QuaZIODevice \- 
.PP
A class to compress/decompress \fBQIODevice\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/quazip/quaziodevice\&.h>\fP
.PP
Inherits \fBQIODevice\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQuaZIODevice\fP (\fBQIODevice\fP *io, \fBQObject\fP *parent=NULL)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "\fB~QuaZIODevice\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "virtual bool \fBflush\fP ()"
.br
.RI "\fIFlushes data waiting to be written\&. \fP"
.ti -1c
.RI "virtual bool \fBopen\fP (QIODevice::OpenMode mode)"
.br
.RI "\fIOpens the device\&. \fP"
.ti -1c
.RI "virtual void \fBclose\fP ()"
.br
.RI "\fICloses this device, but not the underlying one\&. \fP"
.ti -1c
.RI "\fBQIODevice\fP * \fBgetIoDevice\fP () const "
.br
.RI "\fIReturns the underlying device\&. \fP"
.ti -1c
.RI "virtual bool \fBisSequential\fP () const "
.br
.RI "\fIReturns true\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual qint64 \fBreadData\fP (char *data, qint64 maxSize)"
.br
.RI "\fIImplementation of QIODevice::readData()\&. \fP"
.ti -1c
.RI "virtual qint64 \fBwriteData\fP (const char *data, qint64 maxSize)"
.br
.RI "\fIImplementation of QIODevice::writeData()\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "QuaZIODevicePrivate * \fBd\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class can be used to compress any data written to \fBQIODevice\fP or decompress it back\&. Compressing data sent over a QTcpSocket is a good example\&. 
.PP
Definition at line 41 of file quaziodevice\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QuaZIODevice::QuaZIODevice (\fBQIODevice\fP *io, \fBQObject\fP *parent = \fCNULL\fP)"

.PP
\fBParameters:\fP
.RS 4
\fIio\fP The \fBQIODevice\fP to read/write\&. 
.br
\fIparent\fP The parent object, as per \fBQObject\fP logic\&. 
.RE
.PP

.PP
Definition at line 123 of file quaziodevice\&.cpp\&.
.PP
.nf
123                                                         :
124     QIODevice(parent),
125     d(new QuaZIODevicePrivate(io))
126 {
127   connect(io, SIGNAL(readyRead()), SIGNAL(readyRead()));
128 }
.fi
.SS "QuaZIODevice::~QuaZIODevice ()"

.PP
Definition at line 130 of file quaziodevice\&.cpp\&.
.PP
References close(), and d\&.
.PP
.nf
131 {
132     if (isOpen())
133         close();
134     delete d;
135 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void QuaZIODevice::close ()\fC [virtual]\fP"
The underlying \fBQIODevice\fP is not closed in case you want to write something else to it\&. 
.PP
Definition at line 169 of file quaziodevice\&.cpp\&.
.PP
References d, and flush()\&.
.PP
Referenced by ~QuaZIODevice()\&.
.PP
.nf
170 {
171     if ((openMode() & QIODevice::ReadOnly) != 0) {
172         if (inflateEnd(&d->zins) != Z_OK) {
173             setErrorString(d->zins\&.msg);
174         }
175     }
176     if ((openMode() & QIODevice::WriteOnly) != 0) {
177         flush();
178         if (deflateEnd(&d->zouts) != Z_OK) {
179             setErrorString(d->zouts\&.msg);
180         }
181     }
182     QIODevice::close();
183 }
.fi
.SS "bool QuaZIODevice::flush ()\fC [virtual]\fP"
Unfortunately, as \fBQIODevice\fP doesn't support \fBflush()\fP by itself, the only thing this method does is write the compressed data into the device using Z_SYNC_FLUSH mode\&. If you need the compressed data to actually be flushed from the buffer of the underlying \fBQIODevice\fP, you need to call its \fBflush()\fP method as well, providing it supports it (like QTcpSocket does)\&. Example: 
.PP
.nf
QuaZIODevice dev(&sock);
dev\&.open(QIODevice::Write);
dev\&.write(yourDataGoesHere);
dev\&.flush();
sock->flush(); // this actually sends data to network

.fi
.PP
.PP
This may change in the future versions of QuaZIP by implementing an ugly hack: trying to cast the \fBQIODevice\fP using qobject_cast to known \fBflush()\fP-supporting subclasses, and calling flush if the resulting pointer is not zero\&. 
.PP
Definition at line 281 of file quaziodevice\&.cpp\&.
.PP
References d, and QUAZIO_OUTBUFSIZE\&.
.PP
Referenced by close()\&.
.PP
.nf
282 {
283     QString error;
284     if (d->doFlush(error) < 0) {
285         setErrorString(error);
286         return false;
287     }
288     // can't flush buffer, some data is still waiting
289     if (d->outBufPos < d->outBufSize)
290         return true;
291     Bytef c = 0;
292     d->zouts\&.next_in = &c; // fake input buffer
293     d->zouts\&.avail_in = 0; // of zero size
294     do {
295         d->zouts\&.next_out = (Bytef *) d->outBuf;
296         d->zouts\&.avail_out = QUAZIO_OUTBUFSIZE;
297         switch (deflate(&d->zouts, Z_SYNC_FLUSH)) {
298         case Z_OK:
299           d->outBufSize = (char *) d->zouts\&.next_out - d->outBuf;
300           if (d->doFlush(error) < 0) {
301               setErrorString(error);
302               return false;
303           }
304           if (d->outBufPos < d->outBufSize)
305               return true;
306           break;
307         case Z_BUF_ERROR: // nothing to write?
308           return true;
309         default:
310           setErrorString(QString::fromLocal8Bit(d->zouts\&.msg));
311           return false;
312         }
313     } while (d->zouts\&.avail_out == 0);
314     return true;
315 }
.fi
.SS "\fBQIODevice\fP * QuaZIODevice::getIoDevice () const"

.PP
Definition at line 137 of file quaziodevice\&.cpp\&.
.PP
References d\&.
.PP
.nf
138 {
139     return d->io;
140 }
.fi
.SS "bool QuaZIODevice::isSequential () const\fC [virtual]\fP"

.PP
Definition at line 317 of file quaziodevice\&.cpp\&.
.PP
.nf
318 {
319   return true;
320 }
.fi
.SS "bool QuaZIODevice::open (QIODevice::OpenModemode)\fC [virtual]\fP"

.PP
\fBParameters:\fP
.RS 4
\fImode\fP Neither QIODevice::ReadWrite nor QIODevice::Append are not supported\&. 
.RE
.PP

.PP
Definition at line 142 of file quaziodevice\&.cpp\&.
.PP
References d\&.
.PP
.nf
143 {
144     if ((mode & QIODevice::Append) != 0) {
145         setErrorString(trUtf8("QIODevice::Append is not supported for"
146                     " QuaZIODevice"));
147         return false;
148     }
149     if ((mode & QIODevice::ReadWrite) == QIODevice::ReadWrite) {
150         setErrorString(trUtf8("QIODevice::ReadWrite is not supported for"
151                     " QuaZIODevice"));
152         return false;
153     }
154     if ((mode & QIODevice::ReadOnly) != 0) {
155         if (inflateInit(&d->zins) != Z_OK) {
156             setErrorString(d->zins\&.msg);
157             return false;
158         }
159     }
160     if ((mode & QIODevice::WriteOnly) != 0) {
161         if (deflateInit(&d->zouts, Z_DEFAULT_COMPRESSION) != Z_OK) {
162             setErrorString(d->zouts\&.msg);
163             return false;
164         }
165     }
166     return QIODevice::open(mode);
167 }
.fi
.SS "qint64 QuaZIODevice::readData (char *data, qint64maxSize)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 185 of file quaziodevice\&.cpp\&.
.PP
References d, and QUAZIO_INBUFSIZE\&.
.PP
.nf
186 {
187   int read = 0;
188   while (read < maxSize) {
189     if (d->inBufPos == d->inBufSize) {
190       d->inBufPos = 0;
191       d->inBufSize = d->io->read(d->inBuf, QUAZIO_INBUFSIZE);
192       if (d->inBufSize == -1) {
193         d->inBufSize = 0;
194         setErrorString(d->io->errorString());
195         return -1;
196       }
197       if (d->inBufSize == 0)
198         break;
199     }
200     while (read < maxSize && d->inBufPos < d->inBufSize) {
201       d->zins\&.next_in = (Bytef *) (d->inBuf + d->inBufPos);
202       d->zins\&.avail_in = d->inBufSize - d->inBufPos;
203       d->zins\&.next_out = (Bytef *) (data + read);
204       d->zins\&.avail_out = (uInt) (maxSize - read); // hope it's less than 2GB
205       int more = 0;
206       switch (inflate(&d->zins, Z_SYNC_FLUSH)) {
207       case Z_OK:
208         read = (char *) d->zins\&.next_out - data;
209         d->inBufPos = (char *) d->zins\&.next_in - d->inBuf;
210         break;
211       case Z_STREAM_END:
212         read = (char *) d->zins\&.next_out - data;
213         d->inBufPos = (char *) d->zins\&.next_in - d->inBuf;
214         return read;
215       case Z_BUF_ERROR: // this should never happen, but just in case
216         if (!d->zBufError) {
217           qWarning("Z_BUF_ERROR detected with %d/%d in/out, weird",
218               d->zins\&.avail_in, d->zins\&.avail_out);
219           d->zBufError = true;
220         }
221         memmove(d->inBuf, d->inBuf + d->inBufPos, d->inBufSize - d->inBufPos);
222         d->inBufSize -= d->inBufPos;
223         d->inBufPos = 0;
224         more = d->io->read(d->inBuf + d->inBufSize, QUAZIO_INBUFSIZE - d->inBufSize);
225         if (more == -1) {
226           setErrorString(d->io->errorString());
227           return -1;
228         }
229         if (more == 0)
230           return read;
231         d->inBufSize += more;
232         break;
233       default:
234         setErrorString(QString::fromLocal8Bit(d->zins\&.msg));
235         return -1;
236       }
237     }
238   }
239 #ifdef QUAZIP_ZIODEVICE_DEBUG_INPUT
240   indebug\&.write(data, read);
241 #endif
242   return read;
243 }
.fi
.SS "qint64 QuaZIODevice::writeData (const char *data, qint64maxSize)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line 245 of file quaziodevice\&.cpp\&.
.PP
References d, and QUAZIO_OUTBUFSIZE\&.
.PP
.nf
246 {
247   int written = 0;
248   QString error;
249   if (d->doFlush(error) == -1) {
250     setErrorString(error);
251     return -1;
252   }
253   while (written < maxSize) {
254       // there is some data waiting in the output buffer
255     if (d->outBufPos < d->outBufSize)
256       return written;
257     d->zouts\&.next_in = (Bytef *) (data + written);
258     d->zouts\&.avail_in = (uInt) (maxSize - written); // hope it's less than 2GB
259     d->zouts\&.next_out = (Bytef *) d->outBuf;
260     d->zouts\&.avail_out = QUAZIO_OUTBUFSIZE;
261     switch (deflate(&d->zouts, Z_NO_FLUSH)) {
262     case Z_OK:
263       written = (char *) d->zouts\&.next_in - data;
264       d->outBufSize = (char *) d->zouts\&.next_out - d->outBuf;
265       break;
266     default:
267       setErrorString(QString::fromLocal8Bit(d->zouts\&.msg));
268       return -1;
269     }
270     if (d->doFlush(error) == -1) {
271       setErrorString(error);
272       return -1;
273     }
274   }
275 #ifdef QUAZIP_ZIODEVICE_DEBUG_OUTPUT
276   debug\&.write(data, written);
277 #endif
278   return written;
279 }
.fi
.SH "Field Documentation"
.PP 
.SS "QuaZIODevicePrivate* QuaZIODevice::d\fC [private]\fP"

.PP
Definition at line 96 of file quaziodevice\&.h\&.
.PP
Referenced by close(), flush(), getIoDevice(), open(), readData(), writeData(), and ~QuaZIODevice()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
