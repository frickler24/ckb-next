.TH "src/ckb/quazip/qioapi.cpp" 3 "Sat May 27 2017" "Version v0.2.8 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb/quazip/qioapi.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'zlib\&.h'\fP
.br
\fC#include 'ioapi\&.h'\fP
.br
\fC#include 'quazip_global\&.h'\fP
.br
\fC#include <QIODevice>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBQIODevice_descriptor\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSEEK_CUR\fP   1"
.br
.ti -1c
.RI "#define \fBSEEK_END\fP   2"
.br
.ti -1c
.RI "#define \fBSEEK_SET\fP   0"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "voidpf \fBcall_zopen64\fP (const \fBzlib_filefunc64_32_def\fP *pfilefunc, voidpf file, int mode)"
.br
.ti -1c
.RI "int \fBcall_zseek64\fP (const \fBzlib_filefunc64_32_def\fP *pfilefunc, voidpf filestream, \fBZPOS64_T\fP offset, int origin)"
.br
.ti -1c
.RI "\fBZPOS64_T\fP \fBcall_ztell64\fP (const \fBzlib_filefunc64_32_def\fP *pfilefunc, voidpf filestream)"
.br
.ti -1c
.RI "voidpf \fBqiodevice_open_file_func\fP (voidpf opaque, voidpf file, int mode)"
.br
.ti -1c
.RI "uLong \fBqiodevice_read_file_func\fP (voidpf opaque, voidpf stream, void *buf, uLong size)"
.br
.ti -1c
.RI "uLong \fBqiodevice_write_file_func\fP (voidpf opaque, voidpf stream, const void *buf, uLong size)"
.br
.ti -1c
.RI "uLong \fBqiodevice_tell_file_func\fP (voidpf opaque, voidpf stream)"
.br
.ti -1c
.RI "\fBZPOS64_T\fP \fBqiodevice64_tell_file_func\fP (voidpf opaque, voidpf stream)"
.br
.ti -1c
.RI "int \fBqiodevice_seek_file_func\fP (voidpf, voidpf stream, uLong offset, int origin)"
.br
.ti -1c
.RI "int \fBqiodevice64_seek_file_func\fP (voidpf, voidpf stream, \fBZPOS64_T\fP offset, int origin)"
.br
.ti -1c
.RI "int \fBqiodevice_close_file_func\fP (voidpf opaque, voidpf stream)"
.br
.ti -1c
.RI "int \fBqiodevice_fakeclose_file_func\fP (voidpf opaque, voidpf)"
.br
.ti -1c
.RI "int \fBqiodevice_error_file_func\fP (voidpf, voidpf)"
.br
.ti -1c
.RI "void \fBfill_qiodevice_filefunc\fP (\fBzlib_filefunc_def\fP *pzlib_filefunc_def)"
.br
.ti -1c
.RI "void \fBfill_qiodevice64_filefunc\fP (\fBzlib_filefunc64_def\fP *pzlib_filefunc_def)"
.br
.ti -1c
.RI "void \fBfill_zlib_filefunc64_32_def_from_filefunc32\fP (\fBzlib_filefunc64_32_def\fP *p_filefunc64_32, const \fBzlib_filefunc_def\fP *p_filefunc32)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define SEEK_CUR   1"

.PP
Definition at line 29 of file qioapi\&.cpp\&.
.SS "#define SEEK_END   2"

.PP
Definition at line 33 of file qioapi\&.cpp\&.
.SS "#define SEEK_SET   0"

.PP
Definition at line 37 of file qioapi\&.cpp\&.
.PP
Referenced by unzOpenCurrentFile3()\&.
.SH "Function Documentation"
.PP 
.SS "voidpf call_zopen64 (const \fBzlib_filefunc64_32_def\fP *pfilefunc, voidpffile, intmode)"

.PP
Definition at line 40 of file qioapi\&.cpp\&.
.PP
References zlib_filefunc64_def_s::opaque, zlib_filefunc64_32_def_s::zfile_func64, zlib_filefunc64_32_def_s::zopen32_file, and zlib_filefunc64_def_s::zopen64_file\&.
.PP
.nf
41 {
42     if (pfilefunc->zfile_func64\&.zopen64_file != NULL)
43         return (*(pfilefunc->zfile_func64\&.zopen64_file)) (pfilefunc->zfile_func64\&.opaque,file,mode);
44     else
45     {
46         return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64\&.opaque,file,mode);
47     }
48 }
.fi
.SS "int call_zseek64 (const \fBzlib_filefunc64_32_def\fP *pfilefunc, voidpffilestream, \fBZPOS64_T\fPoffset, intorigin)"

.PP
Definition at line 50 of file qioapi\&.cpp\&.
.PP
References zlib_filefunc64_def_s::opaque, zlib_filefunc64_32_def_s::zfile_func64, zlib_filefunc64_32_def_s::zseek32_file, and zlib_filefunc64_def_s::zseek64_file\&.
.PP
.nf
51 {
52     if (pfilefunc->zfile_func64\&.zseek64_file != NULL)
53         return (*(pfilefunc->zfile_func64\&.zseek64_file)) (pfilefunc->zfile_func64\&.opaque,filestream,offset,origin);
54     else
55     {
56         uLong offsetTruncated = (uLong)offset;
57         if (offsetTruncated != offset)
58             return -1;
59         else
60             return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64\&.opaque,filestream,offsetTruncated,origin);
61     }
62 }
.fi
.SS "\fBZPOS64_T\fP call_ztell64 (const \fBzlib_filefunc64_32_def\fP *pfilefunc, voidpffilestream)"

.PP
Definition at line 64 of file qioapi\&.cpp\&.
.PP
References zlib_filefunc64_def_s::opaque, zlib_filefunc64_32_def_s::zfile_func64, zlib_filefunc64_def_s::zseek64_file, zlib_filefunc64_32_def_s::ztell32_file, and zlib_filefunc64_def_s::ztell64_file\&.
.PP
.nf
65 {
66     if (pfilefunc->zfile_func64\&.zseek64_file != NULL)
67         return (*(pfilefunc->zfile_func64\&.ztell64_file)) (pfilefunc->zfile_func64\&.opaque,filestream);
68     else
69     {
70         uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64\&.opaque,filestream);
71         if ((tell_uLong) == ((uLong)-1))
72             return (ZPOS64_T)-1;
73         else
74             return tell_uLong;
75     }
76 }
.fi
.SS "void fill_qiodevice64_filefunc (\fBzlib_filefunc64_def\fP *pzlib_filefunc_def)"

.PP
Definition at line 331 of file qioapi\&.cpp\&.
.PP
References zlib_filefunc64_def_s::opaque, qiodevice64_seek_file_func(), qiodevice64_tell_file_func(), qiodevice_close_file_func(), qiodevice_error_file_func(), qiodevice_fakeclose_file_func(), qiodevice_open_file_func(), qiodevice_read_file_func(), qiodevice_write_file_func(), zlib_filefunc64_def_s::zclose_file, zlib_filefunc64_def_s::zerror_file, zlib_filefunc64_def_s::zfakeclose_file, zlib_filefunc64_def_s::zopen64_file, zlib_filefunc64_def_s::zread_file, zlib_filefunc64_def_s::zseek64_file, zlib_filefunc64_def_s::ztell64_file, and zlib_filefunc64_def_s::zwrite_file\&.
.PP
Referenced by unzOpenInternal(), and zipOpen3()\&.
.PP
.nf
333 {
334     // Open functions are the same for Qt\&.
335     pzlib_filefunc_def->zopen64_file = qiodevice_open_file_func;
336     pzlib_filefunc_def->zread_file = qiodevice_read_file_func;
337     pzlib_filefunc_def->zwrite_file = qiodevice_write_file_func;
338     pzlib_filefunc_def->ztell64_file = qiodevice64_tell_file_func;
339     pzlib_filefunc_def->zseek64_file = qiodevice64_seek_file_func;
340     pzlib_filefunc_def->zclose_file = qiodevice_close_file_func;
341     pzlib_filefunc_def->zerror_file = qiodevice_error_file_func;
342     pzlib_filefunc_def->opaque = new QIODevice_descriptor;
343     pzlib_filefunc_def->zfakeclose_file = qiodevice_fakeclose_file_func;
344 }
.fi
.SS "void fill_qiodevice_filefunc (\fBzlib_filefunc_def\fP *pzlib_filefunc_def)"

.PP
Definition at line 318 of file qioapi\&.cpp\&.
.PP
References zlib_filefunc_def_s::opaque, qiodevice_close_file_func(), qiodevice_error_file_func(), qiodevice_open_file_func(), qiodevice_read_file_func(), qiodevice_seek_file_func(), qiodevice_tell_file_func(), qiodevice_write_file_func(), zlib_filefunc_def_s::zclose_file, zlib_filefunc_def_s::zerror_file, zlib_filefunc_def_s::zopen_file, zlib_filefunc_def_s::zread_file, zlib_filefunc_def_s::zseek_file, zlib_filefunc_def_s::ztell_file, and zlib_filefunc_def_s::zwrite_file\&.
.PP
.nf
320 {
321     pzlib_filefunc_def->zopen_file = qiodevice_open_file_func;
322     pzlib_filefunc_def->zread_file = qiodevice_read_file_func;
323     pzlib_filefunc_def->zwrite_file = qiodevice_write_file_func;
324     pzlib_filefunc_def->ztell_file = qiodevice_tell_file_func;
325     pzlib_filefunc_def->zseek_file = qiodevice_seek_file_func;
326     pzlib_filefunc_def->zclose_file = qiodevice_close_file_func;
327     pzlib_filefunc_def->zerror_file = qiodevice_error_file_func;
328     pzlib_filefunc_def->opaque = new QIODevice_descriptor;
329 }
.fi
.SS "void fill_zlib_filefunc64_32_def_from_filefunc32 (\fBzlib_filefunc64_32_def\fP *p_filefunc64_32, const \fBzlib_filefunc_def\fP *p_filefunc32)"

.PP
Definition at line 346 of file qioapi\&.cpp\&.
.PP
References zlib_filefunc_def_s::opaque, zlib_filefunc64_def_s::opaque, zlib_filefunc_def_s::zclose_file, zlib_filefunc64_def_s::zclose_file, zlib_filefunc_def_s::zerror_file, zlib_filefunc64_def_s::zerror_file, zlib_filefunc64_def_s::zfakeclose_file, zlib_filefunc64_32_def_s::zfile_func64, zlib_filefunc64_32_def_s::zopen32_file, zlib_filefunc64_def_s::zopen64_file, zlib_filefunc_def_s::zopen_file, zlib_filefunc_def_s::zread_file, zlib_filefunc64_def_s::zread_file, zlib_filefunc64_32_def_s::zseek32_file, zlib_filefunc64_def_s::zseek64_file, zlib_filefunc_def_s::zseek_file, zlib_filefunc64_32_def_s::ztell32_file, zlib_filefunc64_def_s::ztell64_file, zlib_filefunc_def_s::ztell_file, zlib_filefunc_def_s::zwrite_file, and zlib_filefunc64_def_s::zwrite_file\&.
.PP
Referenced by unzOpen2(), and zipOpen2()\&.
.PP
.nf
347 {
348     p_filefunc64_32->zfile_func64\&.zopen64_file = NULL;
349     p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
350     p_filefunc64_32->zfile_func64\&.zerror_file = p_filefunc32->zerror_file;
351     p_filefunc64_32->zfile_func64\&.zread_file = p_filefunc32->zread_file;
352     p_filefunc64_32->zfile_func64\&.zwrite_file = p_filefunc32->zwrite_file;
353     p_filefunc64_32->zfile_func64\&.ztell64_file = NULL;
354     p_filefunc64_32->zfile_func64\&.zseek64_file = NULL;
355     p_filefunc64_32->zfile_func64\&.zclose_file = p_filefunc32->zclose_file;
356     p_filefunc64_32->zfile_func64\&.zerror_file = p_filefunc32->zerror_file;
357     p_filefunc64_32->zfile_func64\&.opaque = p_filefunc32->opaque;
358     p_filefunc64_32->zfile_func64\&.zfakeclose_file = NULL;
359     p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
360     p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
361 }
.fi
.SS "int qiodevice64_seek_file_func (voidpf, voidpfstream, \fBZPOS64_T\fPoffset, intorigin)"

.PP
Definition at line 244 of file qioapi\&.cpp\&.
.PP
References ZLIB_FILEFUNC_SEEK_CUR, ZLIB_FILEFUNC_SEEK_END, and ZLIB_FILEFUNC_SEEK_SET\&.
.PP
Referenced by fill_qiodevice64_filefunc()\&.
.PP
.nf
249 {
250     QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
251     if (iodevice->isSequential()) {
252         if (origin == ZLIB_FILEFUNC_SEEK_END
253                 && offset == 0) {
254             // sequential devices are always at end (needed in mdAppend)
255             return 0;
256         } else {
257             qWarning("qiodevice_seek_file_func() called for sequential device");
258             return -1;
259         }
260     }
261     qint64 qiodevice_seek_result=0;
262     int ret;
263     switch (origin)
264     {
265     case ZLIB_FILEFUNC_SEEK_CUR :
266         qiodevice_seek_result = ((QIODevice*)stream)->pos() + offset;
267         break;
268     case ZLIB_FILEFUNC_SEEK_END :
269         qiodevice_seek_result = ((QIODevice*)stream)->size() - offset;
270         break;
271     case ZLIB_FILEFUNC_SEEK_SET :
272         qiodevice_seek_result = offset;
273         break;
274     default:
275         return -1;
276     }
277     ret = !iodevice->seek(qiodevice_seek_result);
278     return ret;
279 }
.fi
.SS "\fBZPOS64_T\fP qiodevice64_tell_file_func (voidpfopaque, voidpfstream)"

.PP
Definition at line 192 of file qioapi\&.cpp\&.
.PP
References QIODevice_descriptor::pos\&.
.PP
Referenced by fill_qiodevice64_filefunc()\&.
.PP
.nf
195 {
196     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
197     QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
198     qint64 ret;
199     if (iodevice->isSequential()) {
200         ret = d->pos;
201     } else {
202         ret = iodevice->pos();
203     }
204     return static_cast<ZPOS64_T>(ret);
205 }
.fi
.SS "int qiodevice_close_file_func (voidpfopaque, voidpfstream)"

.PP
Definition at line 281 of file qioapi\&.cpp\&.
.PP
Referenced by fill_qiodevice64_filefunc(), and fill_qiodevice_filefunc()\&.
.PP
.nf
284 {
285     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
286     delete d;
287     QIODevice *device = reinterpret_cast<QIODevice*>(stream);
288 #ifdef QUAZIP_QSAVEFILE_BUG_WORKAROUND
289     // QSaveFile terribly breaks the is-a idiom:
290     // it IS a QIODevice, but it is NOT compatible with it: close() is private
291     QSaveFile *file = qobject_cast<QSaveFile*>(device);
292     if (file != NULL) {
293         // We have to call the ugly commit() instead:
294         return file->commit() ? 0 : -1;
295     }
296 #endif
297     device->close();
298     return 0;
299 }
.fi
.SS "int qiodevice_error_file_func (voidpf, voidpf)"

.PP
Definition at line 310 of file qioapi\&.cpp\&.
.PP
Referenced by fill_qiodevice64_filefunc(), and fill_qiodevice_filefunc()\&.
.PP
.nf
313 {
314     // can't check for error due to the QIODevice API limitation
315     return 0;
316 }
.fi
.SS "int qiodevice_fakeclose_file_func (voidpfopaque, voidpf)"

.PP
Definition at line 301 of file qioapi\&.cpp\&.
.PP
Referenced by fill_qiodevice64_filefunc()\&.
.PP
.nf
304 {
305     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
306     delete d;
307     return 0;
308 }
.fi
.SS "voidpf qiodevice_open_file_func (voidpfopaque, voidpffile, intmode)"

.PP
Definition at line 86 of file qioapi\&.cpp\&.
.PP
References QIODevice_descriptor::pos, ZLIB_FILEFUNC_MODE_CREATE, ZLIB_FILEFUNC_MODE_EXISTING, ZLIB_FILEFUNC_MODE_READ, and ZLIB_FILEFUNC_MODE_READWRITEFILTER\&.
.PP
Referenced by fill_qiodevice64_filefunc(), and fill_qiodevice_filefunc()\&.
.PP
.nf
90 {
91     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
92     QIODevice *iodevice = reinterpret_cast<QIODevice*>(file);
93     QIODevice::OpenMode desiredMode;
94     if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
95         desiredMode = QIODevice::ReadOnly;
96     else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
97         desiredMode = QIODevice::ReadWrite;
98     else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
99         desiredMode = QIODevice::WriteOnly;
100     if (iodevice->isOpen()) {
101         if ((iodevice->openMode() & desiredMode) == desiredMode) {
102             if (desiredMode != QIODevice::WriteOnly
103                     && iodevice->isSequential()) {
104                 // We can use sequential devices only for writing\&.
105                 delete d;
106                 return NULL;
107             } else {
108                 if ((desiredMode & QIODevice::WriteOnly) != 0) {
109                     // open for writing, need to seek existing device
110                     if (!iodevice->isSequential()) {
111                         iodevice->seek(0);
112                     } else {
113                         d->pos = iodevice->pos();
114                     }
115                 }
116             }
117             return iodevice;
118         } else {
119             delete d;
120             return NULL;
121         }
122     }
123     iodevice->open(desiredMode);
124     if (iodevice->isOpen()) {
125         if (desiredMode != QIODevice::WriteOnly && iodevice->isSequential()) {
126             // We can use sequential devices only for writing\&.
127             iodevice->close();
128             delete d;
129             return NULL;
130         } else {
131             return iodevice;
132         }
133     } else {
134         delete d;
135         return NULL;
136     }
137 }
.fi
.SS "uLong qiodevice_read_file_func (voidpfopaque, voidpfstream, void *buf, uLongsize)"

.PP
Definition at line 140 of file qioapi\&.cpp\&.
.PP
References QIODevice_descriptor::pos\&.
.PP
Referenced by fill_qiodevice64_filefunc(), and fill_qiodevice_filefunc()\&.
.PP
.nf
145 {
146     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
147     QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
148     qint64 ret64 = iodevice->read((char*)buf,size);
149     uLong ret;
150     ret = (uLong) ret64;
151     if (ret64 != -1) {
152         d->pos += ret64;
153     }
154     return ret;
155 }
.fi
.SS "int qiodevice_seek_file_func (voidpf, voidpfstream, uLongoffset, intorigin)"

.PP
Definition at line 207 of file qioapi\&.cpp\&.
.PP
References ZLIB_FILEFUNC_SEEK_CUR, ZLIB_FILEFUNC_SEEK_END, and ZLIB_FILEFUNC_SEEK_SET\&.
.PP
Referenced by fill_qiodevice_filefunc()\&.
.PP
.nf
212 {
213     QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
214     if (iodevice->isSequential()) {
215         if (origin == ZLIB_FILEFUNC_SEEK_END
216                 && offset == 0) {
217             // sequential devices are always at end (needed in mdAppend)
218             return 0;
219         } else {
220             qWarning("qiodevice_seek_file_func() called for sequential device");
221             return -1;
222         }
223     }
224     uLong qiodevice_seek_result=0;
225     int ret;
226     switch (origin)
227     {
228     case ZLIB_FILEFUNC_SEEK_CUR :
229         qiodevice_seek_result = ((QIODevice*)stream)->pos() + offset;
230         break;
231     case ZLIB_FILEFUNC_SEEK_END :
232         qiodevice_seek_result = ((QIODevice*)stream)->size() - offset;
233         break;
234     case ZLIB_FILEFUNC_SEEK_SET :
235         qiodevice_seek_result = offset;
236         break;
237     default:
238         return -1;
239     }
240     ret = !iodevice->seek(qiodevice_seek_result);
241     return ret;
242 }
.fi
.SS "uLong qiodevice_tell_file_func (voidpfopaque, voidpfstream)"

.PP
Definition at line 175 of file qioapi\&.cpp\&.
.PP
References QIODevice_descriptor::pos\&.
.PP
Referenced by fill_qiodevice_filefunc()\&.
.PP
.nf
178 {
179     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
180     QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
181     uLong ret;
182     qint64 ret64;
183     if (iodevice->isSequential()) {
184         ret64 = d->pos;
185     } else {
186         ret64 = iodevice->pos();
187     }
188     ret = static_cast<uLong>(ret64);
189     return ret;
190 }
.fi
.SS "uLong qiodevice_write_file_func (voidpfopaque, voidpfstream, const void *buf, uLongsize)"

.PP
Definition at line 158 of file qioapi\&.cpp\&.
.PP
References QIODevice_descriptor::pos\&.
.PP
Referenced by fill_qiodevice64_filefunc(), and fill_qiodevice_filefunc()\&.
.PP
.nf
163 {
164     QIODevice_descriptor *d = reinterpret_cast<QIODevice_descriptor*>(opaque);
165     QIODevice *iodevice = reinterpret_cast<QIODevice*>(stream);
166     uLong ret;
167     qint64 ret64 = iodevice->write((char*)buf,size);
168     if (ret64 != -1) {
169         d->pos += ret64;
170     }
171     ret = (uLong) ret64;
172     return ret;
173 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
