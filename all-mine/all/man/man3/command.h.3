.TH "src/ckb-daemon/command.h" 3 "Sat May 27 2017" "Version v0.2.8 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ckb-daemon/command.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'includes\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "union \fBdevcmd\fP"
.br
.ti -1c
.RI "struct \fBdevcmd\&.__unnamed__\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCMD_COUNT\fP   (\fBCMD_LAST\fP - \fBCMD_FIRST\fP + 2)"
.br
.ti -1c
.RI "#define \fBCMD_DEV_COUNT\fP   (\fBCMD_LAST\fP - \fBCMD_VT_FIRST\fP + 1)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBcmdhandler\fP )(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *parameter)"
.br
.ti -1c
.RI "typedef int(* \fBcmdhandler_io\fP )(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *parameter)"
.br
.ti -1c
.RI "typedef void(* \fBcmdhandler_mac\fP )(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, const char *keys, const char *assignment)"
.br
.ti -1c
.RI "typedef union \fBdevcmd\fP \fBdevcmd\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBcmd\fP { \fBNONE\fP = -11, \fBDELAY\fP = -10, \fBCMD_FIRST\fP = DELAY, \fBMODE\fP = -9, \fBSWITCH\fP = -8, \fBLAYOUT\fP = -7, \fBACCEL\fP = -6, \fBSCROLLSPEED\fP = -5, \fBNOTIFYON\fP = -4, \fBNOTIFYOFF\fP = -3, \fBFPS\fP = -2, \fBDITHER\fP = -1, \fBHWLOAD\fP = 0, \fBCMD_VT_FIRST\fP = 0, \fBHWSAVE\fP, \fBFWUPDATE\fP, \fBPOLLRATE\fP, \fBACTIVE\fP, \fBIDLE\fP, \fBERASE\fP, \fBERASEPROFILE\fP, \fBNAME\fP, \fBPROFILENAME\fP, \fBID\fP, \fBPROFILEID\fP, \fBRGB\fP, \fBIOFF\fP, \fBION\fP, \fBIAUTO\fP, \fBBIND\fP, \fBUNBIND\fP, \fBREBIND\fP, \fBMACRO\fP, \fBDPI\fP, \fBDPISEL\fP, \fBLIFT\fP, \fBSNAP\fP, \fBNOTIFY\fP, \fBINOTIFY\fP, \fBGET\fP, \fBRESTART\fP, \fBCMD_LAST\fP = RESTART }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBreadcmd\fP (\fBusbdevice\fP *kb, const char *line)"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "union devcmd"
.PP 
Definition at line 73 of file command\&.h\&.
.PP
\fBData Fields:\fP
.RS 4
struct \fBdevcmd\fP \fI__unnamed__\fP 
.br
.PP
\fBcmdhandler\fP \fIdo_cmd[(\fBCMD_LAST\fP-\fBCMD_VT_FIRST\fP+1)]\fP 
.br
.PP
\fBcmdhandler_io\fP \fIdo_io[(\fBCMD_LAST\fP-\fBCMD_VT_FIRST\fP+1)]\fP 
.br
.PP
\fBcmdhandler_mac\fP \fIdo_macro[(\fBCMD_LAST\fP-\fBCMD_VT_FIRST\fP+1)]\fP 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define CMD_COUNT   (\fBCMD_LAST\fP - \fBCMD_FIRST\fP + 2)"

.PP
Definition at line 65 of file command\&.h\&.
.PP
Referenced by readcmd()\&.
.SS "#define CMD_DEV_COUNT   (\fBCMD_LAST\fP - \fBCMD_VT_FIRST\fP + 1)"

.PP
Definition at line 66 of file command\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* cmdhandler)(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *parameter)"

.PP
Definition at line 70 of file command\&.h\&.
.SS "typedef int(* cmdhandler_io)(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, int keyindex, const char *parameter)"

.PP
Definition at line 71 of file command\&.h\&.
.SS "typedef void(* cmdhandler_mac)(\fBusbdevice\fP *kb, \fBusbmode\fP *modeidx, int notifyidx, const char *keys, const char *assignment)"

.PP
Definition at line 72 of file command\&.h\&.
.SS "typedef union \fBdevcmd\fP  \fBdevcmd\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBcmd\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINONE \fP\fP
.TP
\fB\fIDELAY \fP\fP
.TP
\fB\fICMD_FIRST \fP\fP
.TP
\fB\fIMODE \fP\fP
.TP
\fB\fISWITCH \fP\fP
.TP
\fB\fILAYOUT \fP\fP
.TP
\fB\fIACCEL \fP\fP
.TP
\fB\fISCROLLSPEED \fP\fP
.TP
\fB\fINOTIFYON \fP\fP
.TP
\fB\fINOTIFYOFF \fP\fP
.TP
\fB\fIFPS \fP\fP
.TP
\fB\fIDITHER \fP\fP
.TP
\fB\fIHWLOAD \fP\fP
.TP
\fB\fICMD_VT_FIRST \fP\fP
.TP
\fB\fIHWSAVE \fP\fP
.TP
\fB\fIFWUPDATE \fP\fP
.TP
\fB\fIPOLLRATE \fP\fP
.TP
\fB\fIACTIVE \fP\fP
.TP
\fB\fIIDLE \fP\fP
.TP
\fB\fIERASE \fP\fP
.TP
\fB\fIERASEPROFILE \fP\fP
.TP
\fB\fINAME \fP\fP
.TP
\fB\fIPROFILENAME \fP\fP
.TP
\fB\fIID \fP\fP
.TP
\fB\fIPROFILEID \fP\fP
.TP
\fB\fIRGB \fP\fP
.TP
\fB\fIIOFF \fP\fP
.TP
\fB\fIION \fP\fP
.TP
\fB\fIIAUTO \fP\fP
.TP
\fB\fIBIND \fP\fP
.TP
\fB\fIUNBIND \fP\fP
.TP
\fB\fIREBIND \fP\fP
.TP
\fB\fIMACRO \fP\fP
.TP
\fB\fIDPI \fP\fP
.TP
\fB\fIDPISEL \fP\fP
.TP
\fB\fILIFT \fP\fP
.TP
\fB\fISNAP \fP\fP
.TP
\fB\fINOTIFY \fP\fP
.TP
\fB\fIINOTIFY \fP\fP
.TP
\fB\fIGET \fP\fP
.TP
\fB\fIRESTART \fP\fP
.TP
\fB\fICMD_LAST \fP\fP
.PP
Definition at line 7 of file command\&.h\&.
.PP
.nf
7              {
8     // Special - handled by readcmd, no device functions
9     NONE        = -11,
10     DELAY       = -10,   CMD_FIRST = DELAY,
11     MODE        = -9,
12     SWITCH      = -8,
13     LAYOUT      = -7,
14     ACCEL       = -6,
15     SCROLLSPEED = -5,
16     NOTIFYON    = -4,
17     NOTIFYOFF   = -3,
18     FPS         = -2,
19     DITHER      = -1,
20 
21     // Hardware data
22     HWLOAD      = 0,    CMD_VT_FIRST = 0,
23     HWSAVE,
24     FWUPDATE,
25     POLLRATE,
26 
27     // Software control on/off
28     ACTIVE,
29     IDLE,
30 
31     // Profile/mode metadata
32     ERASE,
33     ERASEPROFILE,
34     NAME,
35     PROFILENAME,
36     ID,
37     PROFILEID,
38 
39     // LED control
40     RGB,
41     IOFF,
42     ION,
43     IAUTO,
44 
45     // Key binding control
46     BIND,
47     UNBIND,
48     REBIND,
49     MACRO,
50 
51     // DPI control
52     DPI,
53     DPISEL,
54     LIFT,
55     SNAP,
56 
57     // Notifications and output
58     NOTIFY,
59     INOTIFY,
60     GET,
61     RESTART,
62 
63     CMD_LAST = RESTART
64 } cmd;
.fi
.SH "Function Documentation"
.PP 
.SS "int readcmd (\fBusbdevice\fP *kb, const char *line)"
< Because length of word is length of line + 1, there should be no problem with buffer overflow\&. 
.PP
Definition at line 67 of file command\&.c\&.
.PP
References ACCEL, ACTIVE, usbdevice::active, BIND, CMD_COUNT, CMD_FIRST, cmd_strings, usbprofile::currentmode, DELAY, usbdevice::delay, DITHER, usbdevice::dither, devcmd::do_cmd, devcmd::do_io, devcmd::do_macro, DPI, DPISEL, ERASE, ERASEPROFILE, FEAT_ANSI, FEAT_BIND, FEAT_ISO, FEAT_LMASK, FEAT_MOUSEACCEL, FEAT_NOTIFY, usbdevice::features, lighting::forceupdate, FPS, FWUPDATE, GET, HAS_FEATURES, HWLOAD, HWSAVE, IAUTO, ID, IDLE, INDEX_OF, INOTIFY, IOFF, ION, IS_FULLRANGE, IS_MOUSE_DEV, keymap, LAYOUT, left, LIFT, usbmode::light, MACRO, mknotifynode(), MODE, usbprofile::mode, MODE_COUNT, N_KEYS_EXTENDED, NAME, NEEDS_FW_UPDATE, NONE, NOTIFY, NOTIFYOFF, NOTIFYON, OUTFIFO_MAX, POLLRATE, usbdevice::profile, PROFILEID, PROFILENAME, REBIND, RESTART, RGB, right(), rmnotifynode(), SCROLL_ACCELERATED, SCROLL_MAX, SCROLL_MIN, SCROLLSPEED, SNAP, SWITCH, TRY_WITH_RESET, UNBIND, usbdevice::usbdelay, and usbdevice::vtable\&.
.PP
Referenced by devmain()\&.
.PP
.nf
67                                             {
68     char* word = malloc(strlen(line) + 1);
69     int wordlen;
70     const char* newline = 0;
71     const devcmd* vt = kb->vtable;
72     usbprofile* profile = kb->profile;
73     usbmode* mode = 0;
74     int notifynumber = 0;
75     // Read words from the input
76     cmd command = NONE;
77     while(sscanf(line, "%s%n", word, &wordlen) == 1){
78         line += wordlen;
79         // If we passed a newline, reset the context
80         if(line > newline){
81             mode = profile->currentmode;
82             command = NONE;
83             notifynumber = 0;
84             newline = strchr(line, '\n');
85             if(!newline)
86                 newline = line + strlen(line);
87         }
88         // Check for a command word
89         for(int i = 0; i < CMD_COUNT - 1; i++){
90             if(!strcmp(word, cmd_strings[i])){
91                 command = i + CMD_FIRST;
92 #ifndef OS_MAC
93                 // Layout and mouse acceleration aren't used on Linux; ignore
94                 if(command == LAYOUT || command == ACCEL || command == SCROLLSPEED)
95                     command = NONE;
96 #endif
97                 // Most commands require parameters, but a few are actions in and of themselves
98                 if(command != SWITCH
99                         && command != HWLOAD && command != HWSAVE
100                         && command != ACTIVE && command != IDLE
101                         && command != ERASE && command != ERASEPROFILE
102                         && command != RESTART)
103                     goto next_loop;
104                 break;
105             }
106         }
107 
108         // Set current notification node when given @number
109         int newnotify;
110         if(sscanf(word, "@%u", &newnotify) == 1 && newnotify < OUTFIFO_MAX){
111             notifynumber = newnotify;
112             continue;
113         }
114 
115         // Reject unrecognized commands\&. Reject bind or notify related commands if the keyboard doesn't have the feature enabled\&.
116         if(command == NONE
117                 || ((!HAS_FEATURES(kb, FEAT_BIND) && (command == BIND || command == UNBIND || command == REBIND || command == MACRO || command == DELAY))
118                            || (!HAS_FEATURES(kb, FEAT_NOTIFY) && command == NOTIFY))){
119             next_loop:
120             continue;
121         }
122         // Reject anything not related to fwupdate if device has a bricked FW
123         if(NEEDS_FW_UPDATE(kb) && command != FWUPDATE && command != NOTIFYON && command != NOTIFYOFF)
124             continue;
125 
126         // Specially handled commands - these are available even when keyboard is IDLE
127         switch(command){
128         case NOTIFYON: {
129             // Notification node on
130             int notify;
131             if(sscanf(word, "%u", &notify) == 1)
132                 mknotifynode(kb, notify);
133             continue;
134         } case NOTIFYOFF: {
135             // Notification node off
136             int notify;
137             if(sscanf(word, "%u", &notify) == 1 && notify != 0) // notify0 can't be removed
138                 rmnotifynode(kb, notify);
139             continue;
140         } case GET:
141             // Output data to notification node
142             vt->get(kb, mode, notifynumber, 0, word);
143             continue;
144         case LAYOUT:
145             // OSX: switch ANSI/ISO keyboard layout
146             if(!strcmp(word, "ansi"))
147                 kb->features = (kb->features & ~FEAT_LMASK) | FEAT_ANSI;
148             else if(!strcmp(word, "iso"))
149                 kb->features = (kb->features & ~FEAT_LMASK) | FEAT_ISO;
150             continue;
151 #ifdef OS_MAC
152         case ACCEL:
153             // OSX mouse acceleration on/off
154             if(!strcmp(word, "on"))
155                 kb->features |= FEAT_MOUSEACCEL;
156             else if(!strcmp(word, "off"))
157                 kb->features &= ~FEAT_MOUSEACCEL;
158             continue;
159         case SCROLLSPEED:{
160             int newscroll;
161             if(sscanf(word, "%d", &newscroll) != 1)
162                 break;
163             if(newscroll < SCROLL_MIN)
164                 newscroll = SCROLL_ACCELERATED;
165             if(newscroll > SCROLL_MAX)
166                 newscroll = SCROLL_MAX;
167             kb->scroll_rate = newscroll;
168             continue;
169         }
170 #endif
171         case MODE: {
172             // Select a mode number (1 - 6)
173             int newmode;
174             if(sscanf(word, "%u", &newmode) == 1 && newmode > 0 && newmode <= MODE_COUNT)
175                 mode = profile->mode + newmode - 1;
176             continue;
177         }
178         case FPS: {
179             // USB command delay (2 - 10ms)
180             uint framerate;
181             if(sscanf(word, "%u", &framerate) == 1 && framerate > 0){
182                 // Not all devices require the same number of messages per frame; select delay appropriately
183                 uint per_frame = IS_MOUSE_DEV(kb) ? 2 : IS_FULLRANGE(kb) ? 14 : 5;
184                 uint delay = 1000 / framerate / per_frame;
185                 if(delay < 2)
186                     delay = 2;
187                 else if(delay > 10)
188                     delay = 10;
189                 kb->usbdelay = delay;
190             }
191             continue;
192         }
193         case DITHER: {
194             // 0: No dither, 1: Ordered dither\&.
195             uint dither;
196             if(sscanf(word, "%u", &dither) == 1 && dither <= 1){
197                 kb->dither = dither;
198                 profile->currentmode->light\&.forceupdate = 1;
199                 mode->light\&.forceupdate = 1;
200             }
201             continue;
202         }
203         case DELAY: {
204             long int delay;
205             if(sscanf(word, "%ld", &delay) == 1 && 0 <= delay && delay < UINT_MAX) {
206                 // Add delay of `newdelay` microseconds to macro playback
207                 kb->delay = (unsigned int)delay;
208             } else if(strcmp(word, "on") == 0) {
209                 // allow previous syntax, `delay on` means use old `long macro delay`
210                 kb->delay = UINT_MAX;
211             } else {
212                 // bad parameter to handle false commands like "delay off"
213                 kb->delay = 0; // No delay\&.
214             }
215             continue;
216         }
217         case RESTART: {
218             char mybuffer[] = "no reason specified";
219             if (sscanf(line, " %[^\n]", word) == -1) { 
220                 word = mybuffer;
221             }
222             vt->do_cmd[command](kb, mode, notifynumber, 0, word);
223             continue;
224         }
225         default:;
226         }
227 
228         // If a keyboard is inactive, it must be activated before receiving any other commands
229         if(!kb->active){
230             if(command == ACTIVE)
231                 TRY_WITH_RESET(vt->active(kb, mode, notifynumber, 0, 0));
232             continue;
233         }
234         // Specially handled commands only available when keyboard is ACTIVE
235         switch(command){
236         case IDLE:
237             TRY_WITH_RESET(vt->idle(kb, mode, notifynumber, 0, 0));
238             continue;
239         case SWITCH:
240             if(profile->currentmode != mode){
241                 profile->currentmode = mode;
242                 // Set mode light for non-RGB K95
243                 int index = INDEX_OF(mode, profile->mode);
244                 vt->setmodeindex(kb, index);
245             }
246             continue;
247         case HWLOAD: case HWSAVE:{
248             char delay = kb->usbdelay;
249             // Ensure delay of at least 10ms as the device can get overwhelmed otherwise
250             if(delay < 10)
251                 kb->usbdelay = 10;
252             // Try to load/save the hardware profile\&. Reset on failure, disconnect if reset fails\&.
253             TRY_WITH_RESET(vt->do_io[command](kb, mode, notifynumber, 1, 0));
254             // Re-send the current RGB state as it sometimes gets scrambled
255             TRY_WITH_RESET(vt->updatergb(kb, 1));
256             kb->usbdelay = delay;
257             continue;
258         }
259         case FWUPDATE:
260             // FW update parses a whole word\&. Unlike hwload/hwsave, there's no try again on failure\&.
261             if(vt->fwupdate(kb, mode, notifynumber, 0, word)){
262                 free(word);
263                 return 1;
264             }
265             continue;
266         case POLLRATE: {
267             uint rate;
268             if(sscanf(word, "%u", &rate) == 1 && (rate == 1 || rate == 2 || rate == 4 || rate == 8))
269                 TRY_WITH_RESET(vt->pollrate(kb, mode, notifynumber, rate, 0));
270             continue;
271         }
272         case ERASEPROFILE:
273             // Erase the current profile
274             vt->eraseprofile(kb, mode, notifynumber, 0, 0);
275             // Update profile/mode pointers
276             profile = kb->profile;
277             mode = profile->currentmode;
278             continue;
279         case ERASE: case NAME: case IOFF: case ION: case IAUTO: case INOTIFY: case PROFILENAME: case ID: case PROFILEID: case DPISEL: case LIFT: case SNAP:
280             // All of the above just parse the whole word
281             vt->do_cmd[command](kb, mode, notifynumber, 0, word);
282             continue;
283         case RGB: {
284             // RGB command has a special response for a single hex constant
285             int r, g, b;
286             if(sscanf(word, "%02x%02x%02x", &r, &g, &b) == 3){
287                 // Set all keys
288                 for(int i = 0; i < N_KEYS_EXTENDED; i++)
289                     vt->rgb(kb, mode, notifynumber, i, word);
290                 continue;
291             }
292             break;
293         }
294         case MACRO:
295             if(!strcmp(word, "clear")){
296                 // Macro has a special clear command
297                 vt->macro(kb, mode, notifynumber, 0, 0);
298                 continue;
299             }
300             break;
301         default:;
302         }
303         // For anything else, split the parameter at the colon
304         int left = -1;
305         sscanf(word, "%*[^:]%n", &left);
306         if(left <= 0)
307             continue;
308         const char* right = word + left;
309         if(right[0] == ':')
310             right++;
311         // Macros and DPI have a separate left-side handler
312         if(command == MACRO || command == DPI){
313             word[left] = 0;
314             vt->do_macro[command](kb, mode, notifynumber, word, right);
315             continue;
316         }
317         // Scan the left side for key names and run the requested command
318         int position = 0, field = 0;
319         char keyname[11];
320         while(position < left && sscanf(word + position, "%10[^:,]%n", keyname, &field) == 1){
321             int keycode;
322             if(!strcmp(keyname, "all")){
323                 // Set all keys
324                 for(int i = 0; i < N_KEYS_EXTENDED; i++)
325                     vt->do_cmd[command](kb, mode, notifynumber, i, right);
326             } else if((sscanf(keyname, "#%d", &keycode) && keycode >= 0 && keycode < N_KEYS_EXTENDED)
327                       || (sscanf(keyname, "#x%x", &keycode) && keycode >= 0 && keycode < N_KEYS_EXTENDED)){
328                 // Set a key numerically
329                 vt->do_cmd[command](kb, mode, notifynumber, keycode, right);
330             } else {
331                 // Find this key in the keymap
332                 for(unsigned i = 0; i < N_KEYS_EXTENDED; i++){
333                     if(keymap[i]\&.name && !strcmp(keyname, keymap[i]\&.name)){
334                         vt->do_cmd[command](kb, mode, notifynumber, i, right);
335                         break;
336                     }
337                 }
338             }
339             if(word[position += field] == ',')
340                 position++;
341         }
342     }
343 
344     // Finish up
345     if(!NEEDS_FW_UPDATE(kb)){
346         TRY_WITH_RESET(vt->updatergb(kb, 0));
347         TRY_WITH_RESET(vt->updatedpi(kb, 0));
348     }
349     free(word);
350     return 0;
351 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
