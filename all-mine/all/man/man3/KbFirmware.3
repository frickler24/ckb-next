.TH "KbFirmware" 3 "Sat Jun 3 2017" "Version beta-v0.2.8+testing at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KbFirmware \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kbfirmware\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBFW\fP"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBdownloaded\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBcheckUpdates\fP ()"
.br
.ti -1c
.RI "static bool \fBhasDownloaded\fP ()"
.br
.ti -1c
.RI "static float \fBversionForBoard\fP (const short productID, bool waitForComplete=false)"
.br
.ti -1c
.RI "static QByteArray \fBdataForBoard\fP (const short productID)"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBUNKNOWN\fP = -1, \fBNO\fP, \fBYES\fP }"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBprocessDownload\fP (QNetworkReply *reply)"
.br
.ti -1c
.RI "void \fBdownloadFinished\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKbFirmware\fP ()"
.br
.ti -1c
.RI "\fB~KbFirmware\fP ()"
.br
.ti -1c
.RI "void \fBinitManager\fP ()"
.br
.ti -1c
.RI "bool \fB_checkUpdates\fP ()"
.br
.ti -1c
.RI "float \fB_latestForBoard\fP (const short productID, bool waitForComplete)"
.br
.ti -1c
.RI "QByteArray \fB_fileForBoard\fP (const short productID)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "quint64 \fBlastCheck\fP"
.br
.ti -1c
.RI "quint64 \fBlastFinished\fP"
.br
.ti -1c
.RI "QMap< QString, \fBFW\fP > \fBfwTable\fP"
.br
.ti -1c
.RI "QByteArray \fBfwTableHash\fP"
.br
.ti -1c
.RI "QNetworkAccessManager * \fBnetworkManager\fP"
.br
.ti -1c
.RI "QNetworkReply * \fBtableDownload\fP"
.br
.ti -1c
.RI "enum KbFirmware:: { \&.\&.\&. }  \fBhasGPG\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBKbFirmware\fP \fBinstance\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 10 of file kbfirmware\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN \fP\fP
.TP
\fB\fINO \fP\fP
.TP
\fB\fIYES \fP\fP
.PP
Definition at line 53 of file kbfirmware\&.h\&.
.PP
.nf
53 { UNKNOWN = -1, NO, YES } hasGPG :2;
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KbFirmware::KbFirmware ()\fC [private]\fP"

.PP
Definition at line 14 of file kbfirmware\&.cpp\&.
.PP
.nf
14                        :
15     lastCheck(0), lastFinished(0), networkManager(0), tableDownload(0), hasGPG(UNKNOWN)
16 {
17 }
.fi
.SS "KbFirmware::~KbFirmware ()\fC [private]\fP"

.PP
Definition at line 19 of file kbfirmware\&.cpp\&.
.PP
.nf
19                        {
20     //delete networkManager;
21     // ^ This can cause a crash (QT bug?)
22 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool KbFirmware::_checkUpdates ()\fC [private]\fP"

.PP
Definition at line 30 of file kbfirmware\&.cpp\&.
.PP
References AUTO_CHECK_TIME, downloadFinished(), initManager(), lastCheck, networkManager, and tableDownload\&.
.PP
Referenced by checkUpdates()\&.
.PP
.nf
30                               {
31     initManager();
32     quint64 now = QDateTime::currentMSecsSinceEpoch();
33     if(now < lastCheck + AUTO_CHECK_TIME)
34         return false;
35     // First location is for debugging only\&.
36     tableDownload = networkManager->get(QNetworkRequest(QUrl("https://raw\&.githubusercontent\&.com/frickler24/ckb-next/new-firmware-file-format/FIRMWARE")));
37     // This one is the production one\&.
38     // tableDownload = networkManager->get(QNetworkRequest(QUrl("https://raw\&.githubusercontent\&.com/mattanger/ckb-next/master/FIRMWARE")));
39     connect(tableDownload, SIGNAL(finished()), this, SLOT(downloadFinished()));
40     lastCheck = now;
41     return true;
42 }
.fi
.SS "QByteArray KbFirmware::_fileForBoard (const shortproductID)\fC [private]\fP"

.PP
Definition at line 177 of file kbfirmware\&.cpp\&.
.PP
References QuaZip::csInsensitive, KbFirmware::FW::fileName, fwTable, KbFirmware::FW::hash, QuaZip::mdUnzip, networkManager, QuaZip::open(), QuaZipFile::open(), quit(), QuaZip::setCurrentFile(), and KbFirmware::FW::url\&.
.PP
Referenced by dataForBoard()\&.
.PP
.nf
177                                                          {
178     FW info = fwTable\&.value(QString::number(productID));
179     if(info\&.hash\&.isEmpty())
180         return "";
181     // Download zip from URL\&. Wait for it to finish\&.
182     QNetworkReply* reply = networkManager->get(QNetworkRequest(QUrl(info\&.url)));
183     QEventLoop loop(this);
184     connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
185     loop\&.exec();
186     // Download finished, process data
187     if(reply->error() != QNetworkReply::NoError)
188         return "";
189     QByteArray zipData = reply->readAll();
190     QBuffer buffer(&zipData);
191     // Open zip archive
192     QuaZip zip(&buffer);
193     if(!zip\&.open(QuaZip::mdUnzip))
194         return "";
195     // Find the desired file
196     if(!zip\&.setCurrentFile(info\&.fileName, QuaZip::csInsensitive))
197         return "";
198     QuaZipFile binFile(&zip);
199     if(!binFile\&.open(QIODevice::ReadOnly))
200         return "";
201     QByteArray binary = binFile\&.readAll();
202     // Check the hash
203     if(QCryptographicHash::hash(binary, QCryptographicHash::Sha256) != info\&.hash)
204         return "";
205     return binary;
206 }
.fi
.SS "float KbFirmware::_latestForBoard (const shortproductID, boolwaitForComplete)\fC [private]\fP"
< Only give an error message if we loaded the FIRMWARE file\&. 
.PP
Definition at line 157 of file kbfirmware\&.cpp\&.
.PP
References checkUpdates(), KbManager::ckbDaemonVersionF(), KbManager::ckbGuiVersionF(), KbFirmware::FW::ckbVersion, downloaded(), fwTable, KbFirmware::FW::fwVersion, KbFirmware::FW::hash, quit(), and tableDownload\&.
.PP
Referenced by versionForBoard()\&.
.PP
.nf
157                                                                              {
158     if((tableDownload || checkUpdates()) && waitForComplete){
159         // If waiting is desired, enter an event loop and stay here until the download is finished
160         QEventLoop loop(this);
161         connect(this, SIGNAL(downloaded()), &loop, SLOT(quit()));
162         loop\&.exec();
163     }
164     // Find this board
165     FW info = fwTable\&.value(QString::number(productID));
166     if (info\&.hash\&.isEmpty()) {
167         if (fwTable\&.count() > 0)        
168             qDebug() << "Can't find valid firmware version for device" << productID << QString::number(productID);
169         return 0\&.f;
170     }
171     // Don't return the new version if the current ckb doesn't support it
172     if(info\&.ckbVersion > KbManager::ckbGuiVersionF() || info\&.ckbVersion > KbManager::ckbDaemonVersionF())
173         return -1\&.f;
174     return info\&.fwVersion;
175 }
.fi
.SS "static bool KbFirmware::checkUpdates ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 15 of file kbfirmware\&.h\&.
.PP
References _checkUpdates(), and instance\&.
.PP
Referenced by _latestForBoard(), and MainWindow::timerTick()\&.
.PP
.nf
15 { return instance\&._checkUpdates(); }
.fi
.SS "static QByteArray KbFirmware::dataForBoard (const shortproductID)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 25 of file kbfirmware\&.h\&.
.PP
References _fileForBoard(), and instance\&.
.PP
Referenced by FwUpgradeDialog::exec()\&.
.PP
.nf
25 { return instance\&._fileForBoard(productID); }
.fi
.SS "void KbFirmware::downloaded ()\fC [signal]\fP"

.PP
Definition at line 148 of file moc_kbfirmware\&.cpp\&.
.PP
Referenced by _latestForBoard(), and downloadFinished()\&.
.PP
.nf
149 {
150     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
151 }
.fi
.SS "void KbFirmware::downloadFinished ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 148 of file kbfirmware\&.cpp\&.
.PP
References downloaded(), processDownload(), and tableDownload\&.
.PP
Referenced by _checkUpdates()\&.
.PP
.nf
148                                  {
149     if(!tableDownload)
150         return;
151     processDownload(tableDownload);
152     tableDownload->deleteLater();
153     tableDownload = 0;
154     emit downloaded();
155 }
.fi
.SS "static bool KbFirmware::hasDownloaded ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 18 of file kbfirmware\&.h\&.
.PP
References instance, and lastFinished\&.
.PP
Referenced by KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.PP
.nf
18 { return instance\&.lastFinished != 0; }
.fi
.SS "void KbFirmware::initManager ()\fC [private]\fP"

.PP
Definition at line 24 of file kbfirmware\&.cpp\&.
.PP
References networkManager\&.
.PP
Referenced by _checkUpdates()\&.
.PP
.nf
24                             {
25     if(networkManager)
26         return;
27     networkManager = new QNetworkAccessManager();
28 }
.fi
.SS "void KbFirmware::processDownload (QNetworkReply *reply)\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 44 of file kbfirmware\&.cpp\&.
.PP
References KbFirmware::FW::ckbVersion, KbFirmware::FW::fileName, fwTable, fwTableHash, KbFirmware::FW::fwVersion, hasGPG, KbFirmware::FW::hash, lastCheck, lastFinished, NO, KbManager::parseVersionString(), KbFirmware::FW::productID, UNKNOWN, KbFirmware::FW::url, and YES\&.
.PP
Referenced by downloadFinished()\&.
.PP
.nf
44                                                     {
45     if(reply->error() != QNetworkReply::NoError)
46         return;
47     // Update last check
48     lastCheck = lastFinished = QDateTime::currentMSecsSinceEpoch();
49     QByteArray data = reply->readAll();
50     // Don't do anything if this is the same as the last version downloaded
51     QByteArray hash = QCryptographicHash::hash(data, QCryptographicHash::Sha256);
52     if(hash == fwTableHash)
53         return;
54     fwTableHash = hash;
55     if(hasGPG == UNKNOWN){
56         // Check for a GPG installation
57         QProcess gpg;
58         gpg\&.start("gpg", QStringList("--version"));
59         gpg\&.waitForFinished();
60         if(gpg\&.error() == QProcess::FailedToStart)
61             // No GPG install
62             hasGPG = NO;
63         else {
64             QString output = QString::fromUtf8(gpg\&.readAll());
65             // Must support RSA keys and SHA256
66             if(output\&.contains("RSA", Qt::CaseInsensitive) && output\&.contains("SHA256", Qt::CaseInsensitive))
67                 hasGPG = YES;
68             else
69                 hasGPG = NO;
70         }
71         if(!hasGPG)
72             qDebug() << "No GPG detected, signature verification disabled";
73     }
74     if(hasGPG){
75         // If GPG is available, check the signature on the file before proceeding\&.
76         QDir tmp = QDir::temp();
77         // Save file to a temporary path\&. Include PID to avoid conflicts
78         qint64 pid = QCoreApplication::applicationPid();
79         QString fwPath = tmp\&.absoluteFilePath(QString("ckb-%1-firmware")\&.arg(pid));
80         QFile firmware(fwPath);
81         if(!firmware\&.open(QIODevice::WriteOnly)
82                 || firmware\&.write(data) != data\&.length()){
83             qDebug() << "Failed to write firmware file to temporary location, aborting firmware check";
84             return;
85         }
86         firmware\&.close();
87         // Write GPG key
88         QString keyPath = tmp\&.absoluteFilePath(QString("ckb-%1-key\&.gpg")\&.arg(pid));
89         if(!QFile::copy(":/bin/ckb-next-key\&.gpg", keyPath)){
90             firmware\&.remove();
91             qDebug() << "Failed to write GPG key to temporary location, aborting firmware check";
92             return;
93         }
94         // Check signature
95         QProcess gpg;
96         gpg\&.start("gpg", QStringList("--no-default-keyring") << "--keyring" << keyPath << "--verify" << fwPath);
97         gpg\&.waitForFinished();
98         // Clean up temp files
99         tmp\&.remove(fwPath);
100         tmp\&.remove(keyPath);
101         if(gpg\&.error() != QProcess::UnknownError || gpg\&.exitCode() != 0){
102             qDebug() << "GPG couldn't verify firmware signature:";
103             qDebug() << gpg\&.readAllStandardOutput();
104             qDebug() << gpg\&.readAllStandardError();
105             return;
106         }
107         // Signature good, proceed to update database
108     }
109     fwTable\&.clear();
110     QStringList lines = QString::fromUtf8(data)\&.split("\n");
111     bool scan = false;
112     foreach(QString line, lines){
113         // Collapse whitespace
114         line\&.replace(QRegExp("\\s+"), " ")\&.remove(QRegExp("^\\s"))\&.remove(QRegExp("\\s$"));
115         // Skip empty or commented-out lines
116         if(line\&.length() == 0 || line\&.at(0) == '#')
117             continue;
118         // Don't read anything until the entries begin and don't read anything after they end
119         if(!scan){
120             if(line == "!BEGIN FW ENTRIES")
121                 scan = true;
122             else
123                 continue;
124         }
125         if(line == "!END FW ENTRIES")
126             break;
127         QStringList components = line\&.split(" ");
128         if(components\&.length() != 8)
129             continue;
130         // "VENDOR-PRODUCT"
131         QString device = components[0]\&.toUpper() + "-" + components[1]\&.toUpper();
132         bool ok;
133         FW fw;
134         fw\&.fwVersion = components[2]\&.toFloat();                             // Firmware blob version
135         fw\&.url = QUrl::fromPercentEncoding(components[3]\&.toLatin1());       // URL to zip file
136         fw\&.ckbVersion = KbManager::parseVersionString(components[4]);       // Minimum ckb version
137         fw\&.fileName = QUrl::fromPercentEncoding(components[5]\&.toLatin1());  // Name of file inside zip
138         fw\&.hash = QByteArray::fromHex(components[6]\&.toLatin1());            // SHA256 of file inside zip
139         fw\&.productID = components[7]\&.toShort(&ok, 16);                      // Hex productID assigned to this FW
140         // Update entry
141         fwTable[QString::number(fw\&.productID)] = fw;
142         // qDebug() << "saving fwTabel entry[" << QString::number(fw\&.productID) << "] for device" << device
143         //         << fw\&.fwVersion << fw\&.fileName << fw\&.url << "for ckb-next version >=" << fw\&.ckbVersion;
144     }
145     qDebug() << "Downloaded new firmware list\&." << fwTable\&.count() << "entries found\&.";
146 }
.fi
.SS "static float KbFirmware::versionForBoard (const shortproductID, boolwaitForComplete = \fCfalse\fP)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 22 of file kbfirmware\&.h\&.
.PP
References _latestForBoard(), and instance\&.
.PP
Referenced by MainWindow::checkFwUpdates(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.PP
.nf
22 { return instance\&._latestForBoard(productID, waitForComplete); }
.fi
.SH "Field Documentation"
.PP 
.SS "QMap<QString, \fBFW\fP> KbFirmware::fwTable\fC [private]\fP"

.PP
Definition at line 41 of file kbfirmware\&.h\&.
.PP
Referenced by _fileForBoard(), _latestForBoard(), and processDownload()\&.
.SS "QByteArray KbFirmware::fwTableHash\fC [private]\fP"

.PP
Definition at line 43 of file kbfirmware\&.h\&.
.PP
Referenced by processDownload()\&.
.SS "enum { \&.\&.\&. }   KbFirmware::hasGPG\fC [private]\fP"

.PP
Referenced by processDownload()\&.
.SS "\fBKbFirmware\fP KbFirmware::instance\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 59 of file kbfirmware\&.h\&.
.PP
Referenced by checkUpdates(), dataForBoard(), hasDownloaded(), and versionForBoard()\&.
.SS "quint64 KbFirmware::lastCheck\fC [private]\fP"

.PP
Definition at line 32 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), and processDownload()\&.
.SS "quint64 KbFirmware::lastFinished\fC [private]\fP"

.PP
Definition at line 32 of file kbfirmware\&.h\&.
.PP
Referenced by hasDownloaded(), and processDownload()\&.
.SS "QNetworkAccessManager* KbFirmware::networkManager\fC [private]\fP"

.PP
Definition at line 47 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), _fileForBoard(), and initManager()\&.
.SS "QNetworkReply* KbFirmware::tableDownload\fC [private]\fP"

.PP
Definition at line 50 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), _latestForBoard(), and downloadFinished()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
