.TH "KbFirmware" 3 "Sat May 27 2017" "Version v0.2.8 at branch all-mine" "ckb-next" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KbFirmware \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <src/ckb/kbfirmware\&.h>\fP
.PP
Inherits \fBQObject\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBFW\fP"
.br
.in -1c
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBdownloaded\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBcheckUpdates\fP ()"
.br
.ti -1c
.RI "static bool \fBhasDownloaded\fP ()"
.br
.ti -1c
.RI "static float \fBversionForBoard\fP (const QString &features, bool waitForComplete=false)"
.br
.ti -1c
.RI "static QByteArray \fBdataForBoard\fP (const QString &features)"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBUNKNOWN\fP = -1, \fBNO\fP, \fBYES\fP }"
.br
.in -1c
.SS "Private Slots"

.in +1c
.ti -1c
.RI "void \fBprocessDownload\fP (QNetworkReply *reply)"
.br
.ti -1c
.RI "void \fBdownloadFinished\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBKbFirmware\fP ()"
.br
.ti -1c
.RI "\fB~KbFirmware\fP ()"
.br
.ti -1c
.RI "void \fBinitManager\fP ()"
.br
.ti -1c
.RI "bool \fB_checkUpdates\fP ()"
.br
.ti -1c
.RI "float \fB_latestForBoard\fP (const QString &features, bool waitForComplete)"
.br
.ti -1c
.RI "QByteArray \fB_fileForBoard\fP (const QString &features)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "quint64 \fBlastCheck\fP"
.br
.ti -1c
.RI "quint64 \fBlastFinished\fP"
.br
.ti -1c
.RI "QMap< QString, \fBFW\fP > \fBfwTable\fP"
.br
.ti -1c
.RI "QByteArray \fBfwTableHash\fP"
.br
.ti -1c
.RI "QNetworkAccessManager * \fBnetworkManager\fP"
.br
.ti -1c
.RI "QNetworkReply * \fBtableDownload\fP"
.br
.ti -1c
.RI "enum KbFirmware:: { \&.\&.\&. }  \fBhasGPG\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBKbFirmware\fP \fBinstance\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 10 of file kbfirmware\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN \fP\fP
.TP
\fB\fINO \fP\fP
.TP
\fB\fIYES \fP\fP
.PP
Definition at line 53 of file kbfirmware\&.h\&.
.PP
.nf
53 { UNKNOWN = -1, NO, YES } hasGPG :2;
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "KbFirmware::KbFirmware ()\fC [private]\fP"

.PP
Definition at line 16 of file kbfirmware\&.cpp\&.
.PP
.nf
16                        :
17     lastCheck(0), lastFinished(0), networkManager(0), tableDownload(0), hasGPG(UNKNOWN)
18 {
19 }
.fi
.SS "KbFirmware::~KbFirmware ()\fC [private]\fP"

.PP
Definition at line 21 of file kbfirmware\&.cpp\&.
.PP
.nf
21                        {
22     //delete networkManager;
23     // ^ This can cause a crash (QT bug?)
24 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool KbFirmware::_checkUpdates ()\fC [private]\fP"

.PP
Definition at line 32 of file kbfirmware\&.cpp\&.
.PP
References AUTO_CHECK_TIME, downloadFinished(), initManager(), lastCheck, networkManager, and tableDownload\&.
.PP
Referenced by checkUpdates()\&.
.PP
.nf
32                               {
33     initManager();
34     quint64 now = QDateTime::currentMSecsSinceEpoch();
35     if(now < lastCheck + AUTO_CHECK_TIME)
36         return false;
37     // First location is for debugging only\&.
38     tableDownload = networkManager->get(QNetworkRequest(QUrl("https://raw\&.githubusercontent\&.com/frickler24/ckb-next/new-firmware-file-format/FIRMWARE")));
39     // This one is the production one\&.
40     // tableDownload = networkManager->get(QNetworkRequest(QUrl("https://raw\&.githubusercontent\&.com/mattanger/ckb-next/master/FIRMWARE")));
41     connect(tableDownload, SIGNAL(finished()), this, SLOT(downloadFinished()));
42     lastCheck = now;
43     return true;
44 }
.fi
.SS "QByteArray KbFirmware::_fileForBoard (const QString &features)\fC [private]\fP"

.PP
Definition at line 188 of file kbfirmware\&.cpp\&.
.PP
References QuaZip::csInsensitive, KbFirmware::FW::fileName, fwTable, KbFirmware::FW::hash, QuaZip::mdUnzip, networkManager, QuaZip::open(), QuaZipFile::open(), quit(), QuaZip::setCurrentFile(), tableName(), and KbFirmware::FW::url\&.
.PP
Referenced by dataForBoard()\&.
.PP
.nf
188                                                            {
189     QString name = tableName(features);
190     FW info = fwTable\&.value(name);
191     if(info\&.hash\&.isEmpty())
192         return "";
193     // Download zip from URL\&. Wait for it to finish\&.
194     QNetworkReply* reply = networkManager->get(QNetworkRequest(QUrl(info\&.url)));
195     QEventLoop loop(this);
196     connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
197     loop\&.exec();
198     // Download finished, process data
199     if(reply->error() != QNetworkReply::NoError)
200         return "";
201     QByteArray zipData = reply->readAll();
202     QBuffer buffer(&zipData);
203     // Open zip archive
204     QuaZip zip(&buffer);
205     if(!zip\&.open(QuaZip::mdUnzip))
206         return "";
207     // Find the desired file
208     if(!zip\&.setCurrentFile(info\&.fileName, QuaZip::csInsensitive))
209         return "";
210     QuaZipFile binFile(&zip);
211     if(!binFile\&.open(QIODevice::ReadOnly))
212         return "";
213     QByteArray binary = binFile\&.readAll();
214     // Check the hash
215     if(QCryptographicHash::hash(binary, QCryptographicHash::Sha256) != info\&.hash)
216         return "";
217     return binary;
218 }
.fi
.SS "float KbFirmware::_latestForBoard (const QString &features, boolwaitForComplete)\fC [private]\fP"

.PP
Definition at line 170 of file kbfirmware\&.cpp\&.
.PP
References checkUpdates(), KbManager::ckbDaemonVersionF(), KbManager::ckbGuiVersionF(), KbFirmware::FW::ckbVersion, downloaded(), fwTable, KbFirmware::FW::fwVersion, KbFirmware::FW::hash, quit(), tableDownload, and tableName()\&.
.PP
Referenced by versionForBoard()\&.
.PP
.nf
170                                                                               {
171     if((tableDownload || checkUpdates()) && waitForComplete){
172         // If waiting is desired, enter an event loop and stay here until the download is finished
173         QEventLoop loop(this);
174         connect(this, SIGNAL(downloaded()), &loop, SLOT(quit()));
175         loop\&.exec();
176     }
177     // Find this board
178     QString name = tableName(features);
179     FW info = fwTable\&.value(name);
180     if(info\&.hash\&.isEmpty())
181         return 0\&.f;
182     // Don't return the new version if the current ckb doesn't support it
183     if(info\&.ckbVersion > KbManager::ckbGuiVersionF() || info\&.ckbVersion > KbManager::ckbDaemonVersionF())
184         return -1\&.f;
185     return info\&.fwVersion;
186 }
.fi
.SS "static bool KbFirmware::checkUpdates ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 15 of file kbfirmware\&.h\&.
.PP
References _checkUpdates(), and instance\&.
.PP
Referenced by _latestForBoard(), and MainWindow::timerTick()\&.
.PP
.nf
15 { return instance\&._checkUpdates(); }
.fi
.SS "static QByteArray KbFirmware::dataForBoard (const QString &features)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 25 of file kbfirmware\&.h\&.
.PP
References _fileForBoard(), and instance\&.
.PP
Referenced by FwUpgradeDialog::exec()\&.
.PP
.nf
25 { return instance\&._fileForBoard(features); }
.fi
.SS "void KbFirmware::downloaded ()\fC [signal]\fP"

.PP
Definition at line 148 of file moc_kbfirmware\&.cpp\&.
.PP
Referenced by _latestForBoard(), and downloadFinished()\&.
.PP
.nf
149 {
150     QMetaObject::activate(this, &staticMetaObject, 0, Q_NULLPTR);
151 }
.fi
.SS "void KbFirmware::downloadFinished ()\fC [private]\fP, \fC [slot]\fP"

.PP
Definition at line 149 of file kbfirmware\&.cpp\&.
.PP
References downloaded(), processDownload(), and tableDownload\&.
.PP
Referenced by _checkUpdates()\&.
.PP
.nf
149                                  {
150     if(!tableDownload)
151         return;
152     processDownload(tableDownload);
153     tableDownload->deleteLater();
154     tableDownload = 0;
155     emit downloaded();
156 }
.fi
.SS "static bool KbFirmware::hasDownloaded ()\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 18 of file kbfirmware\&.h\&.
.PP
References instance, and lastFinished\&.
.PP
Referenced by KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.PP
.nf
18 { return instance\&.lastFinished != 0; }
.fi
.SS "void KbFirmware::initManager ()\fC [private]\fP"

.PP
Definition at line 26 of file kbfirmware\&.cpp\&.
.PP
References networkManager\&.
.PP
Referenced by _checkUpdates()\&.
.PP
.nf
26                             {
27     if(networkManager)
28         return;
29     networkManager = new QNetworkAccessManager();
30 }
.fi
.SS "void KbFirmware::processDownload (QNetworkReply *reply)\fC [private]\fP, \fC [slot]\fP"
< CHECKFORGPG is a debug flag\&. Set to 0 if GPG should be ignored 
.PP
Definition at line 46 of file kbfirmware\&.cpp\&.
.PP
References CHECKFORGPG, KbFirmware::FW::ckbVersion, KbFirmware::FW::fileName, KbFirmware::FW::forProductID, fwTable, fwTableHash, KbFirmware::FW::fwVersion, hasGPG, KbFirmware::FW::hash, lastCheck, lastFinished, NO, KbManager::parseVersionString(), UNKNOWN, KbFirmware::FW::url, and YES\&.
.PP
Referenced by downloadFinished()\&.
.PP
.nf
46                                                     {
47     if(reply->error() != QNetworkReply::NoError)
48         return;
49     // Update last check
50     lastCheck = lastFinished = QDateTime::currentMSecsSinceEpoch();
51     QByteArray data = reply->readAll();
52     // Don't do anything if this is the same as the last version downloaded
53     QByteArray hash = QCryptographicHash::hash(data, QCryptographicHash::Sha256);
54     if(hash == fwTableHash)
55         return;
56     fwTableHash = hash;
57     if(hasGPG == UNKNOWN){
58         // Check for a GPG installation
59         QProcess gpg;
60         gpg\&.start("gpg", QStringList("--version"));
61         gpg\&.waitForFinished();
62         if(gpg\&.error() == QProcess::FailedToStart)
63             // No GPG install
64             hasGPG = NO;
65         else {
66             QString output = QString::fromUtf8(gpg\&.readAll());
67             // Must support RSA keys and SHA256
68             if(output\&.contains("RSA", Qt::CaseInsensitive) && output\&.contains("SHA256", Qt::CaseInsensitive))
69                 hasGPG = YES;
70             else
71                 hasGPG = NO;
72         }
73         if(!hasGPG)
74             qDebug() << "No GPG detected, signature verification disabled";
75     }
76     if (hasGPG && CHECKFORGPG) { 
77         // If GPG is available, check the signature on the file before proceeding\&.
78         QDir tmp = QDir::temp();
79         // Save file to a temporary path\&. Include PID to avoid conflicts
80         qint64 pid = QCoreApplication::applicationPid();
81         QString fwPath = tmp\&.absoluteFilePath(QString("ckb-%1-firmware")\&.arg(pid));
82         QFile firmware(fwPath);
83         if(!firmware\&.open(QIODevice::WriteOnly)
84                 || firmware\&.write(data) != data\&.length()){
85             qDebug() << "Failed to write firmware file to temporary location, aborting firmware check";
86             return;
87         }
88         firmware\&.close();
89         // Write GPG key
90         QString keyPath = tmp\&.absoluteFilePath(QString("ckb-%1-key\&.gpg")\&.arg(pid));
91         if(!QFile::copy(":/bin/ckb-next-key\&.gpg", keyPath)){
92             firmware\&.remove();
93             qDebug() << "Failed to write GPG key to temporary location, aborting firmware check";
94             return;
95         }
96         // Check signature
97         QProcess gpg;
98         gpg\&.start("gpg", QStringList("--no-default-keyring") << "--keyring" << keyPath << "--verify" << fwPath);
99         gpg\&.waitForFinished();
100         // Clean up temp files
101         tmp\&.remove(fwPath);
102         tmp\&.remove(keyPath);
103         if(gpg\&.error() != QProcess::UnknownError || gpg\&.exitCode() != 0){
104             qDebug() << "GPG couldn't verify firmware signature:";
105             qDebug() << gpg\&.readAllStandardOutput();
106             qDebug() << gpg\&.readAllStandardError();
107             return;
108         }
109         // Signature good, proceed to update database
110     }
111     fwTable\&.clear();
112     QStringList lines = QString::fromUtf8(data)\&.split("\n");
113     bool scan = false;
114     foreach(QString line, lines){
115         // Collapse whitespace
116         line\&.replace(QRegExp("\\s+"), " ")\&.remove(QRegExp("^\\s"))\&.remove(QRegExp("\\s$"));
117         // Skip empty or commented-out lines
118         if(line\&.length() == 0 || line\&.at(0) == '#')
119             continue;
120         // Don't read anything until the entries begin and don't read anything after they end
121         if(!scan){
122             if(line == "!BEGIN FW ENTRIES")
123                 scan = true;
124             else
125                 continue;
126         }
127         if(line == "!END FW ENTRIES")
128             break;
129         QStringList components = line\&.split(" ");
130         if(components\&.length() != 8)
131             continue;
132         // "VENDOR-PRODUCT"
133         QString device = components[0]\&.toUpper() + "-" + components[1]\&.toUpper();
134         FW fw;
135         fw\&.fwVersion = components[2]\&.toFloat();                             // Firmware blob version
136         fw\&.url = QUrl::fromPercentEncoding(components[3]\&.toLatin1());       // URL to zip file
137         fw\&.ckbVersion = KbManager::parseVersionString(components[4]);       // Minimum ckb version
138         fw\&.fileName = QUrl::fromPercentEncoding(components[5]\&.toLatin1());  // Name of file inside zip
139         fw\&.hash = QByteArray::fromHex(components[6]\&.toLatin1());            // SHA256 of file inside zip
140         bool ok;
141         fw\&.forProductID = components[7]\&.toUInt(&ok, 16);
142         if (!ok) qWarning() << "Could not read product specification from FIRMWARE, value =" << components[7];
143         // Update entry
144         fwTable[device] = fw;
145     }
146     qDebug() << "Downloaded new firmware list\&." << fwTable\&.count() << "entries found\&.";
147 }
.fi
.SS "static float KbFirmware::versionForBoard (const QString &features, boolwaitForComplete = \fCfalse\fP)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line 22 of file kbfirmware\&.h\&.
.PP
References _latestForBoard(), and instance\&.
.PP
Referenced by MainWindow::checkFwUpdates(), KbWidget::on_fwUpdButton_clicked(), and KbWidget::updateFwButton()\&.
.PP
.nf
22 { return instance\&._latestForBoard(features, waitForComplete); }
.fi
.SH "Field Documentation"
.PP 
.SS "QMap<QString, \fBFW\fP> KbFirmware::fwTable\fC [private]\fP"

.PP
Definition at line 41 of file kbfirmware\&.h\&.
.PP
Referenced by _fileForBoard(), _latestForBoard(), and processDownload()\&.
.SS "QByteArray KbFirmware::fwTableHash\fC [private]\fP"

.PP
Definition at line 43 of file kbfirmware\&.h\&.
.PP
Referenced by processDownload()\&.
.SS "enum { \&.\&.\&. }   KbFirmware::hasGPG\fC [private]\fP"

.PP
Referenced by processDownload()\&.
.SS "\fBKbFirmware\fP KbFirmware::instance\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 59 of file kbfirmware\&.h\&.
.PP
Referenced by checkUpdates(), dataForBoard(), hasDownloaded(), and versionForBoard()\&.
.SS "quint64 KbFirmware::lastCheck\fC [private]\fP"

.PP
Definition at line 32 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), and processDownload()\&.
.SS "quint64 KbFirmware::lastFinished\fC [private]\fP"

.PP
Definition at line 32 of file kbfirmware\&.h\&.
.PP
Referenced by hasDownloaded(), and processDownload()\&.
.SS "QNetworkAccessManager* KbFirmware::networkManager\fC [private]\fP"

.PP
Definition at line 47 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), _fileForBoard(), and initManager()\&.
.SS "QNetworkReply* KbFirmware::tableDownload\fC [private]\fP"

.PP
Definition at line 50 of file kbfirmware\&.h\&.
.PP
Referenced by _checkUpdates(), _latestForBoard(), and downloadFinished()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ckb-next from the source code\&.
